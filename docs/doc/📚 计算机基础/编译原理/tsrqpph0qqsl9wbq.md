---
title: 7、代码生成
urlname: tsrqpph0qqsl9wbq
date: '2024-06-28 12:00:48'
updated: '2024-06-28 12:10:09'
cover: 'https://cdn.nlark.com/yuque/__mermaid_v3/cfb5e3a30e2e1c621dbb67a29ec259fa.svg'
description: 'keywords: 代码生成, 目标代码, 指令选择, 寄存器分配, 指令调度---代码生成是编译过程的最后阶段，它将优化后的中间表示转换为目标机器的汇编代码或机器代码。这个阶段直接影响程序的执行效率和资源使用，因此在编译器设计中占据着关键地位。7.1 代码生成概述7.1.1 代码生成的目标和...'
keywords: '代码生成, 目标代码, 指令选择, 寄存器分配, 指令调度'
---
代码生成是编译过程的最后阶段，它将优化后的中间表示转换为目标机器的汇编代码或机器代码。这个阶段直接影响程序的执行效率和资源使用，因此在编译器设计中占据着关键地位。
## 7.1 代码生成概述
### 7.1.1 代码生成的目标和挑战
代码生成的主要目标是生成正确、高效的目标代码。具体包括：

1. 正确性：生成的代码必须准确实现源程序的语义。
2. 效率：生成的代码应该高效利用目标机器的资源。
3. 紧凑性：生成的代码应该尽可能小，以减少内存占用。
4. 可重定位性：生成的代码应该易于在内存中重定位。

代码生成面临的主要挑战包括：

- 指令选择：为中间代码选择最合适的目标机器指令。
- 寄存器分配：有效管理有限的寄存器资源。
- 指令调度：安排指令执行顺序以最大化并行性。
- 目标机器特性的利用：充分利用特定处理器的特殊指令和功能。
### 7.1.2 代码生成的输入和输出
代码生成器的输入通常是经过优化的中间表示（如三地址码或四元式），输出是目标机器的汇编代码或直接的机器代码。
![](https://oss1.aistar.cool/elog-offer-now/c37e1fdd220c934311b3864294a95263.svg)### 7.1.3 代码生成的主要步骤
代码生成过程通常包括以下主要步骤：

1. 指令选择
2. 指令排序
3. 寄存器分配
4. 指令调度
5. 目标代码优化

这些步骤可能以不同的顺序执行，或者交织在一起进行。
## 7.2 指令选择
指令选择是将中间表示的操作映射到目标机器指令的过程。
### 7.2.1 指令选择的基本策略
指令选择的基本策略包括：

1. 模式匹配：将中间代码模式匹配到目标机器指令模式。
2. 树覆盖：将中间表示的语法树用目标机器指令覆盖。
3. 动态规划：使用动态规划算法找到最优的指令序列。
### 7.2.2 基于树覆盖的指令选择
树覆盖算法将中间表示视为一棵树，然后尝试用目标机器指令"覆盖"这棵树。每个指令对应树的一个子树。
![](https://oss1.aistar.cool/elog-offer-now/ada0e741c242caaf451b340afc40543c.svg)上图表示表达式 `(a + b) * c`。指令选择过程会尝试用目标机器的指令覆盖这棵树，例如：

1. 使用 ADD 指令覆盖 "+" 节点和其子节点。
2. 使用 MUL 指令覆盖 "*" 节点和其子节点。
### 7.2.3 复杂指令集的处理
现代处理器往往具有复杂的指令集，包括多操作数指令、特殊目的指令等。处理这些指令需要更复杂的指令选择算法，如：

- 多模式匹配
- 带成本的树覆盖
- 整数线性规划
## 7.3 寄存器分配
寄存器分配是决定哪些变量在何时存放在寄存器中的过程。由于寄存器访问速度远快于内存，有效的寄存器分配对生成高效代码至关重要。
### 7.3.1 寄存器分配的基本问题
寄存器分配面临的主要问题包括：

1. 寄存器数量有限
2. 不同变量的生命周期可能重叠
3. 某些指令可能要求特定的寄存器
### 7.3.2 图着色寄存器分配
图着色是一种常用的寄存器分配方法。步骤如下：

1. 构建冲突图：节点表示变量，边表示变量生命周期重叠。
2. 为图着色：每种颜色代表一个寄存器。
3. 如果无法用给定数量的颜色着色，则溢出某些变量到内存。
![](https://oss1.aistar.cool/elog-offer-now/a02521c1ce9465a6c74397deb517b94f.svg)上图展示了一个变量冲突图。假设我们有3个可用寄存器，一种可能的着色方案是：

- a, d, e 分别使用不同的寄存器
- b 和 c 需要溢出到内存
### 7.3.3 线性扫描寄存器分配
线性扫描是一种更快速但可能次优的寄存器分配算法。它按程序顺序扫描变量的生命周期，为每个变量分配可用的寄存器。
![](https://oss1.aistar.cool/elog-offer-now/28161235db1a640c53580f68da6894e0.svg)上图展示了变量生命周期，线性扫描算法会按时间顺序处理这些生命周期，尽可能复用寄存器。
### 7.3.4 寄存器分配的优化策略
一些常用的优化策略包括：

1. 寄存器合并：将多个短生命周期的变量分配到同一个寄存器。
2. 寄存器重命名：通过重命名寄存器来延长变量在寄存器中的生命周期。
3. 循环优化：优先为循环中的变量分配寄存器。
## 7.4 指令调度
指令调度旨在重新排列指令顺序，以最大化指令级并行性，充分利用现代处理器的流水线和多发射能力。
### 7.4.1 基本块内指令调度
基本块内指令调度试图在不改变程序语义的前提下，重新排列基本块内的指令顺序。
上图展示了一个基本块的指令依赖关系。一个可能的优化调度是：

1. load r1, [addr1]
2. load r2, [addr2]
3. add r3, r1, r2
4. store [addr3], r3

这样可以让两个 load 指令并行执行，利用内存访问的延迟时间。
### 7.4.2 全局指令调度
全局指令调度在更大的范围内移动指令，可能跨越基本块边界。常见技术包括：

1. 跟踪调度（Trace Scheduling）
2. 超级块调度（Superblock Scheduling）
3. 区域调度（Region Scheduling）
### 7.4.3 软件流水
软件流水是一种循环优化技术，它重新安排循环迭代的指令顺序，使得多个迭代的指令可以并行执行。
![](https://oss1.aistar.cool/elog-offer-now/4e92ff14935645590da73b4adc5c8b62.svg)上图展示了软件流水的效果，其中A、B、C、D代表循环体中的不同阶段。通过重叠不同迭代的执行，可以提高指令级并行性。
## 7.5 目标代码优化
在生成目标代码后，还可以进行一些特定于目标机器的优化。
### 7.5.1 窥孔优化
窥孔优化检查短序列的指令，并用更高效的指令序列替换它们。例如：
```
mov r1, 0
add r1, r1, 1
```
可以优化为：
```
mov r1, 1
```
### 7.5.2 分支优化
分支优化包括：

1. 分支预测：根据静态分析或profile信息优化分支指令。
2. 分支消除：将条件分支转换为条件执行指令。
### 7.5.3 地址计算优化
优化复杂的地址计算，例如将数组索引计算简化为增量更新。
## 7.6 目标相关的代码生成
不同的目标架构可能需要特定的代码生成策略。
### 7.6.1 CISC架构的代码生成
CISC（复杂指令集计算机）架构的特点是指令集丰富，单条指令可能完成复杂的操作。代码生成需要充分利用这些复杂指令。
### 7.6.2 RISC架构的代码生成
RISC（精简指令集计算机）架构的特点是指令简单统一，但执行速度快。代码生成需要更多地关注指令调度和寄存器使用。
### 7.6.3 VLIW架构的代码生成
VLIW（超长指令字）架构依赖编译器来安排并行指令。代码生成需要进行更复杂的指令打包和调度。
## 7.7 代码生成的评估与优化
### 7.7.1 性能度量
评估生成代码质量的指标包括：

1. 执行时间
2. 代码大小
3. 能耗
4. 缓存性能
### 7.7.2 反馈导向优化
使用实际运行的profile信息来指导代码生成和优化决策。
### 7.7.3 自适应优化
在运行时动态重新编译和优化热点代码，以适应实际的执行情况。
## 7.8 新兴技术和未来方向
### 7.8.1 机器学习辅助的代码生成
使用机器学习技术来改进指令选择、寄存器分配等决策。
### 7.8.2 针对新型硬件架构的代码生成
为量子计算机、神经网络处理器等新型硬件生成专门的代码。
### 7.8.3 跨平台代码生成
开发更强大的跨平台代码生成技术，以支持日益多样化的计算设备。
本章详细介绍了代码生成的各个方面，从基本的指令选择到复杂的指令调度和目标相关优化。这些技术共同构成了现代编译器后端的核心，为生成高效、可靠的目标代码提供了基础。随着计算机架构和应用需求的不断发展，代码生成技术也在持续演进，以应对新的挑战和机遇。
