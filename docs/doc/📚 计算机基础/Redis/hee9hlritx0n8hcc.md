---
title: "Redis面试高频问题\U0001F525"
urlname: hee9hlritx0n8hcc
date: '2024-05-24 15:38:11'
updated: '2024-06-03 15:31:59'
description: 一、什么是Redis？1. 什么是Redis？回答：Redis（Remote Dictionary Server）是一个开源的、基于内存的数据结构存储系统。它可以用作数据库、缓存和消息代理。Redis支持多种数据结构，如字符串（Strings）、散列（Hashes）、列表（Lists）、集合（...
---
### 一、什么是Redis？
#### 1. **什么是Redis？**

**回答**：
Redis（Remote Dictionary Server）是一个开源的、基于内存的数据结构存储系统。它可以用作数据库、缓存和消息代理。Redis支持多种数据结构，如字符串（Strings）、散列（Hashes）、列表（Lists）、集合（Sets）、有序集合（Sorted Sets）等。Redis的数据存储在内存中，因此读写操作非常快速，但也支持将数据持久化到磁盘。Redis提供了丰富的功能，包括事务、发布订阅、Lua脚本、键过期和Eviction（数据淘汰）策略。

#### 2. **Redis和Memcached有什么区别？**

**回答**：
Redis与Memcached都是流行的内存缓存系统，但它们在功能、数据结构和应用场景上有显著区别：

-  **数据类型支持**： 
   - Redis支持丰富的数据类型，包括字符串、列表、集合、散列和有序集合等。
   - Memcached只支持简单的key-value（键值对）存储。
-  **持久化**： 
   - Redis支持持久化，可以将数据存储到磁盘上，通过RDB快照和AOF日志实现数据持久化。
   - Memcached不支持持久化数据，所有数据都仅存储在内存中，重启后数据会丢失。
-  **分布式特性**： 
   - Redis支持主从复制、哨兵和集群模式，提供高可用性和数据分片功能。
   - Memcached通过客户端实现分布式缓存，但不具备原生的高可用性和数据分片功能。
-  **内存管理**： 
   - Redis有多种内存驱逐策略（如LRU、LFU等），可以根据需求选择合适的策略。
   - Memcached采用LRU（Least Recently Used）策略进行内存管理。
-  **功能特性**： 
   - Redis支持事务、Lua脚本、发布订阅、键过期和Eviction策略等高级功能。
   - Memcached功能相对简单，主要用于缓存数据。

#### 3. **为什么用Redis作为MySQL的缓存？**

**回答**：
将Redis用作MySQL的缓存有以下几个主要原因：

-  **性能优势**： 
   - Redis是基于内存的存储系统，读写速度非常快，通常在微秒级别。而MySQL是磁盘存储，读写速度较慢，尤其是复杂查询和大量数据操作时，响应时间较长。
   - 使用Redis缓存可以显著减少对MySQL的直接访问，降低数据库负载，提高整体系统性能。
-  **数据一致性**： 
   - Redis提供了主从复制、持久化等功能，可以保证数据的一致性和高可用性。
   - 通过合理设计缓存和数据库同步机制，可以确保缓存数据和数据库数据的一致性。
-  **缓存策略**： 
   - Redis支持多种缓存淘汰策略（如LRU、LFU等），可以根据业务需求选择合适的策略，优化内存使用。
   - Redis支持设置键的过期时间，可以自动删除过期数据，保持缓存的新鲜度。
-  **灵活性**： 
   - Redis支持多种数据结构，可以灵活地缓存各种类型的数据，如字符串、列表、集合等，满足不同的业务需求。
   - Redis提供了丰富的API和命令，便于开发和运维。
-  **扩展性**： 
   - Redis支持集群模式，可以通过数据分片实现水平扩展，适应大规模数据和高并发访问的需求。
   - Redis的哨兵模式和主从复制机制，可以实现高可用性和故障恢复，保证系统的稳定性和可靠性。

### 二、Redis 数据结构

#### 4. **Redis数据类型以及使用场景分别是什么？**

**回答**：
Redis支持多种数据类型，每种数据类型都有特定的使用场景：

-  **字符串（String）**： 
   - **使用场景**：缓存简单的键值对数据，如用户信息、配置参数、计数器等。
   - **命令**：`SET`、`GET`、`INCR`、`DECR`、`APPEND`等。
-  **哈希（Hash）**： 
   - **使用场景**：存储对象类型的数据，如用户信息、商品详情等。可以通过字段访问对象的各个属性。
   - **命令**：`HSET`、`HGET`、`HGETALL`、`HMSET`等。
-  **列表（List）**： 
   - **使用场景**：消息队列、任务列表、时间序列数据等。支持从两端插入和弹出元素。
   - **命令**：`LPUSH`、`RPUSH`、`LPOP`、`RPOP`、`LRANGE`等。
-  **集合（Set）**： 
   - **使用场景**：存储无序且唯一的元素，如标签、朋友列表等。支持集合运算（交集、并集、差集）。
   - **命令**：`SADD`、`SREM`、`SMEMBERS`、`SINTER`、`SUNION`等。
-  **有序集合（Sorted Set）**： 
   - **使用场景**：排行榜、计分系统等。每个元素关联一个分数，根据分数进行排序。
   - **命令**：`ZADD`、`ZSCORE`、`ZRANGE`、`ZRANK`、`ZREVRANK`等。

#### 5. **五种常见的Redis数据类型是怎么实现的？**

**回答**：

-  **字符串（String）**： 
   - **实现方式**：Redis使用简单动态字符串（SDS）实现字符串类型。SDS是一种动态字符串结构，支持高效的字符串操作和内存管理。
   - **数据结构**：
```c
struct sdshdr {
    int len;     // 字符串长度
    int free;    // 未使用空间长度
    char buf[];  // 存放字符串的数组
};
```
 

-  **哈希（Hash）**： 
   - **实现方式**：Redis的哈希类型使用两种数据结构实现，分别是哈希表和压缩列表。 
      - 哈希表：当哈希包含的键值对较多时，使用哈希表实现。
      - 压缩列表：当哈希包含的键值对较少时，使用压缩列表（ziplist）实现。
   - **数据结构**： 
      - 哈希表：
```c
typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;
```
 

      - 压缩列表：
```c
struct ziplist {
    unsigned int zlbytes;
    unsigned int zltail;
    unsigned int zllen;
    unsigned char zlentry[];
};
```
 

-  **列表（List）**： 
   - **实现方式**：Redis的列表类型使用双向链表和压缩列表实现。 
      - 双向链表：当列表包含的元素较多时，使用双向链表实现。
      - 压缩列表：当列表包含的元素较少时，使用压缩列表（ziplist）实现。
   - **数据结构**： 
      - 双向链表：
```c
typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;
```
 

      - 压缩列表：
```c
struct ziplist {
    unsigned int zlbytes;
    unsigned int zltail;
    unsigned int zllen;
    unsigned char zlentry[];
};
```
 

-  **集合（Set）**： 
   - **实现方式**：Redis的集合类型使用两种数据结构实现，分别是哈希表和整数集合。 
      - 哈希表：当集合包含的元素较多且不全是整数时，使用哈希表实现。
      - 整数集合：当集合包含的元素较少且全是整数时，使用整数集合（intset）实现。
   - **数据结构**： 
      - 哈希表：
```c
typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;
```
 

      - 整数集合：
```c
typedef struct intset {
    uint32_t encoding;
    uint32_t length;
    int8_t contents[];
} intset;
```
 

-  **有序集合（Sorted Set）**： 
   - **实现方式**：Redis的有序集合类型使用跳表和哈希表组合实现。 
      - 跳表：用于按分数排序元素。
      - 哈希表：用于存储元素和分数的映射关系。
   - 数据结构;TODO,带补充~
### 三、Redis 线程模型

#### 6. **Redis是单线程吗？**

**回答**：
是的，Redis的命令执行部分是单线程的。这意味着Redis在处理客户端请求时使用单线程来执行所有命令。这种设计简化了Redis的实现和维护，但也带来了高效的性能。

#### 7. **Redis单线程模式是怎样的？**

**回答**：
Redis单线程模式主要依赖于事件循环和I/O多路复用机制。单线程处理所有命令请求，避免了多线程中的上下文切换和锁竞争问题。

使用Mermaid语法展示Redis单线程模式的工作流程：


#### 8. **Redis采用单线程为什么还这么快？**

**回答**：
Redis采用单线程但仍然很快，主要有以下几个原因：

- **内存操作**：Redis所有数据都存储在内存中，读写速度非常快。
- **非阻塞I/O**：Redis使用I/O多路复用技术（如epoll），高效处理大量的并发连接。
- **高效的数据结构**：Redis设计了高效的基本数据结构（如SDS、跳表等），保证操作的时间复杂度低。
- **避免上下文切换**：单线程模式避免了多线程中的上下文切换和竞争锁，提高了CPU利用率。

#### 9. **Redis 6.0之前为什么使用单线程？**

**回答**：
Redis 6.0之前使用单线程，主要是为了简化设计和避免多线程带来的复杂性。单线程模式避免了多线程中的数据竞争和锁管理问题，提高了系统的稳定性和可预测性。此外，单线程模型在大多数情况下已经能够满足高性能的要求。

#### 10. **Redis 6.0之后为什么引入了多线程？**

**回答**：
Redis 6.0之后引入了多线程，主要是为了优化网络I/O处理，进一步提升并发性能。多线程用于处理客户端的网络读写操作，而命令执行仍然是单线程的。这样既保持了单线程的简单性和高效性，又利用多线程提高了网络I/O的并发能力。

使用Mermaid语法展示Redis 6.0之后的多线程模型：


### 四、Redis 持久化

#### 11. **Redis如何实现数据不丢失？**

**回答**：
Redis通过两种主要的持久化机制来实现数据不丢失：RDB（Redis DataBase）快照和AOF（Append Only File）日志。

#### 12. **AOF日志是如何实现的？**

**回答**：
AOF（Append Only File）日志记录每个写操作到文件中，Redis重启时通过重放AOF文件中的写操作来恢复数据。AOF提供了三种同步策略：每次写操作后、每秒一次和从不。默认策略是每秒一次，兼顾了性能和数据安全。

使用Mermaid语法展示AOF日志的实现流程：


#### 13. **RDB快照是如何实现的？**

**回答**：
RDB（Redis DataBase）快照是将内存中的数据生成快照并保存到磁盘的二进制文件中。Redis通过定期保存RDB文件来实现数据持久化。RDB保存的频率可以通过配置文件中的`save`参数进行设置。

使用Mermaid语法展示RDB快照的实现流程：


#### 14. **为什么会有混合持久化？**

**回答**：
混合持久化是指同时使用RDB和AOF两种持久化方式，以达到数据恢复的快速性和数据持久性的兼顾。混合持久化的优势在于：

- **快速启动**：通过加载最新的RDB文件，快速恢复大部分数据。
- **数据安全**：通过重放AOF日志，恢复最近的写操作，确保数据的完整性和一致性。

使用Mermaid语法展示混合持久化的流程：


### 五、Redis 集群

#### 15. **Redis如何实现服务高可用？**

**回答**：
Redis通过主从复制、哨兵机制和集群模式来实现服务的高可用。

- **主从复制**：一个主节点（Master）可以有多个从节点（Slave），从节点实时同步主节点的数据。主节点故障时，从节点可以升级为主节点，继续提供服务。
- **哨兵机制（Sentinel）**：哨兵监控Redis主从架构中的主节点和从节点，自动进行故障转移（Failover），保证系统的高可用性。
- **集群模式（Cluster）**：Redis集群允许数据分布在多个节点上，通过数据分片（Sharding）实现水平扩展和高可用。每个数据分片都有主从节点，确保高可用性。

使用Mermaid语法展示Redis主从复制和哨兵机制：


#### 16. **集群脑裂导致数据丢失怎么办？**

**回答**：
集群脑裂是指Redis集群中的部分节点由于网络分区或其他原因，导致无法正常通信，形成两个或多个独立的子集群，各自认为自己是主节点。这可能导致数据不一致和数据丢失。

解决集群脑裂导致的数据丢失可以采取以下措施：

- **增加哨兵节点**：增加哨兵节点数量，确保在网络分区时，哨兵能够正确识别主节点状态，避免错误的故障转移。
- **配置quorum参数**：设置合理的quorum参数，确保在网络分区时，只有超过半数的哨兵同意才进行故障转移。
- **定期备份**：定期备份Redis数据，确保在发生脑裂时，可以通过备份进行数据恢复。
- **网络优化**：优化网络配置，减少网络分区的可能性。

### 六、Redis 过期删除与内存淘汰

#### 17. **Redis使用的过期删除策略是什么？**

**回答**：
Redis使用两种过期删除策略：

- **惰性删除（Lazy Deletion）**：当访问一个键时，Redis检查其是否过期，如果过期则删除该键。惰性删除不会主动扫描所有键，只在访问时才检查，大大减少了CPU消耗。
- **定期删除（Periodic Deletion）**：Redis定期（默认每100ms）随机抽取一部分键，检查并删除过期的键。这种方式可以避免内存中充满过期键，但可能在某些情况下无法及时清理所有过期键。

使用Mermaid语法展示惰性删除和定期删除的流程：


#### 18. **Redis持久化时，对过期键会如何处理？**

**回答**：
Redis在持久化过程中对过期键的处理方式因持久化方式不同而有所区别。

-  **RDB持久化**： 
   - 在生成RDB快照时，Redis会检查所有键，如果发现某个键已经过期，则不会将其包含在快照中。这样可以确保RDB文件中没有过期的数据。
-  **AOF持久化**： 
   - 在AOF持久化过程中，过期键的删除操作会被记录在AOF文件中。当Redis重启并重放AOF文件时，这些删除操作会被执行，确保过期键不会存在于内存中。

使用Mermaid语法展示RDB和AOF持久化的过期键处理：


#### 19. **Redis主从模式中，对过期键会如何处理？**

**回答**：
在Redis的主从模式中，过期键的处理遵循以下原则：

-  **主节点（Master）**： 
   - 主节点负责管理所有键的过期状态。当一个键在主节点过期并被删除时，主节点会将删除操作同步到所有从节点。
-  **从节点（Slave）**： 
   - 从节点不会独立管理键的过期状态，而是由主节点通知它们删除过期键。
   - 这种设计确保了主从节点之间的一致性，避免了主从节点之间的冲突。

使用Mermaid语法展示主从模式中过期键的处理流程：


#### 20. **Redis内存满了，会发生什么？**

**回答**：
当Redis内存使用达到配置的最大内存限制（maxmemory）时，Redis会启用内存淘汰机制，根据配置的策略删除部分数据，以腾出空间存储新数据。如果没有配置内存淘汰策略，Redis会返回错误，指出内存不足，无法执行写操作。

#### 21. **Redis内存淘汰策略有哪些？**

**回答**：
Redis支持多种内存淘汰策略，可以根据不同的业务需求选择合适的策略：

- **noeviction**：当内存达到最大限制时，不再执行任何写操作，直接返回错误。
- **allkeys-lru**：使用LRU算法，从所有键中选择最近最少使用的键进行删除。
- **volatile-lru**：使用LRU算法，从设置了过期时间的键中选择最近最少使用的键进行删除。
- **allkeys-random**：从所有键中随机选择键进行删除。
- **volatile-random**：从设置了过期时间的键中随机选择键进行删除。
- **volatile-ttl**：从设置了过期时间的键中选择即将过期的键进行删除。

使用Mermaid语法展示内存淘汰策略：


#### 22. **LRU算法和LFU算法有什么区别？**

**回答**：
LRU（Least Recently Used）和LFU（Least Frequently Used）都是常见的缓存淘汰算法，但它们的策略不同：

-  **LRU算法**： 
   - LRU算法基于最近使用的时间，淘汰最久未使用的键。
   - 实现方式：使用链表或哈希表加双向链表，记录每个键的访问时间，每次访问键时将其移动到链表头部，淘汰时从链表尾部删除。
-  **LFU算法**： 
   - LFU算法基于使用频率，淘汰使用频率最低的键。
   - 实现方式：使用计数器记录每个键的访问次数，淘汰时选择访问次数最少的键。

使用Mermaid语法展示LRU和LFU算法的区别：


### 七、Redis 缓存设计

#### 23. **如何避免缓存雪崩、缓存击穿、缓存穿透？**

**回答**：

- **缓存雪崩**： 
   - **原因**：大量缓存同时过期，导致大量请求直接打到数据库，造成数据库压力过大。
   - **解决方案**： 
      - 设置不同的缓存过期时间以错开缓存过期时间。
      - 在缓存过期前主动更新缓存，使用定时任务刷新缓存。
      - 使用锁机制，限制同时访问数据库的请求数量。


- **缓存击穿**： 
   - **原因**：某些热点数据在缓存过期后，瞬间有大量请求访问，导致请求直接打到数据库。
   - **解决方案**： 
      - 热点数据设置为永不过期，并使用后台线程定时更新缓存。
      - 使用互斥锁或分布式锁，控制同时访问数据库的请求数量。


- **缓存穿透**： 
   - **原因**：请求的数据在缓存和数据库中都不存在，导致请求直接打到数据库，可能被恶意利用进行攻击。
   - **解决方案**： 
      - 使用布隆过滤器，拦截非法请求。
      - 缓存空值，将不存在的数据缓存一段时间，防止频繁访问数据库。


#### 24. **如何设计一个缓存策略，可以动态缓存热点数据？**

**回答**：

设计一个缓存策略，以动态缓存热点数据，可以考虑以下几点：

1.  **热点数据检测**： 
   - 使用滑动窗口统计或实时监控请求频率，识别热点数据。
   - 当某个数据的访问频率超过阈值时，将其标记为热点数据。
2.  **缓存预热**： 
   - 在系统启动或流量高峰前，预先将热点数据加载到缓存中。
   - 使用后台线程定时更新热点数据，避免缓存失效。
3.  **动态调整**： 
   - 根据访问频率动态调整缓存容量，增加热点数据的缓存空间。
   - 对于访问频率下降的数据，减少缓存空间或从缓存中移除。

展示动态缓存热点数据的策略：


#### 25. **说说常见的缓存更新策略？**
**回答**：

常见的缓存更新策略主要有以下几种：

1. **定时更新（Time-based Refresh）**： 
   - 定时刷新缓存，定期从数据库中获取最新数据，更新缓存。
   - 优点：缓存数据定时更新，保证数据的新鲜度。
   - 缺点：可能会导致短暂的不一致性，尤其在定时器触发前的数据更新。


2. **失效更新（Cache Invalidation）**： 
   - 数据库更新时，主动删除或更新对应的缓存。
   - 优点：确保缓存数据与数据库数据的一致性。
   - 缺点：实现复杂，需要在数据库更新时同步更新缓存。


3. **主动更新（Write-through/Write-back）**： 
   - Write-through：写操作同时更新数据库和缓存。
   - Write-back：写操作先更新缓存，定期将缓存数据同步到数据库。
   - 优点：Write-through确保数据一致性；Write-back提高写操作性能。
   - 缺点：Write-through的写操作性能较低；Write-back可能导致数据不一致。


#### 26. **如何保证缓存和数据库数据的一致性？**

**回答**：

保证缓存和数据库数据的一致性是缓存系统设计中的重要问题，可以采取以下策略：

1. **先更新数据库，再更新缓存**： 
   - 先执行数据库更新操作，再更新或删除缓存。
   - 优点：保证数据库的数据一致性。
   - 缺点：可能会引起短暂的不一致性，尤其是在两步操作之间出现并发读写的情况下。


2. **先删除缓存，再更新数据库**： 
   - 先删除缓存，再执行数据库更新操作。
   - 优点：避免了缓存中的脏数据。
   - 缺点：在删除缓存和更新数据库之间，可能会有读操作直接请求数据库。


3. **双写（Cache-Aside Pattern）**： 
   - 数据更新时，同时更新缓存和数据库。
   - 优点：缓存和数据库始终保持同步。
   - 缺点：实现复杂，可能会导致性能下降。


4. **异步更新**： 
   - 数据更新时，先更新数据库，再通过消息队列异步更新缓存。
   - 优点：减少了直接的数据库读写冲突。
   - 缺点：消息队列引入了额外的复杂性和延迟。


### 八、Redis 实战

#### 27. **Redis如何实现延迟队列？**

**回答**：

Redis可以使用Sorted Set（有序集合）来实现延迟队列。延迟队列是一种特殊的消息队列，消息需要在特定时间点或经过一定延迟后才被处理。

实现步骤：

1. 使用`ZADD`命令将消息添加到有序集合中，时间戳作为分数。
2. 使用`ZRANGEBYSCORE`命令按时间范围取出到期的消息。
3. 使用`ZREM`命令删除已处理的消息。

展示延迟队列的实现流程：


#### 28. **Redis的大key如何处理？**

**回答**：

大key是指在Redis中存储的数据量特别大（如包含大量元素的列表、集合等）。处理大key主要有以下策略：

1. **拆分大key**： 
   - 将大key拆分为多个小key，每个小key包含部分数据。
   - 优点：减少单个key的内存占用，避免单次操作时间过长。
   - 缺点：增加了管理的复杂性。


2. **异步删除**： 
   - 在删除大key时，采用异步方式，逐步删除。
   - 优点：避免阻塞Redis主线程。
   - 缺点：实现复杂，需要额外的代码支持。



#### 29. **Redis管道有什么用？**

**回答**：

Redis管道（Pipeline）允许在一次请求中发送多个命令，减少客户端与服务器之间的往返次数，从而提高批量操作的性能。

1.  **批量发送命令**： 
   - 客户端将多个命令一次性发送到服务器。
   - 服务器按顺序执行命令，返回结果。
2.  **减少网络延迟**： 
   - 减少了每个命令的网络延迟，提高整体性能。
   - 适用于需要一次性处理大量命令的场景，如批量插入、更新等。

展示Redis管道的工作流程：


#### 30. **Redis事务支持回滚吗？**

**回答**：

Redis的事务机制通过MULTI、EXEC、DISCARD和WATCH命令实现，但它不支持回滚。事务中的所有命令要么全部执行，要么全部不执行。如果事务执行过程中遇到错误，已完成的命令不会回滚。

1. **MULTI**：开始事务。
2. **EXEC**：执行事务中的所有命令。
3. **DISCARD**：取消事务，不执行事务中的命令。
4. **WATCH**：监视一个或多个键，如果这些键被其他客户端修改，事务将被取消。

展示Redis事务的执行流程：


#### 31. **如何用Redis实现分布式锁的？**

**回答**：

Redis可以通过SETNX命令或Redlock算法实现分布式锁。

1. **SETNX命令**： 
   - 使用SETNX（Set if Not Exists）命令设置一个键，如果键不存在，则成功设置并获取锁。如果键已存在，则获取锁失败。
   - 可以结合EXPIRE命令设置锁的过期时间，防止死锁。


2. **Redlock算法**： 
   - Redlock是Redis官方推荐的一种分布式锁算法，适用于多Redis节点的分布式环境。
   - 该算法通过在多个独立的Redis实例上分别获取锁，确保锁的高可靠性。

展示Redlock算法实现分布式锁的流程：



