---
title: 校招参考！腾娱互动-Go社招一面
urlname: dxwkhngq4yrc7xac
date: '2024-07-23 22:20:47'
updated: '2024-07-23 22:28:20'
description: 面试问题为什么想离职对我们的招聘岗位有了解吗有去过武汉吗自我介绍什么时候接触golang的，自学的是么，为什么想到去学go分享一下go语言的学习经验学习go的时候有没有遇到过什么问题？讲一下goroutine与线程有什么不同呢？什么情况下会引起panic怎么捕获panicerror 和 pan...
---
# 面试问题

- 为什么想离职
- 对我们的招聘岗位有了解吗
- 有去过武汉吗
- 自我介绍
- 什么时候接触golang的，自学的是么，为什么想到去学go
- 分享一下go语言的学习经验
- 学习go的时候有没有遇到过什么问题？
- 讲一下goroutine与线程有什么不同呢？
- 什么情况下会引起panic
- 怎么捕获panic
- error 和 panic的区别
- golang的gc怎么做的 
1. 触发时机是什么？
2. go的gc为什么要引入短暂的全局停顿
3. 标记回收的时候怎么解决循环引用的问题
4. 什么是弱引用，举个例子，比如定义了一个组合类型，一个循环嵌套的关系，什么是弱引用，什么是循环引用
- 项目 
1. 在中台系统具体负责哪些
2. 数据抓取遇到过哪些难点？
- 有关注过哪些最新的技术发展
- 反问

原问题链接：[https://www.nowcoder.com/discuss/642858660929994752](https://www.nowcoder.com/discuss/642858660929994752)
# 参考回答
#### 离职原因和求职动机
**「面试官」**：欢迎来到今天的面试。首先，能否谈谈你为什么想要离开当前的工作岗位？
**『求职者』**：谢谢面试官。我考虑离职主要是因为我希望能在职业发展上有新的突破。在当前公司，我已经积累了丰富的经验，但我感觉自己的成长速度有所放缓。我一直关注贵公司的发展，被你们在技术创新和团队文化方面的成就所吸引。我认为加入贵公司将给我带来新的挑战和学习机会，能够帮助我更好地发展我的职业生涯。
**「面试官」**：理解。那么，你对我们公司的这个招聘岗位有什么了解吗？
**『求职者』**：是的，我对贵公司的这个岗位做了一些研究。我了解到这是一个专注于Go语言开发的后端工程师岗位，主要负责公司核心业务系统的开发和优化。我特别注意到岗位要求中提到了分布式系统的经验和高并发处理能力，这正是我在过去的工作中积累的经验和我希望进一步深入的领域。
**「面试官」**：很好。你之前有去过武汉吗？对这座城市有什么印象？
**『求职者』**：是的，我去过武汉几次。武汉给我的印象是一座充满活力和机遇的城市。它有深厚的历史文化底蕴，同时又是中部地区的科技创新中心。我特别欣赏武汉在近年来在科技产业方面的快速发展，这也是吸引我考虑在武汉发展的原因之一。
#### 自我介绍和Go语言学习经历
**「面试官」**：谢谢你的分享。现在，能否请你做一个简短的自我介绍？
**『求职者』**：当然。我是[您的名字]，毕业于[您的学校]，主修计算机科学。我有5年的后端开发经验，其中近3年主要使用Go语言进行开发。在当前公司，我主要负责中台系统的开发和维护，参与了多个大型项目的设计和实现。我擅长处理高并发场景，对分布式系统有深入的理解。除了技术能力，我也注重团队协作，经常参与code review和技术分享。在业余时间，我喜欢关注新技术trends，并在个人项目中尝试应用。
**「面试官」**：听起来你对Go语言有很深的理解。你是什么时候开始接触Go的？是自学的吗？为什么选择学习Go？
**『求职者』**：我大约三年前开始接触Go语言。最初确实是通过自学开始的。选择学习Go主要有几个原因：

1. **并发优势**：Go的goroutine和channel机制让并发编程变得更加简单和高效，这对于构建高性能的后端服务非常有吸引力。
2. **语言设计**：Go的简洁性和强类型特性很吸引我。它去除了很多其他语言的复杂特性，使得代码更易读、易维护。
3. **生态系统**：Go在云原生和微服务领域有很强的生态系统，这与行业发展趋势非常契合。
4. **编译速度**：Go的快速编译速度大大提高了开发效率。
5. **职业发展**：我看到Go在市场上的需求不断增长，学习Go可以为我的职业发展带来新的机会。

开始自学后，我很快就被Go的设计理念和实用性所吸引，之后在工作中有机会将Go应用到实际项目中，这更加深了我对Go的理解和热爱。
**「面试官」**：能分享一下你学习Go语言的经验吗？
**『求职者』**：当然，我很乐意分享我学习Go的经验：

1. **官方文档**：我首先通过Go的官方文档和tour of Go开始学习。这些资源提供了语言的核心概念和最佳实践。
2. **实践项目**：我认为学习编程语言最好的方法是通过实际项目。我开始用Go重写一些我之前用其他语言完成的小项目，这帮助我快速掌握了语言特性。
3. **深入理解并发**：Go的并发模型是其最大的特点之一，我花了很多时间理解goroutine和channel的工作原理，以及如何有效地使用它们。
4. **社区参与**：我积极参与Go社区，包括阅读博客、参加线上和线下的Go meetup。这让我了解到很多实用的技巧和最新的发展趋势。
5. **源码阅读**：为了更深入地理解Go，我阅读了一些著名Go项目的源码，如Docker和Kubernetes。这帮助我学习到了很多高质量的Go代码写法。
6. **持续学习**：Go生态系统发展很快，我保持关注Go的新特性和最佳实践，例如泛型的引入和错误处理的演变。
7. **分享知识**：我发现，试图向他人解释Go的概念能够加深自己的理解。因此，我经常在团队中分享Go的知识，甚至写一些技术博客。

这个学习过程让我不仅掌握了Go的语法，更重要的是理解了Go的设计哲学和最佳实践。
**「面试官」**：在学习Go的过程中，你遇到过什么问题吗？
**『求职者』**：是的，在学习Go的过程中，我确实遇到了一些挑战：

1. **并发模型的理解**：初学时，理解goroutine和channel的工作原理以及如何正确使用它们来避免死锁和竞态条件是一个挑战。我通过大量的练习和阅读相关文章才逐渐掌握。
2. **错误处理方式**：Go的错误处理方式与我之前使用的语言很不同。适应 `if err != nil` 的模式以及学会何时使用panic和recover花了一些时间。
3. **接口的隐式实现**：Go的接口是隐式实现的，这个概念一开始让我感到困惑。我通过实践和阅读优秀的Go代码才真正理解了这种设计的灵活性。
4. **包管理**：在Go modules出现之前，包管理是一个痛点。适应GOPATH和后来转向Go modules的过程中遇到了一些困难。
5. **指针vs值**：理解何时使用指针，何时使用值，特别是在方法接收者的选择上，起初也有一些困惑。
6. **GC机制**：理解Go的垃圾回收机制，特别是在处理大量数据时如何优化内存使用，也是一个学习过程。
7. **Context的使用**：正确使用Context来处理取消和超时，以及在函数调用链中传递Context，一开始也有些棘手。

克服这些问题的过程实际上加深了我对Go的理解。我通过大量阅读、实践和与其他Go开发者交流来解决这些问题，这个过程也让我更加欣赏Go的设计理念。
#### Go语言核心概念
**「面试官」**：很好的学习经历。那么，你能讲一下goroutine与线程有什么不同吗？
**『求职者』**：当然，goroutine和线程有几个关键的区别：

1. **创建和管理**：
   - Goroutine是由Go运行时（runtime）管理的，而线程是由操作系统管理的。
   - Goroutine的创建和销毁开销很小，而线程的创建和销毁相对昂贵。
2. **内存占用**：
   - Goroutine起始只需要2KB的栈内存，而线程通常需要1MB或更多。
   - Goroutine的栈是动态的，可以根据需要增长和收缩，而线程的栈大小通常是固定的。
3. **切换成本**：
   - Goroutine的切换在用户空间完成，开销很小。
   - 线程切换涉及系统调用，需要切换到内核空间，开销较大。
4. **并发规模**：
   - 一个程序可以轻松创建上万个goroutine。
   - 而同时运行的线程数量受到系统资源的限制，通常要少得多。
5. **通信方式**：
   - Goroutine通常使用channel进行通信，这是语言级的特性。
   - 线程间通信通常需要使用互斥锁、信号量等同步原语。
6. **调度方式**：
   - Goroutine使用Go运行时的调度器，实现了协作式的调度。
   - 线程由操作系统调度，通常是抢占式的。
7. **上下文切换**：
   - Goroutine的上下文切换很轻量，因为它只需保存少量的寄存器。
   - 线程的上下文切换需要保存所有寄存器，开销较大。

总的来说，goroutine提供了一种更轻量、更易于使用的并发模型，使得Go能够高效地处理大量并发任务。这也是Go在高并发服务器开发中表现出色的原因之一。
**「面试官」**：理解得很好。那么，你能说说什么情况下会引起panic吗？
**『求职者』**：Panic是Go语言中的一种机制，用于处理程序中的严重错误。以下是一些可能引起panic的常见情况：

1. **运行时错误**：
   - 数组或切片越界访问
   - 空指针解引用
   - 向已关闭的channel发送数据
   - 类型断言失败
2. **除零操作**：
当程序尝试除以零时会触发panic。
3. **调用内置的panic函数**：
开发者可以在代码中显式调用`panic()`函数来触发panic。
4. **Go运行时检测到的其他严重错误**：
例如栈溢出或内存不足。
5. **map并发读写**：
在没有proper同步的情况下并发读写map可能导致panic。
6. **类型断言失败**：
使用类型断言时，如果断言失败且没有使用两个返回值的形式，会触发panic。
7. **关闭一个已经关闭的channel**：
重复关闭一个channel会导致panic。
8. **从一个nil的channel中接收数据**：
这会导致程序永久阻塞，Go运行时会将其视为一种死锁并引发panic。
9. **递归调用过深导致栈溢出**：
虽然Go的栈是动态增长的，但如果递归过深仍可能导致栈溢出并引发panic。
10. **使用未初始化的映射**：
尝试向一个nil map添加元素会导致panic。

重要的是要注意，panic应该用于不可恢复的错误情况。对于可以预期和处理的错误，应该使用Go的错误处理机制（返回error）。适当使用panic和recover可以帮助我们构建更健壮的程序。
**「面试官」**：很好，那么如何捕获panic呢？
**『求职者』**：在Go中，我们可以使用`recover`函数来捕获panic。以下是捕获panic的基本步骤和一些最佳实践：

1. **基本用法**：
```go
defer func() {
    if r := recover(); r != nil {
        fmt.Println("Recovered from panic:", r)
    }
}()
```
   这个defer函数会在包含它的函数结束时执行，无论是正常结束还是因为panic而结束。

2. **在goroutine中使用**：
每个goroutine都需要自己的recover，因为panic不会跨goroutine传播。
```go
go func() {
    defer func() {
        if r := recover(); r != nil {
            log.Println("Recovered in goroutine:", r)
        }
    }()
    // 可能引起panic的代码
}()
```

3. **记录堆栈信息**：
为了更好地调试，通常我们会记录完整的堆栈信息。
```go
import "runtime/debug"

defer func() {
    if r := recover(); r != nil {
        log.Printf("Panic: %v\n%s", r, debug.Stack())
    }
}()
```

4. **重新抛出panic**：
在某些情况下，你可能想在记录错误后重新抛出panic。
```go
defer func() {
    if r := recover(); r != nil {
        log.Println("Panic:", r)
        panic(r) // 重新抛出panic
    }
}()
```

5. **使用命名的返回值**：
如果函数有命名的返回值，可以在defer中修改这些值。
```go
func example() (err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("panic occurred: %v", r)
        }
    }()
    // 函数主体
}
```

6. **避免在不必要的地方使用recover**：
只在真正需要处理panic的地方使用recover，过度使用可能掩盖真正的问题。
7. **测试recover逻辑**：
确保编写测试来验证你的recover逻辑是否按预期工作。

记住，虽然recover可以捕获panic，但它不应该被用作常规错误处理的替代品。Go的错误处理通常应该使用返回错误值的方式。Panic/recover更适合处理那些真正意外和不可恢复的情况。
**「面试官」**：非常好。那么你能解释一下error和panic的区别吗？
**『求职者』**：当然，error和panic在Go语言中都用于处理错误情况，但它们有很大的不同：

1. **用途**：
   - Error：用于表示可预期的、可恢复的错误情况。
   - Panic：用于表示严重的、不可恢复的错误，通常是程序无法继续执行的情况。
2. **控制流**：
   - Error：不会中断程序的正常执行流程。函数返回error，调用者可以选择如何处理。
   - Panic：会立即停止当前函数的执行，并开始沿调用栈向上传播，直到被recover捕获或导致程序崩溃。
3. **处理方式**：
   - Error：通常通过检查返回值来处理，如 `if err != nil { ... }`。
   - Panic：通过defer和recover来捕获和处理。
4. **性能影响**：
   - Error：几乎没有性能开销。
   - Panic：有一定的性能开销，特别是在被recover捕获时。
5. **使用场景**：
   - Error：用于大多数可预见的错误情况，如文件不存在、网络连接失败等。
   - Panic：用于严重的运行时错误，如索引越界、空指针解引用等。
6. **可预测性**：
   - Error：使代码更可预测，因为错误处理是显式的。
   - Panic：可能在意想不到的地方发生，使程序行为less predictable。
7. **返回值**：
   - Error：通常作为函数的返回值之一。
   - Panic：不是通过常规的返回机制传递的。
8. **标准库使用**：
   - Error：Go标准库大量使用error接口来表示错误。
   - Panic：标准库较少使用panic，主要用于真正的异常情况。
9. **恢复能力**：
   - Error：允许程序优雅地处理错误并继续执行。
   - Panic：除非被recover捕获，否则会导致程序终止。

总的来说，在Go中，我们应该优先使用error来处理大多数错误情况。Panic应该保留给那些真正异常和不可恢复的情况。这种方法使得错误处理更加明确和可控，符合Go的设计哲学。
**「面试官」**：很好的解释。现在让我们谈谈Go的垃圾回收机制。你能解释一下Go的GC是如何工作的吗？
**『求职者』**：当然，Go的垃圾回收（GC）机制是一个复杂而有趣的话题。Go使用的是并发的、三色标记-清除算法，具体工作过程如下：

1. **三色标记算法**：
   - 白色：潜在的垃圾对象。
   - 灰色：已被标记但其引用还未被扫描的对象。
   - 黑色：已被标记且其所有引用都已被扫描的对象。
2. **标记阶段**：
   - 从根对象（如全局变量、栈变量）开始，将其标记为灰色。
   - 遍历灰色对象，将其引用的对象标记为灰色，然后将自己标记为黑色。
   - 重复这个过程，直到没有灰色对象。
3. **清除阶段**：
   - 清除所有剩余的白色对象（这些是垃圾）。
4. **并发执行**：
   - Go的GC是并发的，大部分工作与程序并行执行。
   - 使用写屏障技术来处理并发修改。
5. **STW（Stop The World）**：
   - GC过程中有短暂的STW阶段，但时间很短（通常<1ms）。
6. **触发时机**：
   - 基于堆大小增长的动态触发。
   - 可以通过runtime.GC()手动触发。
7. **内存分配**：
   - 使用TCMalloc算法的变种进行快速内存分配。
8. **优化技术**：
   - 使用位图标记。
   - 并行标记和清除。
   - 增量式扫描。
9. **垃圾回收调优**：
   - 可以通过GOGC环境变量调整GC频率。
   - 使用runtime/debug包进行更细粒度的控制。

Go的GC设计目标是低延迟和高吞吐量，特别适合需要快速响应的服务器应用。虽然有短暂的STW，但对大多数应用来说影响很小。理解GC机制对于优化Go程序的性能非常重要。
**「面试官」**：很好的解释。那么，Go的GC触发时机具体是什么？
**『求职者』**：Go的垃圾回收（GC）触发机制是动态的，主要基于以下几个因素：

1. **内存分配阈值**：
   - 当堆内存大小增长到上次GC后的一定比例时触发。这个比例由GOGC环境变量控制，默认是100%。
   - 例如，如果上次GC后堆内存为4MB，那么下次GC会在堆内存达到8MB时触发。
2. **定期触发**：
   - Go运行时会定期检查是否需要进行GC，即使内存增长未达到阈值。
3. **系统内存压力**：
   - 当系统内存压力大时，Go可能会更频繁地触发GC。
4. **手动触发**：
   - 可以通过调用`runtime.GC()`函数手动触发GC。
5. **并发标记开始的触发时机**：
   - 在达到内存分配阈值的75%时，并发标记阶段就会开始。
6. **基于CPU利用率**：
   - GC会尝试在CPU利用率较低时进行，以减少对程序性能的影响。
7. **强制GC**：
   - 在极端情况下，如内存耗尽，Go会强制进行GC。
8. **后台GC**：
   - Go 1.12引入了后台GC机制，可以在空闲时进行一些GC工作。
9. **大对象分配**：
   - 分配特别大的对象可能会立即触发GC。
10. **GC期间的内存分配**：
   - 如果在GC过程中分配了大量新内存，可能会触发新一轮GC。

理解这些触发机制对于优化Go程序的性能很重要。例如，可以通过调整GOGC值来控制GC频率，或者在关键路径上手动触发GC来避免在不适当的时候发生GC。但通常情况下，Go的自动GC机制已经能够很好地平衡内存使用和性能。
**「面试官」**：非常好。那么，你知道为什么Go的GC要引入短暂的全局停顿（STW）吗？
**『求职者』**：Go的垃圾回收（GC）引入短暂的全局停顿（Stop The World，STW）主要是为了确保垃圾回收的正确性和一致性。虽然Go的GC大部分工作是并发进行的，但仍然需要STW阶段，原因如下：

1. **确保一致性**：
   - STW可以确保在某个时间点上，所有的goroutine都停止，这样GC可以获得一个一致的内存视图。
1. **根对象扫描**：
   - 在STW期间，GC可以准确地扫描所有的根对象（如全局变量、goroutine栈等），而不用担心它们被并发修改。
1. **写屏障开启和关闭**：
   - STW用于开启和关闭写屏障。写屏障是并发GC的关键机制，用于跟踪内存的变化。
1. **处理复杂的内存状态**：
   - 某些复杂的内存状态（如goroutine创建）可能需要在STW期间处理，以避免race condition。
1. **终止检查**：
   - STW用于执行终止检查，确保所有需要被标记的对象都已被标记。
1. **避免并发带来的复杂性**：
   - 虽然并发GC理论上可以完全无STW，但这会大大增加算法的复杂性和开销。短暂的STW是一种权衡。
1. **性能考虑**：
   - 短暂的STW可能比完全消除STW但增加大量同步开销更有效率。
1. **调度器配合**：
   - STW期间，Go可以更容易地管理和协调所有的goroutine。
1. **内存屏障的同步点**：
   - STW提供了一个同步点，确保所有的内存屏障操作都已完成。
1. **简化实现**：
   - STW简化了GC的实现，使得整个系统更加健壮和可维护。

值得注意的是，Go团队一直在努力减少STW的持续时间。在现代Go版本中，STW通常只持续几百微秒到几毫秒，对大多数应用的影响很小。此外，Go的GC被设计为可预测的，STW的时间通常与live heap size成正比，而不是与总堆大小成正比，这使得它在大型应用中仍然表现良好。
**「面试官」**：很好的解释。那么在标记回收的过程中，Go是如何解决循环引用的问题的？
**『求职者』**：Go的垃圾回收器在处理循环引用时主要依赖于其三色标记算法。这个算法能有效地处理循环引用，而不需要特殊的机制。以下是Go如何解决循环引用问题：

1. **三色标记算法**：
   - 白色：潜在的垃圾对象。
   - 灰色：已被标记但其引用还未被扫描的对象。
   - 黑色：已被标记且其所有引用都已被扫描的对象。
2. **标记过程**：
   - 从根对象开始，将其标记为灰色。
   - 遍历灰色对象，将其引用的对象标记为灰色，然后将自己标记为黑色。
   - 重复这个过程，直到没有灰色对象。
3. **处理循环引用**：
   - 当遇到循环引用时，算法会继续遍历，直到循环中的所有对象都被标记。
   - 如果循环中的对象可以从根对象到达，它们最终会被标记为黑色。
   - 如果循环中的对象无法从根对象到达，它们会保持白色，最终被回收。
4. **不依赖引用计数**：
   - Go的GC不使用引用计数，因此不会被循环引用困住。
5. **可达性分析**：
   - Go的GC基于可达性分析，只关心对象是否可以从根对象到达，而不关心对象之间的引用关系。
6. **并发标记**：
   - Go的并发标记过程能够有效处理在标记过程中发生的对象引用变化。
7. **写屏障**：
   - 使用写屏障技术来处理并发修改，确保不会错过任何应该被标记的对象。
8. **增量式扫描**：
   - 通过增量式扫描，Go可以在不影响程序正常运行的情况下处理大量的对象，包括复杂的循环引用结构。
9. **终止检测**：
   - GC的终止检测确保所有可达对象都被正确标记，包括那些在循环引用中的对象。
10. **不需要显式处理**：
   - 程序员不需要显式处理循环引用，GC会自动处理这种情况。

总的来说，Go的垃圾回收器通过其三色标记算法和并发设计，能够有效地处理循环引用问题，无需额外的特殊机制。
