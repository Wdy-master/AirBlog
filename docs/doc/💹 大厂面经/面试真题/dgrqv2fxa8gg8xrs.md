---
title: 百度日常实习一面&二面
urlname: dgrqv2fxa8gg8xrs
date: '2024-07-27 20:25:19'
updated: '2024-07-27 20:37:55'
cover: 'https://cdn.nlark.com/yuque/__puml/90a7d789afce7c5f4ad81ba1e1c9d6a3.svg'
description: 面试问题0.项目拷打1.Redis避免主从读取不一致的问题2.线程的生命周期3.操作系统层面线程和进程的区别4.JAVA集合有哪些?5.hashmap底层实现原理6.java gc过程7.Java四大引用区别和应用8.分布式服务 对接口做限流 实现思路9.redis淘汰策略10.JAVA设计模...
---
# 面试问题
0.项目拷打
1.Redis避免主从读取不一致的问题
2.线程的生命周期
3.操作系统层面线程和进程的区别
4.JAVA集合有哪些?
5.hashmap底层实现原理
6.java gc过程
7.Java四大引用区别和应用
8.分布式服务 对接口做限流 实现思路
9.redis淘汰策略
10.JAVA设计模式
11.Java反射理解
12.十万个单词  从中找出访问频率最高的单词
> 原问题链接：[https://www.nowcoder.com/discuss/645681234500165632?sourceSSR=users](https://www.nowcoder.com/discuss/645681234500165632?sourceSSR=users)

# 参考回答
**面试官**：能否简单介绍一下你最近参与的项目，以及你在其中的主要职责？

**应聘者**：好的。我最近参与了一个电商平台的后端开发项目。我主要负责订单系统的设计和实现。这个系统需要处理高并发的订单创建、支付和状态更新等操作。我使用了Spring Boot框架，结合Redis缓存和MySQL数据库来实现。为了提高系统的可靠性和性能，我还实现了分布式锁来处理并发问题，并使用消息队列来处理异步任务。

**面试官**：听起来是个很有挑战性的项目。那么在使用Redis时，你是如何避免主从读取不一致的问题的？

**应聘者**：为了避免Redis主从读取不一致的问题，我们采取了以下几个策略：

1. 读写分离：我们将写操作都发送到主节点，读操作可以分发到从节点。
2. 延迟复制：我们设置了合理的复制延迟阈值。如果从节点的复制延迟超过这个阈值，我们就将读请求路由到主节点或其他延迟较小的从节点。
3. 版本号机制：我们在写入数据时附加一个版本号，读取时检查版本号，如果发现不一致，就从主节点重新读取。
4. 强一致性读：对于特别重要的数据，我们使用WAIT命令来确保数据已经被复制到指定数量的从节点后再返回。
5. 客户端缓存：对于一些不太重要的数据，我们在客户端做了一层缓存，可以容忍短时间的不一致。

这些策略的选择取决于具体的业务场景和对数据一致性的要求。

**面试官**：很好。那么你能描述一下线程的生命周期吗？

**应聘者**：当然。Java中线程的生命周期主要包括以下几个状态：
![](https://oss1.aistar.cool/elog-offer-now/e82ac68a36d7c72d7558a5b98e6a0969.svg)
1. 新建（New）：线程对象被创建后，还没有调用start()方法时的状态。
2. 就绪（Runnable）：线程调用了start()方法后，等待CPU调度的状态。
3. 运行（Running）：线程获得CPU时间片，正在执行run()方法中的代码。
4. 阻塞（Blocked）：线程因为某些原因放弃CPU使用权，暂时停止运行。比如等待I/O操作完成、等待获取锁等。
5. 等待（Waiting）：线程进入等待状态，比如调用了Object.wait()或Thread.join()方法。
6. 超时等待（Timed Waiting）：线程等待一个具体的时间，比如调用了Thread.sleep(long)或Object.wait(long)方法。
7. 终止（Terminated）：线程执行完run()方法或因异常退出后的状态。

线程在生命周期中会根据不同的操作在这些状态之间转换。

**面试官**：从操作系统层面来看，线程和进程有什么区别？

**应聘者**：从操作系统层面来看，线程和进程的主要区别有：

1. 资源占用：进程是资源分配的基本单位，每个进程都有自己的地址空间、文件描述符等资源。而线程是CPU调度的基本单位，同一进程中的多个线程共享进程的资源。
2. 切换开销：线程切换的开销比进程切换小，因为线程切换只需要保存和恢复少量的寄存器内容，而进程切换涉及到整个进程的上下文。
3. 通信方式：同一进程中的线程可以直接通过共享内存通信，而进程间通信需要使用IPC（如管道、消息队列等）。
4. 独立性：进程有更高的独立性，一个进程崩溃通常不会影响其他进程。而一个线程崩溃可能会导致整个进程崩溃。
5. 系统开销：创建和撤销进程的开销比线程大。
6. 并发性：在多核处理器上，不同进程可以并行执行，而多线程程序可能受到GIL（全局解释器锁）等因素的限制。
7. 数据共享：线程之间可以方便地共享数据，而进程间共享数据需要特殊的IPC机制。

**面试官**：Java中有哪些常用的集合类？

**应聘者**：Java中常用的集合类主要包括：

1. List接口的实现类：
   - ArrayList：基于动态数组实现，随机访问效率高。
   - LinkedList：基于双向链表实现，插入和删除效率高。
   - Vector：类似ArrayList，但是线程安全的。
2. Set接口的实现类：
   - HashSet：基于HashMap实现，不允许重复元素。
   - TreeSet：基于红黑树实现，元素有序但插入和删除较慢。
   - LinkedHashSet：具有HashSet的查找效率，并且维护了插入顺序。
3. Map接口的实现类：
   - HashMap：基于哈希表实现，允许null键和值。
   - TreeMap：基于红黑树实现，键值对有序存储。
   - LinkedHashMap：类似HashMap，但维护了插入顺序。
   - Hashtable：类似HashMap，但是线程安全的，不允许null键和值。
4. Queue接口的实现类：
   - LinkedList：可以用作队列使用。
   - PriorityQueue：基于优先堆的无界优先队列。
5. Deque接口的实现类：
   - ArrayDeque：基于可变长数组实现的双端队列。
   - LinkedList：也实现了Deque接口。

这些集合类各有特点，选择使用哪一个取决于具体的应用场景。

**面试官**：你能详细解释一下HashMap的底层实现原理吗？

**应聘者**：当然。HashMap的底层实现原理主要涉及以下几个方面：

1. 数据结构：HashMap使用数组+链表+红黑树（Java 8及以后）的结构。数组被称为桶（bucket），每个桶存储一个链表或红黑树。
2. 哈希函数：当插入一个键值对时，HashMap会对key的hashCode()进行哈希计算，然后通过哈希值确定存储的桶位置。
3. 解决哈希冲突：当多个key映射到同一个桶时，HashMap使用链表（或红黑树）来存储这些元素。
4. 链表转红黑树：当一个桶中的元素超过8个（默认值）且数组长度大于等于64时，链表会转换为红黑树，以提高查找效率。
5. 负载因子：HashMap有一个负载因子（默认0.75），当元素数量超过数组容量乘以负载因子时，会触发扩容操作。
6. 扩容：扩容时，会创建一个新的更大的数组（通常是原来的2倍），并将原有元素重新哈希到新数组中。
7. 线程不安全：HashMap是非线程安全的。多线程环境下可能会导致死循环（Java 7及之前）或数据不一致。
8. null键和值：HashMap允许使用null作为键和值。null键总是被放在第一个桶中。
9. 迭代顺序：HashMap不保证元素的顺序，迭代顺序可能会随着元素的添加或删除而改变。

理解HashMap的这些实现细节对于正确使用和优化HashMap非常重要。

**面试官**：能简要描述一下Java的垃圾回收过程吗？

**应聘者**：Java的垃圾回收（GC）过程主要包括以下几个步骤：

1. 标记（Mark）：GC首先标记所有仍在使用的对象。这个过程从GC Roots开始，沿着对象引用关系遍历所有可达对象。
2. 清除（Sweep）：标记完成后，GC会清除所有未被标记的对象，释放它们占用的内存。
3. 压缩（Compact）：某些GC算法会在清除后进行内存压缩，将存活的对象移动到一起，减少内存碎片。
4. 分代回收：Java使用分代回收策略，将堆内存分为年轻代和老年代。
   - 年轻代使用复制算法，频繁进行Minor GC。
   - 老年代使用标记-清除或标记-压缩算法，进行Major GC。
5. 并发和并行：现代JVM支持并发标记（如CMS）和并行回收（如Parallel GC）以减少停顿时间。
6. G1 GC：将堆分割成多个区域，可以并行、并发地进行垃圾回收，并有预测停顿时间的能力。
7. ZGC：目标是在任何堆大小下都能保证极低的停顿时间（<10ms）。

GC的具体行为会根据所选择的GC算法和JVM参数而有所不同。理解GC过程有助于优化Java应用的性能和内存使用。
**面试官**：Java中四种引用类型的区别和应用场景是什么？

**应聘者**：Java中的四种引用类型及其应用场景如下：

1. 强引用（Strong Reference）：
   - 最常见的引用类型，例如 `Object obj = new Object();`
   - 只要强引用存在，对象就不会被回收
   - 应用：常规对象的引用
2. 软引用（Soft Reference）：
   - 使用 `SoftReference` 类实现
   - 当内存不足时，软引用指向的对象可能被回收
   - 应用：缓存，如网页缓存、图片缓存等
3. 弱引用（Weak Reference）：
   - 使用 `WeakReference` 类实现
   - 下一次GC时，弱引用指向的对象就会被回收
   - 应用：WeakHashMap，避免内存泄漏
4. 虚引用（Phantom Reference）：
   - 使用 `PhantomReference` 类实现
   - 随时可能被回收，必须和引用队列（ReferenceQueue）一起使用
   - 应用：跟踪对象的回收，如管理直接内存的释放

这四种引用类型为内存敏感的应用程序提供了更细粒度的内存管理控制。
**面试官**：在分布式服务中，如何对接口进行限流？请描述实现思路。

**应聘者**：在分布式服务中对接口进行限流，可以考虑以下几种实现思路：

1. 分布式限流器：
   - 使用Redis实现令牌桶或漏桶算法
   - 使用Lua脚本保证原子性操作
   - 所有服务节点共享同一个Redis计数器
2. 网关层限流：
   - 在API网关（如Nginx、Zuul、Spring Cloud Gateway）实现限流逻辑
   - 可以使用Nginx的limit_req模块或自定义限流插件
3. 分布式配置中心：
   - 使用配置中心（如Apollo、Nacos）动态调整限流规则
   - 各服务节点实时获取最新限流配置
4. 消息队列限流：
   - 将请求放入消息队列，控制消费速度来实现限流
   - 适用于异步处理的场景
1. 熔断降级：
   - 使用Hystrix或Sentinel实现熔断降级
   - 当请求量超过阈值时，自动触发服务降级
1. 分布式锁限流：
   - 使用Zookeeper或Redis实现分布式锁
   - 获取锁成功才允许处理请求
1. 自适应限流：
   - 根据系统负载（CPU、内存、响应时间等）动态调整限流阈值
   - 结合机器学习算法预测流量峰值

实现时需要考虑性能、一致性和可用性等因素。通常会结合多种策略来实现更精细和高效的限流。

**面试官**：Redis有哪些淘汰策略？

**应聘者**：Redis提供了几种不同的内存淘汰策略，用于在内存达到最大值时决定如何处理新的写入请求：

1. noeviction：不淘汰任何数据，当内存不足时新写入会报错。
2. allkeys-lru：从所有key中使用LRU（最近最少使用）算法淘汰。
3. volatile-lru：从设置了过期时间的key中使用LRU算法淘汰。
4. allkeys-random：从所有key中随机选择并淘汰。
5. volatile-random：从设置了过期时间的key中随机选择并淘汰。
6. volatile-ttl：从设置了过期时间的key中，选择最近要过期的key进行淘汰。
7. allkeys-lfu：从所有key中使用LFU（最不经常使用）算法淘汰。（Redis 4.0新增）
8. volatile-lfu：从设置了过期时间的key中使用LFU算法淘汰。（Redis 4.0新增）

选择合适的淘汰策略取决于具体的应用场景。例如，如果我们的应用对缓存命中率要求很高，可能会选择allkeys-lru或allkeys-lfu。如果我们希望确保某些key不会被淘汰，可以选择volatile-系列的策略。
**面试官**：你能说说Java中常用的设计模式吗？
**应聘者**：当然，Java中常用的设计模式包括：

1. 单例模式（Singleton）：确保一个类只有一个实例，并提供一个全局访问点。
2. 工厂模式（Factory）：定义一个创建对象的接口，让子类决定实例化哪个类。
3. 抽象工厂模式（Abstract Factory）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
4. 建造者模式（Builder）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
5. 原型模式（Prototype）：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
6. 适配器模式（Adapter）：将一个类的接口转换成客户希望的另外一个接口。
7. 装饰器模式（Decorator）：动态地给一个对象添加一些额外的职责。
8. 代理模式（Proxy）：为其他对象提供一种代理以控制对这个对象的访问。
9. 观察者模式（Observer）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
10. 策略模式（Strategy）：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。

这些设计模式在Java开发中经常使用，能够提高代码的复用性、可维护性和可扩展性。
**面试官**：你对Java反射的理解是什么？
**应聘者**：Java反射是指在运行时检查、访问和修改类、接口、字段和方法的能力。它允许我们在运行时获取类的信息，创建类的实例，调用方法，以及访问和修改字段。
主要特点和用途包括：

1. 运行时类型信息：可以在运行时获取类的完整信息。
2. 动态创建对象：可以在运行时动态创建类的实例，而无需在编译时知道类的名称。
3. 访问私有成员：可以访问和修改类的私有字段和方法。
4. 动态方法调用：可以在运行时调用任意方法，即使在编译时不知道这个方法。
5. 注解处理：可以在运行时读取和处理注解信息。
6. 框架开发：很多框架（如Spring）大量使用反射来实现依赖注入、AOP等功能。
7. 泛型擦除后的类型检查：可以在运行时获取泛型的实际类型信息。

反射的主要类包括Class、Method、Field、Constructor等，它们都在java.lang.reflect包中。
虽然反射非常强大，但也有一些缺点，如性能开销较大、可能破坏封装性等，因此在使用时需要权衡利弊。
**面试官**：如果有十万个单词，如何找出访问频率最高的单词？
**应聘者**：要找出十万个单词中访问频率最高的单词，我们可以使用以下步骤：

1. 使用HashMap统计每个单词的频率：
   - 遍历所有单词，用HashMap记录每个单词出现的次数。
   - Key为单词，Value为出现次数。
1. 找出最高频率：
   - 遍历HashMap，记录最高的频率值。
1. 输出最高频率的单词：
   - 再次遍历HashMap，输出频率等于最高频率的单词。

Java代码实现如下：
```java
import java.util.*;

public class WordFrequency {
    public static List<String> findMostFrequentWords(String[] words) {
        // 统计频率
        Map<String, Integer> frequencyMap = new HashMap<>();
        for (String word : words) {
            frequencyMap.put(word, frequencyMap.getOrDefault(word, 0) + 1);
        }

        // 找出最高频率
        int maxFrequency = 0;
        for (int frequency : frequencyMap.values()) {
            maxFrequency = Math.max(maxFrequency, frequency);
        }

        // 输出最高频率的单词
        List<String> mostFrequentWords = new ArrayList<>();
        for (Map.Entry<String, Integer> entry : frequencyMap.entrySet()) {
            if (entry.getValue() == maxFrequency) {
                mostFrequentWords.add(entry.getKey());
            }
        }

        return mostFrequentWords;
    }

    public static void main(String[] args) {
        String[] words = {"apple", "banana", "apple", "cherry", "date", "apple", "banana"};
        List<String> result = findMostFrequentWords(words);
        System.out.println("Most frequent words: " + result);
    }
}
```
这个方法的时间复杂度是O(n)，其中n是单词的总数。空间复杂度是O(m)，其中m是不同单词的数量。
对于大规模数据，我们还可以考虑使用流式处理或分布式计算来优化性能。
**面试官**：非常好。最后，你有什么问题想问我的吗？
**应聘者**：是的，我有几个问题：

1. 贵公司在技术栈选择上有什么特别的考虑吗？特别是在处理大规模数据和高并发方面。
2. 团队的开发流程是怎样的？是否采用敏捷开发方法？
3. 公司对员工的技术培训和职业发展有什么规划？
4. 这个职位在短期和长期的主要职责和挑战是什么？

**面试官**：[面试官会根据公司实际情况回答这些问题]
**应聘者**：非常感谢您的解答。这些信息对我很有帮助，让我对贵公司有了更深入的了解。我很期待能够加入您的团队，为公司的发展贡献自己的力量。
