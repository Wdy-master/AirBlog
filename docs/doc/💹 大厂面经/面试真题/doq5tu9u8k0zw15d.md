---
title: 字节一面面经：秒过，不会过不了吧？
urlname: doq5tu9u8k0zw15d
date: '2024-06-04 21:23:03'
updated: '2024-07-27 20:41:27'
description: 面试问题自我介绍你知道的搜索算法有哪些二叉搜索树，二叉平衡树，红黑树有什么区别（上面第二题我提到了这几种数据结构）Mysql为什么用B+树哈希的时间复杂度是多少哈希在是用的时候要注意什么并发和并行有什么区别线程和进程有什么区别你知道的语言里垃圾回收算法有什么C++智能指针说一下（简历里有写会C...
---
# 面试问题
- 自我介绍
- 你知道的搜索算法有哪些
- 二叉搜索树，二叉平衡树，红黑树有什么区别（上面第二题我提到了这几种数据结构）
- Mysql为什么用B+树
- 哈希的时间复杂度是多少
- 哈希在是用的时候要注意什么
- 并发和并行有什么区别
- 线程和进程有什么区别
- 你知道的语言里垃圾回收算法有什么
- C++智能指针说一下（简历里有写会C++）
- 问项目
- 做题，力扣146 LRU缓存
# 参考回答
**「面试官」**: 欢迎来到今天的面试。首先请您做个简单的自我介绍吧。
**『求职者』**: 好的,谢谢面试官。我叫张三,是一名计算机科学与技术专业的应届毕业生。在校期间,我主要学习了**数据结构与算法、操作系统、数据库系统**等核心课程,并参与了几个实际项目的开发。我对**后端开发和人工智能**领域特别感兴趣,也在这些方向上做了一些探索。我性格开朗,喜欢钻研技术,希望能加入贵公司,和优秀的同事一起工作和成长。
**「面试官」**: 谢谢您的自我介绍。那么接下来我想了解一下,您知道哪些搜索算法?能简单介绍一下吗?
**『求职者』**: 好的,我了解的搜索算法主要有以下几种:

1. **线性搜索**:最简单的搜索算法,从头到尾遍历整个数据结构。时间复杂度为O(n)。
2. **二分搜索**:适用于有序数组,每次将搜索范围缩小一半。时间复杂度为O(log n)。
3. **深度优先搜索(DFS)**:通过栈实现,沿着树的深度遍历直到到达叶子结点。
4. **广度优先搜索(BFS)**:通过队列实现,逐层遍历树的节点。
5. **哈希搜索**:通过哈希函数将关键字映射到数组下标,实现O(1)的搜索。
6. **二叉搜索树**:左子树小于根节点,右子树大于根节点,平均搜索时间复杂度为O(log n)。
7. **红黑树**:自平衡的二叉搜索树,保证最坏情况下的时间复杂度为O(log n)。

这些算法各有特点,适用于不同的场景。选择合适的搜索算法可以显著提高程序的效率。
**「面试官」**: 很好,您提到了二叉搜索树和红黑树。那么您能具体说说二叉搜索树、二叉平衡树和红黑树之间有什么区别吗?
**『求职者』**: 当然,我很乐意解释这三种树结构的区别:

1. **二叉搜索树(BST)**:
   - 特点:左子树的所有节点值小于根节点,右子树的所有节点值大于根节点。
   - 优点:**查找、插入和删除**的平均时间复杂度为O(log n)。
   - 缺点:在最坏情况下(如顺序插入),可能**退化成链表**,时间复杂度变为O(n)。
2. **二叉平衡树(AVL树)**:
   - 特点:是一种**自平衡**的二叉搜索树,任何节点的两个子树的高度最大差别为1。
   - 优点:**查找、插入和删除**的时间复杂度**始终保持在O(log n)**。
   - 缺点:为了维护平衡,**调整次数频繁**,对于频繁插入删除的场景可能影响性能。
3. **红黑树**:
   - 特点:是一种**近似平衡**的二叉搜索树,通过节点的颜色来维护平衡。
   - 规则:根是黑色;每个叶子节点(NIL)是黑色;如果一个节点是红色,则它的子节点必须是黑色;从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
   - 优点:**查找、插入和删除**的时间复杂度为O(log n),且**调整次数少于AVL树**,更适合频繁插入删除的场景。
   - 应用:广泛应用于**C++ STL**的map和set等容器中。

总的来说,这三种树结构是一个**平衡和性能**的权衡。二叉搜索树最简单但可能失衡,AVL树完全平衡但调整成本高,而红黑树在两者之间取得了很好的平衡,既保证了最坏情况下的时间复杂度,又减少了调整的频率。
**「面试官」**: 非常好的回答。那么,您知道为什么MySQL选择使用B+树作为索引结构,而不是使用这些树结构吗?
**『求职者』**: 这是一个很好的问题。MySQL选择B+树作为索引结构,主要是出于以下几个考虑:

1. **磁盘访问优化**:
   - B+树是一种**多路搜索树**,每个节点可以存储多个键值,这样可以**显著减少树的高度**。
   - 降低树高意味着**减少磁盘I/O次数**,因为每个节点通常对应磁盘上的一个页。
2. **范围查询效率**:
   - B+树的所有数据都存储在叶子节点,叶子节点之间通过指针连接。
   - 这种结构使得**范围查询非常高效**,只需要找到范围的起始点,然后沿着叶子节点遍历即可。
3. **数据存储优化**:
   - B+树的非叶子节点只存储键值信息,不存储数据,这样**每个节点可以存储更多索引**。
   - 更多的索引意味着更少的树高,进一步减少了I/O操作。
1. **查询稳定性**:
   - 由于所有数据都在叶子节点,所以**任何查询都要到叶子节点**,查询时间比较稳定。
   - 相比之下,二叉树结构在不同情况下的查询时间可能差异较大。
1. **适应性强**:
   - B+树**对于大数据量和磁盘存储**特别有效,可以很好地适应数据库系统的需求。
   - 它能够在**插入和删除操作**后自动维护平衡,保证性能的稳定性。

相比之下,二叉搜索树、AVL树和红黑树虽然在内存中表现良好,但在处理大规模数据和磁盘I/O时就显得不够高效。它们的节点通常只包含单个数据项,导致树的高度相对较高,不适合频繁的磁盘访问。
总之,B+树在**磁盘I/O、范围查询、数据存储效率和查询稳定性**等方面的优势,使其成为MySQL等关系型数据库系统的理想选择。
**「面试官」**: 您对B+树的理解很深入。让我们转向另一个话题,您刚才提到了哈希搜索。能否告诉我哈希的时间复杂度是多少?以及在使用哈希时需要注意什么?
**『求职者』**: 当然,我很乐意回答这个问题。
首先,关于哈希的时间复杂度:

1. **平均情况**:
   - 哈希表的**查找、插入和删除**操作的平均时间复杂度都是**O(1)**。
   - 这是哈希表最大的优势,也是它被广泛使用的原因。
1. **最坏情况**:
   - 在最坏情况下,时间复杂度可能退化到**O(n)**。
   - 这种情况通常发生在**严重的哈希冲突**时。

关于使用哈希时需要注意的事项:

1. **选择合适的哈希函数**:
   - 好的哈希函数应该**均匀分布**键值,minimizing冲突。
   - 它应该**计算速度快**,不应该成为性能瓶颈。
1. **处理哈希冲突**:
   - 常用方法包括**链式寻址**和**开放寻址**。
   - 需要根据具体应用场景选择合适的冲突解决策略。
1. **负载因子**:
   - 需要关注哈希表的**负载因子**(已使用的桶数/总桶数)。
   - 当负载因子过高时,需要**考虑扩容**以维持性能。
1. **数据分布**:
   - 如果预先知道数据分布,可以**优化哈希函数**以适应特定的数据集。
1. **安全性考虑**:
   - 在某些场景下(如密码存储),需要使用**加盐哈希**或其他安全哈希算法。
1. **内存使用**:
   - 哈希表通常需要**额外的内存**来存储桶和链表结构。
   - 在内存受限的环境中需要权衡使用。
1. **迭代顺序**:
   - 哈希表**不保证元素的顺序**,如果需要有序遍历,可能需要额外的数据结构。
1. **哈希函数的选择**:
   - 对于不同的数据类型,可能需要**不同的哈希函数**。
   - 例如,字符串和整数可能需要不同的哈希策略。

通过正确处理这些注意事项,我们可以充分发挥哈希表的优势,在实际应用中获得excellent的性能。
**「面试官」**: 非常好的回答。现在让我们讨论一下并发和并行。您能解释一下并发和并行有什么区别吗?
**『求职者』**: 当然,我很乐意解释并发和并行的区别。这两个概念经常被混淆,但它们实际上有着明显的区别:

1. **并发(Concurrency)**:
   - 定义:并发是指**多个任务在重叠的时间段内启动、运行和完成**的能力。
   - 特点:
      - 不一定同时执行,而是**交替执行**。
      - 主要目的是**提高程序的响应性**和**throughput**。
      - 可以在**单核处理器**上实现。
   - 例子:单核CPU上的多任务处理,通过时间片轮转来交替执行不同的任务。
1. **并行(Parallelism)**:
   - 定义:并行是指**多个任务或多个子任务同时执行**的能力。
   - 特点:
      - 需要**多核处理器**或分布式系统的支持。
      - 主要目的是**提高程序的执行速度**。
      - 真正的**同时执行**多个任务。
   - 例子:在多核CPU上,不同的核心同时执行不同的任务。
1. **关键区别**:
   - **执行方式**:并发是交替执行,并行是同时执行。
   - **资源要求**:并发可以在单核上实现,并行需要多核或多台机器。
   - **目标**:并发主要是为了better利用CPU和I/O资源,并行是为了加速计算。
   - **复杂性**:并发通常比并行更复杂,因为需要处理任务间的协调和同步。
1. **实际应用**:
   - 在实际系统中,并发和并行常常**同时存在**。
   - 例如,一个多线程程序在多核处理器上运行时,既有并发(多个线程交替使用同一个核心),也有并行(不同的线程在不同的核心上同时执行)。
1. **编程模型**:
   - 并发编程常使用**多线程、异步I/O**等技术。
   - 并行编程可能涉及**MPI、OpenMP**等并行计算框架。

理解这两个概念的区别对于设计高效的系统和选择合适的编程模型非常重要。在实际应用中,我们often需要根据具体需求和硬件条件来决定使用并发、并行或两者结合的方式。
**「面试官」**: 很好的解释。那么,您能进一步解释一下线程和进程的区别吗?
**『求职者』**: 当然,我很乐意解释线程和进程的区别。这是操作系统中的两个核心概念,理解它们的区别对于系统设计和编程都非常重要。

1. **定义**:
   - **进程(Process)**:是**程序在执行过程中的实例**,是系统进行资源分配和调度的基本单位。
   - **线程(Thread)**:是**进程内的执行单元**,是CPU调度和分派的基本单位。
1. **资源占用**:
   - **进程**:拥有独立的**内存空间**、**文件描述符**、**程序计数器**等资源。
   - **线程**:共享所属进程的内存空间和其他资源,但有自己的**栈空间**和**寄存器**。
1. **创建和销毁
