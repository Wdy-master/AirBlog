---
title: 6.3 学历差，就不能学计算机？扯
urlname: obr7vwumxdr170hy
date: '2024-06-13 21:14:36'
updated: '2024-06-13 21:14:43'
cover: 'https://cdn.nlark.com/yuque/0/2024/png/22382235/1717507741102-eba64c0a-1c3f-474c-b789-9fbd816c8ac3.png'
description: 大家好，我是白露。最近看到一篇帖子，不得不跟大家好好唠嗑唠嗑！这位网友说“真别学计算机了，计算机真是天坑，学历差的真别学了。”然后列举了一些看似正确，实则站不住脚的观点，xs。这话可以说是让我瞠目结舌。今天，白露就好好聊一聊，希望能给大家一些清醒的思考。学历与能力：别总拿学历说事儿没错，学历的...
---
大家好，我是白露。

最近看到一篇帖子，不得不跟大家好好唠嗑唠嗑！
![image.png](https://oss1.aistar.cool/elog-offer-now/c76d6e1930bc28ad3794fff1c72871d3.png)
这位网友说“**真别学计算机了，计算机真是天坑，学历差的真别学了**。”然后列举了一些看似正确，实则站不住脚的观点，xs。

这话可以说是让我**瞠目结舌**。今天，白露就好好聊一聊，希望能给大家一些清醒的思考。
### 学历与能力：别总拿学历说事儿
没错，学历的重要性不可否认，但在计算机行业，**能力才是王道**。

你可以通过实战项目、竞赛、开源贡献来展示自己的实力，完全不需要自怨自艾。人家ACM选手和开源大佬厉害，那是他努力的结果，你也可以成为其中一员，只要你肯下功夫。

### 自我实现：别忘了初心

有些人觉得计算机工作辛苦，那是因为你只看到了眼前的拼搏，而忽略了每个项目结束后的成就感和满足感。

**选对了兴趣所在，工作不再是痛苦，而是一场享受**。你再看看那些真正热爱编程的人，哪一个不是充满着对未来的期待和动力？

### 就业市场需求：计算机专业的黄金地带
咱们来看看实际情况。计算机专业是市场需求最大的领域之一。
**不管是互联网企业、金融行业还是科技公司，对计算机人才的需求都是“供不应求”**。
你以为在同学中多卷两年就没用了？那是因为你还没看到企业招聘时对计算机人才的渴求程度。有了硬实力，简历通过率高得惊人。
### 职业发展前景：别只看眼前，放眼未来
计算机领域是技术最前沿的舞台，各种新技术层出不穷。**掌握了计算机技术，你就是立于不败之地**。
从人工智能到大数据、再到云计算，每一个方向都有无数的机会等待你来探索。你觉得两年刷LeetCode难，那是因为你还没看到以后在这些领域大展拳脚时的光景。

### 持续学习能力：没点硬实力，哪都混不下去
计算机行业最大的特点就是不断学习、不断进步。
有人抱怨“天天卷天天学”，可是你有没有想过，这是在培养你解决问题的能力和持久的学习习惯？

**这些都是最宝贵的职业素质**。在这个竞争激烈的世界，停滞不前才是最大的问题。你以为其他行业就不需要学习了？醒醒吧，这年头无论做什么，只有跟上时代的步伐，才有出路。
### 多样选择：什么香不香，你说了算
最后，不要被所谓“香不香”的言论带偏了。
**国企养老有它的优势**，但计算机专业的挑战和回报同样不容小觑。

关键是找到自己真正适合和热爱的方向，钱不是唯一的衡量标准，成就感和个人成长同样重要。
### 清醒点，别被带节奏

总之，不要一叶障目，这世界上没有哪条路是轻松的。**计算机也好，国企也罢，每条路都有自己的风景**。你需要的是找到适合自己的路，并坚持不懈地走下去，而不是被一时的压力和外界的言论所左右。

兄弟姐妹们，坚定自己的选择，努力提升自我。如果你有不同的观点或想法，欢迎在评论区与我分享和讨论。我们下次再见！好了，我们来看一篇字节的面试，如果不想看，可以直接跳转到文末，有惊喜：

# 开始面试

**面试官**: 你好，请进行自我介绍。

**求职者**: 您好，我是一名软件开发工程师，拥有计算机科学背景。我精通C++和数据库管理，对数据结构和算法有深入的理解。我曾参与过多个项目，涉及后端开发、系统设计以及性能优化。我对新技术充满热情，并喜欢在快节奏的环境中解决复杂的技术问题。

**面试官**: 你知道的搜索算法有哪些？

**求职者**: 我知道的搜索算法包括线性搜索、二分搜索、深度优先搜索（DFS）、广度优先搜索（BFS）、启发式搜索如A*搜索算法，以及哈希表查询等。

**面试官**: 二叉搜索树、二叉平衡树、红黑树有什么区别？

**求职者**: 二叉搜索树是一种节点的左子树只包含小于该节点的数，右子树只包含大于该节点的数的二叉树。

二叉平衡树（如AVL树）是一种二叉搜索树，它要求任何节点的两个子树的高度差不能超过一，这样确保了树的平衡状态，改善了搜索效率。红黑树也是一种自平衡的二叉搜索树，它通过确保任何路径上不会出现两个连续的红色节点来保持大致的平衡，这样可以保证最长的路径不会超过最短的路径的两倍。

**面试官**: MySQL为什么用B+树？

**求职者**: MySQL使用B+树作为其索引结构主要是因为B+树的查询性能稳定，且在磁盘I/O操作上具有较高的效率。

B+树的所有值都存在叶子节点上，并且叶子节点通过指针连接，这使得范围查询变得非常快速。其内部节点只存储键值，可以在相同的空间内存储更多的键，从而减少了树的高度和磁盘I/O次数。

**面试官**: 哈希的时间复杂度是多少？

**求职者**: 最理想情况下，哈希表的查找、插入和删除操作的时间复杂度都是O(1)。

但在最坏的情况下，如果所有的键都映射到同一个槽中，那么时间复杂度会退化为O(n)，其中n是键值对的数量。

**面试官**: 哈希在使用时要注意什么？

**求职者**: 在使用哈希时需要注意避免哈希冲突，选择一个好的哈希函数来分散键值对。还需要考虑哈希表的扩容问题，因为当哈希表中的元素太多时，性能会下降。
此外，对于安全相关的应用，需要考虑防止哈希碰撞攻击，比如通过使用加密哈希函数。

**面试官**: 并发和并行有什么区别？

**求职者**: 并发是指系统能够处理多个任务的能力，这些任务可能不是同时执行的，但可以交错执行，给人一种同时进行的错觉。
并行则是指多个任务真正同时执行，这通常需要多个处理器或者多核处理器。

**面试官**: 线程和进程有什么区别？

**求职者**: 进程是操作系统资源分配的基本单位，每个进程都有自己独立的内存空间。
线程是程序执行的最小单位，是进程的一个实体，同一进程内的线程共享该进程的地址空间和资源。线程之间的通信和同步比进程更简单，但也更容易出现同步问题。

**面试官**: 你知道的语言里垃圾回收算法有什么？

**求职者**: 常见的垃圾回收算法包括标记-清除、标记-整理、复制算法、引用计数和分代收集。
标记-清除算法通过标记活动对象然后清除未标记的对象来回收内存。标记-整理算法在标记阶段类似，但是会将所有活动对象移动到一端，以避免内存碎片。复制算法将可用内存一分为二，一半空间用来分配对象，当这部分内存用完时，就将活动对象复制到另一半空间中。引用计数是跟踪每个对象的引用数量，当引用数量为零时释放对象。分代收集是基于对象生命周期不同分为几代，不同代使用不同的回收策略。

**面试官**: C++智能指针说一下。

**求职者**: C++的智能指针是一种资源管理的工具，它可以自动管理内存的分配和释放，避免内存泄露。
有三种主要的智能指针：`std::unique_ptr`、`std::shared_ptr`和`std::weak_ptr`。`std::unique_ptr`是一个独占所有权的智能指针，它不允许复制，只能移动。`std::shared_ptr`通过引用计数来共享所有权，当引用计数降到零时，资源会被自动释放。`std::weak_ptr`是一种不控制对象生命周期的智能指针，它用来解决`std::shared_ptr`相互引用造成的循环引用问题。

**面试官**: 项目方面，你能谈谈你最近的一个项目经历吗？

**求职者**: 我最近的一个项目是开发了一个多线程的网络服务程序，它能够处理数千个客户端的并发连接。
在这个项目中，我负责实现了客户端的请求分发和响应处理逻辑，以及后端数据的存储和检索。我使用了线程池来优化资源的使用，并引入了C++11的新特性，如lambda表达式和智能指针来简化代码和提高性能。

**面试官**: 来手撕一个LRU缓存的实现。

**求职者**: LRU（最近最少使用）缓存可以使用一个哈希表和一个双向链表来实现。
哈希表负责快速查找节点，双向链表负责维护节点的顺序。在C++中，可以使用`std::unordered_map`来实现哈希表，自定义一个双向链表或使用`std::list`。

```cpp
#include <iostream>
#include <unordered_map>
#include <list>

class LRUCache {
private:
    struct CacheNode {
        int key;
        int value;
        CacheNode(int k, int v) : key(k), value(v) {}
    };

    int capacity;
    std::list<CacheNode> cacheList;
    std::unordered_map<int, std::list<CacheNode>::iterator> cacheMap;

public:
    LRUCache(int capacity) : capacity(capacity) {}

    int get(int key) {
        auto it = cacheMap.find(key);
        if (it == cacheMap.end()) return -1;
        cacheList.splice(cacheList.begin(), cacheList, it->second); // Move to front
        return it->second->value;
    }

    void put(int key, int value) {
        auto it = cacheMap.find(key);
        if (it != cacheMap.end()) {
            // Update the value
            it->second->value = value;
            // Move the updated node to the front
            cacheList.splice(cacheList.begin(), cacheList, it->second);
            // No need to update the iterator in the map, as it still points to the correct node
            return;
        }
        if (cacheList.size() == capacity) {
            // Erase the least recently used element from the map and list
            cacheMap.erase(cacheList.back().key);
            cacheList.pop_back();
        }
        // Insert new element at the front and update the map
        cacheList.emplace_front(key, value);
        cacheMap[key] = cacheList.begin();
    }
};
```
