---
title: 双非进大厂也并非不可能
urlname: elocqv7dobz6tlo1
date: '2024-07-05 12:09:59'
updated: '2024-07-05 12:10:22'
cover: 'https://cdn.nlark.com/yuque/0/2024/png/22382235/1719834296789-8cc59077-2735-471a-b01c-7120874f3c05.png'
description: 大家好，我是白露啊。今天我们要分享一个非常励志的故事，它证明了双非背景的毕业生也可以通过努力和坚持，进入梦想中的大厂。下面是这位网友的真实经历，希望能为正在找工作的你提供一些激励和参考。背景介绍这位网友的背景并不特殊，他是一名双非本科毕业生。实习经历包括顺丰和货拉拉。在秋招时，他只有一个秋招期...
---
大家好，我是白露啊。

今天我们要分享一个非常励志的故事，它证明了双非背景的毕业生也可以通过努力和坚持，进入梦想中的大厂。
![image.png](https://oss1.aistar.cool/elog-offer-now/2baf616a40c97917d7f96208169266cb.png)
下面是这位网友的真实经历，希望能为正在找工作的你提供一些激励和参考。

---

### 背景介绍
这位网友的背景并不特殊，他是一名双非本科毕业生。实习经历包括顺丰和货拉拉。

在秋招时，他只有一个秋招期间烂大街的博客项目，而在春招期间，他换成了一个短链接项目。
### 秋招和春招的面试与Offer
**秋招：** 他参加了多个面试，但能拿到的中大厂后端面试仅有货拉拉（零星的一两个小厂就不提了）。
**春招：** 春招期间情况有所好转，他陆续拿到了汽车之家、树美科技、小黑盒和美团的面试机会。
相比秋招，春招确实多了很多机会，感觉一部分是因为项目更具吸引力了，而且他也积累了更多的经历。
### 秋招和春招的感悟
**学历重要，但不是决定因素**：
对于校招生来说，学历、实习经历、优秀的项目或开源经历确实是非常重要的。

但是，他自己的经历证明了，**学历低并不完全意味着无法进入中大厂**。

在秋招时，他看着周围的人不断拿到面试机会，而自己却机会渺茫，这让他极度焦虑。

然而，他没有放弃。

**不断完善自己，抓住每个机会**：
他在实习的同时，一边投递秋招的简历，一边学习八股算法，还忙着寻找耗时短但亮眼的项目。这一切都是因为他深知自身简历的劣势，无论是学历还是项目经历，均不占优势。

因此，他不断寻找机会去完善自己。
货拉拉给了他一个机会，他抓住了。

尽管那时候他的简历还很一般，使用的项目也是烂大街的博客项目，但他凭借毅力和勤奋成功获得了这次难得的机会。
**提升自我，增加面试机会**：
转到春招时，由于他完善了个人项目并且提前去货拉拉实习，丰富了履历，他的面试机会显著增加。

他拿到了美团和快手的面试机会，并最终选择了美团的offer。不得不说，**马哥的短链项目在短时间内快速掌握并且有很多亮点，非常适合用来充实简历**。
### 给24届校招生的建议
**把握机会，提升自我**：
虽然学历无法改变，但我们可以把握住各种机会。

没有面试机会不可怕，最可怕的是，当机会来临时没有好好把握。如果他在秋招时没有把握住货拉拉的机会，没有提前去实习增加履历，春招的机会可能也会少很多。
**不断增加履历，提升自我**：
我们要做的就是不断丰富自己的履历，不断提升自己。

当机会来临时，一定要抓住。这个网友的经历告诉我们，双非背景确实有可能进入大厂。关键在于如何利用每一个机会，如何通过不懈的努力去追求自己的目标。

---

总结一下，这个网友的分享证明，学历背景并不是决定你能否进入大厂的唯一因素。

通过努力、坚持和不断自我提升，每个人都有机会实现自己的职业梦想。

希望他的经验和建议能激励更多的24届校招生，让大家在求职路上更加坚定和自信。
如果你有任何问题或想法，欢迎在评论区和我讨论分享。
# 美团一面面经
**面试官**: 你好，先简单介绍一下你在实习经历中觉得最有价值的一个case吧。
**求职者**: 当然。我在实习期间参与了一个对**CompletableFuture多线程接口**进行优化的项目。这个项目的背景是我们在处理大量并发任务时，发现现有的多线程实现存在性能瓶颈和资源浪费的问题。我们希望通过使用**CompletableFuture**来优化多线程处理。
**面试官**: 那么，你们为什么选择使用**CompletableFuture**进行优化？它解决了哪些关键问题？
**求职者**:

- **背景**：我们原先的多线程实现采用的是传统的**Thread**和**ExecutorService**，在处理大量并发任务时，出现了线程资源浪费和性能瓶颈的问题。
- **关键问题**：
   - **线程管理**复杂：传统的线程管理需要手动控制线程的创建和销毁，容易导致资源浪费。
   - **任务依赖**：处理任务依赖关系复杂，手动管理任务之间的依赖关系容易出错。
   - **阻塞**：传统的多线程方法容易出现阻塞，降低了整体性能。

**面试官**: 使用**CompletableFuture**进行优化后，带来了哪些问题？使用它时需要注意哪些点？
**求职者**:

- **带来的问题**：
   - **调试难度增加**：由于异步执行，调试和排查问题变得更加复杂。
   - **异常处理复杂**：异步任务中的异常处理需要特别注意，容易遗漏。
- **注意点**：
   - **线程池选择**：需要合理选择和配置线程池，以避免线程资源的浪费和性能瓶颈。
   - **任务依赖管理**：需要特别注意任务之间的依赖关系，确保任务能够正确执行。
   - **异常处理**：需要在每个异步任务中进行适当的异常处理，避免异常传播影响整体流程。

**面试官**: 你们在使用**CompletableFuture**时，线程池是怎么考虑的？
**求职者**: 我们选择了**ForkJoinPool**作为默认的线程池，因为它能够更好地利用多核CPU资源。同时，我们也根据任务的具体需求，创建了自定义的**ThreadPoolExecutor**，用于处理一些特定的任务。
### 进程间通信
**面试官**: 看你是科班出身，我们聊聊**进程间通信**（IPC）吧。你能介绍一下进程间通信的方式吗？
**求职者**: 当然。进程间通信的方式主要有以下几种：

- **管道（Pipe）**：用于父子进程之间的通信，单向传输。
- **命名管道（Named Pipe）**：用于任意进程之间的通信，双向传输。
- **消息队列（Message Queue）**：用于不同进程之间通过消息传递数据。
- **共享内存（Shared Memory）**：多个进程共享同一块内存区域，速度快，但需要同步机制。
- **信号量（Semaphore）**：用于进程间的同步，控制对共享资源的访问。
- **套接字（Socket）**：用于不同主机之间的通信，也可以用于本地主机的进程间通信。

**面试官**: 那么从操作系统设计者的角度考虑，为什么需要设计这么多种进程间通信的方式？
**求职者**:

- **不同的应用场景**：不同的通信方式适用于不同的应用场景。例如，管道适用于简单的父子进程通信，而共享内存适用于需要高效数据传输的场景。
- **性能需求**：不同的通信方式在性能上有差异，共享内存速度快但复杂，而消息队列和信号量则相对简单但速度慢。
- **同步需求**：有些通信方式如信号量和消息队列提供了同步机制，适用于需要严格同步的场景，而共享内存则需要额外的同步机制。
- **网络通信**：套接字不仅适用于本地通信，还可以用于网络通信，具有广泛的应用范围。
### TCP和UDP
**面试官**: 好的，我们再聊聊网络协议。**TCP和UDP**主要有什么差别？
**求职者**:

- **TCP（Transmission Control Protocol）**：
   - **连接型协议**：在传输数据之前需要建立连接。
   - **可靠性**：提供可靠的数据传输，确保数据包按顺序到达，并且没有丢失。
   - **流控制和拥塞控制**：TCP具有流控制和拥塞控制机制。
   - **应用场景**：适用于需要可靠传输的应用，如HTTP、FTP、邮件等。
- **UDP（User Datagram Protocol）**：
   - **无连接协议**：无需建立连接，直接传输数据包。
   - **不可靠**：不保证数据包的顺序和完整性，可能会丢失或重复。
   - **低开销**：由于没有连接建立和维护，传输效率高。
   - **应用场景**：适用于对实时性要求高但不要求可靠传输的应用，如视频流、在线游戏、DNS等。

**面试官**: 那么，怎么基于**UDP**实现一个可靠的通信协议？
**求职者**: 可以基于UDP实现一个可靠的通信协议，以下是一些关键点：

- **序列号**：为每个数据包分配一个序列号，接收方可以根据序列号重组数据包，并检测丢失的数据包。
- **确认机制**：接收方在接收到数据包后发送确认（ACK）给发送方，发送方在超时未收到确认时重新发送数据包。
- **重传机制**：发送方在超时未收到确认时，重新发送数据包。
- **流控制**：根据接收方的处理能力，调整发送数据包的速率，避免接收方过载。
- **拥塞控制**：通过检测网络拥塞情况，动态调整发送速率，避免网络拥塞。
### 线程安全的单例模式
**面试官**: 请写一个**线程安全的单例模式**，需要使用`final`、`private`构造函数、`volatile`和双重检查。
**求职者**: 这是一个使用`Java`实现的线程安全单例模式示例：
```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {
        // 私有构造函数，防止外部实例化
    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
**解释**：

- **volatile**：确保多线程环境下的可见性，防止指令重排序。
- **private构造函数**：防止外部实例化。
- **双重检查**：在同步代码块内外都进行检查，以提高性能。
### 数据库隔离级别
**面试官**: 你了解**数据库隔离级别**吗？
**求职者**: 了解。数据库的隔离级别决定了事务之间的隔离程度，共有四种常见的隔离级别：

1. **读未提交（Read Uncommitted）**：最低的隔离级别，允许读取未提交的数据，可能会导致脏读。
2. **读已提交（Read Committed）**：只允许读取已提交的数据，避免脏读，但可能会出现不可重复读。
3. **可重复读（Repeatable Read）**：在一个事务内多次读取相同数据时，结果是一样的，避免不可重复读，但可能会出现幻读。
4. **可序列化（Serializable）**：最高的隔离级别，完全隔离事务，避免幻读，但性能开销最大。
### 联合索引
**面试官**: **联合索引**在不满足最左匹配原则时为什么会失效？
**求职者**: 联合索引在不满足最左匹配原则时会失效，这是因为数据库在创建联合索引时，是按照索引列的顺序进行排序的。只有按照最左前缀顺序查询时，才能有效利用索引。如果查询条件不包含最左边的列，数据库无法利用索引的排序信息，导致索引失效，退化为全表扫描。
### 算法题
**面试官**: 最后我们来做一道算法题。一个变形的二分查找，做法是根据`mid`所处的下标奇数偶数决定是去`mid-1`还是`mid+1`。你可以试着写一下代码吗？
**求职者**:当然，我们继续。
**求职者**: 好的，我来写一下这个变形的二分查找的代码。假设我们有一个已经部分排序的数组，并且我们需要根据`mid`的位置是奇数还是偶数来决定下一步的搜索方向。
```java
public class Solution {
    public int modifiedBinarySearch(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] == target) {
                return mid;
            }

            if (mid % 2 == 0) {  // 如果mid是偶数
                if (nums[mid] < target) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            } else {  // 如果mid是奇数
                if (nums[mid] < target) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
        }

        return -1;  // 如果没找到，返回-1
    }
}
```
**解释**：

- **初始化左右指针**：`left`指向数组的左端，`right`指向数组的右端。
- **计算中间位置**：`mid = left + (right - left) / 2`，避免直接相加可能导致的整数溢出。
- **比较中间值和目标值**：
   - 如果`nums[mid] == target`，返回`mid`。
   - 如果`mid`是偶数且`nums[mid] < target`，则目标值在右半部分，移动`left`指针。
   - 如果`mid`是偶数且`nums[mid] >= target`，则目标值在左半部分，移动`right`指针。
   - 如果`mid`是奇数且`nums[mid] < target`，则目标值在左半部分，移动`right`指针。
   - 如果`mid`是奇数且`nums[mid] >= target`，则目标值在右半部分，移动`left`指针。
- **循环终止条件**：当`left > right`时，停止循环，如果没有找到目标值，返回`-1`。

**面试官**: 很好，今天的面试就到这里了，感谢你的回答。我们会尽快通知你结果。祝你好运！

---

