---
title: 牛马也要卖个好价钱：我劝你不跳槽也要多面试
urlname: qkzq1vr17x0d30lq
date: '2024-07-05 12:09:28'
updated: '2024-07-05 12:09:59'
description: hey，大家好，我是白露啊。前几天，智联招聘有一篇文章“建议大家有事没事就去面试”上了热搜，引发了很多网友的共鸣。这让我想起之前有位实验室的师兄也跟我提过类似的观点：市场在不断变化，即使不打算换工作，也一定要多去面试，因为面试不仅仅是找工作，更是看世界的一种方式。面试是看世界的窗职场中，我们常...
---
hey，大家好，我是白露啊。
前几天，智联招聘有一篇文章“建议大家有事没事就去面试”上了热搜，引发了很多网友的共鸣。

这让我想起之前有位实验室的师兄也跟我提过类似的观点：市场在不断变化，即使不打算换工作，也一定要多去面试，因为面试不仅仅是找工作，更是看世界的一种方式。

---

## 面试是看世界的窗
职场中，我们常自嘲为“牛马”，但即便是牛马也要卖个好价钱。

定期出去面试，不仅仅是为了换工作更重要的是通过面试了解市场现状，定位自己的身价。

HR朋友曾说：“市场不断变化，即使不换工作，也一定要多去面试，因为面试也是去看世界。”

我们要学会在晴天修屋顶，多去面试，了解市场现状，做好风险预测和自我评估。
## 显示市场价值，调整期望
通过面试，我们可以清晰地了解自己的市场价值。

如果你的薪资是8K，通过面试了解市场行情，如果都是8K左右，那你的薪资处于正常水平。

但如果市场薪资水平都是12K，而你只拿到8K，那么你可能需要考虑跳槽了。

而如果你的薪资高于市场水平，那你就可以安心提升自己的业务能力，在当前的企业中继续发展。

面试不仅能帮我们了解市场，也能让我们在与领导谈薪时更有底气。
## 发现自身优势和短板
面试不仅是职业发展的“体检”，更是发现自身优势和短板的好机会。

很多人害怕面试，尤其是群面时畏缩不前，但其实通过多次面试，可以积累经验，逐步提升自信。

你会发现，大部分企业的面试问题大同小异。通过多次面试交流，可以更加清晰地认识到自己的优缺点。
## 拓展行业人脉和资源
通过面试积累经验和拓展人脉圈子是另一个重要的好处。

每次面试都是了解企业需求、薪资水平和工作情况的好机会。

更重要的是，你可以通过面试链接到行业内的资源，为未来职业发展打下基础。
## 掌握面试技巧，提升自我价值

1. **筛选企业，有效面试**
   - 面试前，一定要对企业进行背景调查，筛选出与自己匹配度高的公司。避免“路上2小时，面试5分钟”的情况，不仅浪费时间，还没有实际效果。
2. **掌握面试话术，熟练应对**
   - 面试要像“海王”一样，掌握熟练的面试技巧和话术。通过不断练习，你会发现自己的表现越来越好，真正需要找工作时，这些经验会成为你的预演。
3. **链接行业人脉，拓展职业资源**
   - 面试不仅是找工作的过程，还是一个拓展人脉的好机会。通过面试，你可以接触到行业中的“大咖”，获得更多职业资源和机会。
4. **多面试多学习，不怕失败**
   - 面试是一个学习的过程，不要害怕失败。每次面试后进行复盘，找出自己不足的地方，在工作中加强学习和改进，逐步补齐自己的短板。
5. **利用面试发现新机会**
   - 在面试过程中，不仅要展示自己，还要学会发现企业的潜在机会。有时，一些岗位在招聘时会有隐藏的要求，多提问，可能会为自己争取到意想不到的新机会。
6. **心态平和，享受过程**
   - 最后，不要把面试看成任务或考试，放平心态，把它当作一次自我提升和了解市场的途径。在这个过程中见到不同的人，接触不同的企业，你会发现一个更优秀的自己。
## Ending
没有一劳永逸的行业，也没有铁饭碗岗位。

我们要学会“居安思危”。

正如白露之前一直提到过的那样，在面试的过程中，算法非常重要。我在学习网站里分享了《剑指offer详解》，是当初我校招面试的时候斩获十几个offer的精华总结。
今天我就以一道题来展示一下：
# 001.赋值运算符函数
有一个类声明如下，请重载其赋值运算符：
```cpp
class CMyString
{
public:
    CMyString(char *p = nullptr);
    CMyString(const CMyString& str);
    ~CMyString();
private:
    char *m_pData;
}
```
即**重载赋值运算符**，完成str1=str2=str3···等赋值操作，对于这个数组结构而言，就是传递m_pData指针，所以题目考察的就是如何安全简洁地实现指针的复制。
## 补充：赋值/拷贝重载函数
> 默认使用是浅拷贝，也就是说将**该对象的内存原封不动地挪动到新对象的内存中**，因此对于含有指针的类，**这种方式很有可能造成有多个指针指向同一块空间**，**在析构时候同一块空间析构多次导致崩溃，**因此需要实现深拷贝来完成拷贝。

这道题有四个要点：

- **重载运算符**是怎么重载的？
- 返回**自身的引用（this）**（为了实现连等操作）；
- 注意**内存消耗以及内容的不变性**（有时由于内存错误会造成原数据丢失，即异常安全性）;
- 判断**是不是同一个实例（比如a==a）**；

先给出一个**初代版本**：
```cpp
CMyString& CMyString::operator=(const CMyString& other)
{
    if (this != &other)
    {
        // 析构了对象，但是其对应的内存地址起始还在
        delete[] m_pData;
        // 其实可以直接new，但是delete之后
        // 将指针赋值为nullptr
        // 是C++程序员的基本操作
        m_pData = nullptr;
        // 之所以用strlen是因为如果用size
        // 数组就退化为指针了哦
        m_pData = new char[strlen(other.m_pData) + 1];
        // 前面是目的
        strcpy(m_pData, other.m_pData);
    }
    return *this;
}
```
> strlen所作的是一个计数器的工作，它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，**直到碰到第一个字符串结束符'\0'为止**，然后返回计数器值(长度不包含'\0')。

上述代码是先释放了原本的内存空间，而后再开辟新的，要是···新的内存不够呢？出现异常呢？那以前的数据不就丢失了么？ 因此我们需要**考虑出现异常如何解决**。 **改进版本**：
```cpp
CMyString& CMyString::operator=(const CMyString& other)
{
    if (this != &other)
    {
        //先分配空间
        char *pTemp = new char[strlen(other.m_pData) + 1];
        strcpy(pTemp, other.m_pData);
        //分配成功后再释放原来的内存
        delete[] m_pData;
        m_pData = nullptr;
        m_pData = pTemp;
    }
    return *this;
}
```
还可利用**临时对象自动构造析构的特性**的实现方法：
```cpp
class mystring{
public:
    mystring(char* Pdata);
    mystring(const mystring& str);
    ~mystring();
    mystring& operator=(const mystring&str){
        /**以下实现了操作的异常安全性，并释放原有的内存，因为strTemp会自动析构**/
        if(&str!=this){
            mystring strTemp(str);
            char* pTemp=strTemp.m_pData;
            strTemp.m_data=m_pData;
            m_pData=pTemp;    
            // 上面的代码，其实就是
            // swap（m_pData,strTemp.m_data）；       
        }
        return *this;
    };
private:
    char* m_data;
}
```
> 1.class 与struct有什么区别？ 答：（其实这两者都可以用来定义成员变量、成员函数等等，都可以声明public和private）区别就在于struct的默认权限是public，而class是private；另一个区别为，class可用于声明类模板，而struct不可以； 2.C++中对象的建立可以**在堆和栈上**。分别为**静态建立和动态建立**的方式，构建**堆上的对象时一般使用new关键字**，而**对象的指针在栈上**。使用new在堆上构建的对象需要主动的**delete销毁**。 C++对象可以在堆或栈中，函数的传参可以是对象(对象的拷贝)，或是对象的指针。

如果你想进一步学习，可以点击网站学习，里面有我分享的上百道算法题。
[🗡 剑指OFFER精讲](https://offernow.cn/s/algorithm/hogrunp9g0bggri2)
