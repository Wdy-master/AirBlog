---
title: 5.29 寒冬来了，字节跳动开启裁员新模式。。
urlname: xkmfsfmiumxogo0z
date: '2024-06-13 21:14:37'
updated: '2024-06-13 21:14:44'
cover: 'https://cdn.nlark.com/yuque/0/2024/png/22382235/1716905308210-c5848a68-e0ca-4acd-8cc3-7e7643f9c671.png'
description: 大家好，我是白露啊。不得不说，字节跳动还是真的会搞事啊。最近一段时间，字节搞出了一个裁员新模式：“细水长流”。这个寓意和“财（裁）源（员）广进”计划差不多了，只不过比较含蓄了。在一个著名社交平台上里，有字节员工发帖称，HR透露北京已经裁员到了不让裁员的地步。相比过去的一次性大规模裁员，目前字节...
---
![image.png](https://oss1.aistar.cool/elog-offer-now/7fe06e844361934bca7312149c391682.png)

大家好，我是白露啊。

不得不说，字节跳动还是真的会搞事啊。

最近一段时间，字节搞出了一个裁员新模式：**“细水长流”**。这个寓意和“**财（裁）源（员）广进**”计划差不多了，只不过比较含蓄了。

在一个著名社交平台上里，有字节员工发帖称，**HR透露北京已经裁员到了不让裁员的地步**。

相比过去的一次性大规模裁员，目前字节跳动的新裁员模式显得低调不少。这表明字节正在执行**一种考核优化策略**，这也是为什么一直**没有爆炸性裁员消息**被媒体大肆报道的主要原因。

然而，这种不一样的裁员动作背后，**透露的是字节业务调整的步伐开始显得举棋不定**。
![image.png](https://oss1.aistar.cool/elog-offer-now/3bb730adfb9a88288e87ace78ca433af.png)
现在的字节，可能缺少了张一鸣时期的锐意进取，那种一往无前的**自信**了。

投资人童士豪曾说：“抖音的崛起不是平白无故的，张一鸣砸钱比谁砸得都多，**他所展现出来的气势和格局比我们任何人想象得都大。**”

**职场风云不可预测**，有起伏也有辉煌。大家要记住，任何时候，我们都应该积极应对，不畏艰难，找到适合自己的位置，多找找副业，不要只想着能在公司一直打工。

因为，铁打的营盘，流水的兵。只是，字节不一定是铁打的，**但流水的兵是确定的**。

现在国际IT形势也不好，国内国外都在裁员。如果兄弟们也有类似的裁员经历，欢迎评论区分享~

今天就来分享一下字节——今日头条的一个面试题。
# 开始面试

**面试官**: 你好，欢迎参加面试。首先请你解释一下进程与线程的区别。

**求职者**: 进程是系统进行资源分配和调度的一个独立单位，它拥有独立的地址空间和系统资源。而线程是进程的一个执行流，是CPU调度和执行的最小单位，同一进程中的线程共享该进程的地址空间和资源。线程相比进程有更小的开销，上下文切换更快，但也因为资源共享，需要更细致的同步和并发控制。

**面试官**: 很好。那么，能描述一下TCP连接的过程吗？

**求职者**: TCP连接的建立是通过三次握手过程完成的。首先，客户端向服务器发送一个SYN（同步）报文，然后服务器响应客户端一个SYN-ACK（同步确认）报文。最后，客户端再发送一个ACK（确认）报文给服务器，完成三次握手，建立连接。

**面试官**: 对于为什么TCP连接是三次握手而不是两次，你怎么看？

**求职者**: 三次握手的目的是为了确保双方的发送和接收能力都是正常的。如果只有两次握手，那么只能确认一方的发送和接收能力，不能确保另一方能接收到信息。此外，三次握手可以防止已失效的连接请求报文突然又传送到了服务端，造成资源浪费。

**面试官**: 那么，TCP是怎么确保数据传输的可靠性的？

**求职者**: TCP通过序列号、确认应答、重传机制、流量控制和拥塞控制等技术来确保数据传输的可靠性。序列号用来保证数据的顺序，确认应答和重传机制用来处理丢包问题，流量控制防止发送方过快发送数据导致接收方来不及接收，拥塞控制则是防止过多的数据注入到网络中，造成网络拥塞。

**面试官**: 你对系统和数据库有了解吗？

**求职者**: 是的，我对操作系统的基本概念如进程管理、内存管理和文件系统有一定的理解。对于数据库，我熟悉基本的SQL操作，数据库设计，以及索引优化等。

**面试官**: 好，那现在请你手撕一个二进制字符串求和的问题。

**求职者**:

```java
public String addBinary(String a, String b) {
    StringBuilder sb = new StringBuilder();
    int i = a.length() - 1, j = b.length() - 1, carry = 0;
    while (i >= 0 || j >= 0) {
        int sum = carry;
        if (j >= 0) sum += b.charAt(j--) - '0';
        if (i >= 0) sum += a.charAt(i--) - '0';
        sb.append(sum % 2);
        carry = sum / 2;
    }
    if (carry != 0) sb.append(carry);
    return sb.reverse().toString();
}
```

**面试官**: 很好，你解决了问题。这就结束了我们的面试，感谢你的参与。



