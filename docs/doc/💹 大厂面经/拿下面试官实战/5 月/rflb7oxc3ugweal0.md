---
title: 5/2 美团实习
urlname: rflb7oxc3ugweal0
date: '2024-06-13 21:14:38'
updated: '2024-06-13 21:14:46'
cover: 'https://cdn.nlark.com/yuque/0/2024/png/22382235/1714524504982-5895272f-aa56-4611-b140-f196338fbb67.png'
description: 'https://www.nowcoder.com/feed/main/detail/b6e7154498094ed4a8fbde61769b30d4面试官: 嗨，欢迎来到美团的后端面试。我们今天会讨论一些技术问题，先从基础开始。你能给我讲讲HashMap的原理以及它为什么线程不安全吗？还有，红...'
---
> [https://www.nowcoder.com/feed/main/detail/b6e7154498094ed4a8fbde61769b30d4](https://www.nowcoder.com/feed/main/detail/b6e7154498094ed4a8fbde61769b30d4)


**面试官**: 嗨，欢迎来到美团的后端面试。我们今天会讨论一些技术问题，先从基础开始。你能给我讲讲**HashMap的原理**以及它为什么**线程不安全**吗？还有，**红黑树的结构**是怎样的？

**求职者**: 当然可以。**HashMap的原理**基于散列表，它通过hashcode来计算键的存储索引。由于多线程同时修改HashMap可能会导致竞态条件，这就是它**不安全**的原因。至于**红黑树**，它是一种自平衡的二叉查找树，具有五个基本性质，保证了操作的效率。

**面试官**: 很好。接下来谈谈**ConcurrentHashMap**。它是怎样**保证线程安全**的？在**1.8版本中有哪些优化**？为什么从**ReentrantLock改成了CAS加synchronized**？

**求职者**: **ConcurrentHashMap**通过分段锁的机制来保证线程安全。在1.8版本中，进行了结构上的优化，引入了**Node数组加链表加红黑树**的结构，提高了并发度。它之所以从**ReentrantLock改为CAS加synchronized**，是为了在保证安全的同时，提高了读操作的效率，减少了锁的竞争。

**面试官**: 明白了。那如果在Java中只重写**hashcode**或**equals**会怎样？

**求职者**: 如果只重写其中一个，会破坏hashcode和equals的一致性，导致在集合操作中出现错误。比如，两个对象逻辑相等但可能被分配到不同的bucket，或者相同bucket中认为是不同的元素。

**面试官**: 解释一下数据库的**最左匹配原则**，以及给定的SQL查询条件在使用联合索引(a, b, c)时会怎样？

**求职者**: **最左匹配原则**指的是数据库在使用联合索引时会从左到右的顺序来匹配条件。对于给定的查询条件，①会充分利用到索引，因为它遵循了索引的顺序；②则只能部分利用索引，因为b的条件是一个范围查询，会使得c的索引部分失效。

**面试官**: 很好。那你能告诉我为什么数据库索引会选用**B+树**吗？

**求职者**: **B+树**是因为它能保持数据的有序性，并且它的分支统一，查询效率稳定。此外，它的叶子节点带有指针，便于范围查询，适合磁盘读取，提高了IO效率。

**面试官**: 那么，谈谈**事务隔离级别**，尤其是**可重复读**解决了哪些问题？

**求职者**: 事务隔离级别包括读未提交、读已提交、可重复读和串行化。**可重复读**主要解决了脏读和不可重复读的问题，保证了在同一个事务中多次读取相同记录的结果是一致的。

**面试官**: MySQL是如何实现可重复读的？它是怎样解决脏读和不可重复读问题的？

**求职者**: MySQL的可重复读是通过**MVCC（多版本并发控制）**实现的。它会为每个事务生成一个唯一的版本号，对于更新操作，数据库会保留原数据的快照。这样就即解决了脏读也解决了不可重复读的问题。

**面试官**: 接下来，描述一下**JVM内存结构**。

**求职者**: JVM内存结构主要包括堆内存、方法区、虚拟机栈、本地方法栈和程序计数器。**堆内存**是最大的一块，存放对象实例；**方法区**存储类信息、常量、静态变量等；**虚拟机栈**存储局部变量表、操作数栈等；**本地方法栈**用于支持native方法；**程序计数器**是线程私有的，记录当前线程执行的字节码的行号。

**面试官**: Redis你都用过哪些数据类型？

**求职者**: Redis的常用数据类型包括**字符串(String)**、**列表(List)**、**集合(Set)**、**有序集合(ZSet)**和**哈希(Hash)**。每种数据类型都有其适用的场景，如字符串可用于缓存，列表适用于队列等。

**面试官**: 你能解释一下Redis是如何实现**分布式锁**的吗？

**求职者**: Redis实现分布式锁主要是通过**SETNX命令**，它可以设置一个key，如果key不存在则操作成功，存在则失败。通过这种方式可以确保锁的唯一性。还可以使用**过期时间**来避免死锁。

**面试官**: 谈谈**缓存穿透**和**缓存雪崩**。

**求职者**: **缓存穿透**是指查询不存在的数据，导致每次都要去数据库查询，可以通过缓存空值或布隆过滤器解决。**缓存雪崩**是指大量缓存同时失效，导致数据库压力骤增，可以通过设置不同的过期时间或使用熔断限流策略来缓解。

**面试官**: 你如何看待**缓存空值**与**布隆过滤器**的区别和优缺点？

**求职者**: **缓存空值**可以防止数据库查询不存在的数据，但如果攻击者使用不同的查询条件，仍然可能导致缓存穿透。**布隆过滤器**可以更有效地防止穿透，但存在一定的误判率，并且一旦设定，难以变更。

**面试官**: 你用过哪些**消息队列**？能描述一下**RocketMQ**的结构吗？

**求职者**: 我用过**RabbitMQ**和**Kafka**。**RocketMQ**的结构包括**生产者、消费者、NameServer和Broker**。NameServer作为路由信息的注册中心，Broker负责存储和传输消息。

**面试官**: 在消息队列中，怎么**保证不重复消费**？如果**消费失败了**应该怎么办？

**求职者**: 为了保证不重复消费，可以设置消息唯一ID并在消费端做好去重处理。如果消费失败，可以采用**重试机制**，对于一些不可恢复的错误，可以将消息记录下来，进行人工干预。

**面试官**: 那么，我们现在来**简单聊一下你的项目**。请你简要介绍一下你参与的一个你认为最有挑战的项目，并说明你在其中扮演的角色。

**求职者**: 在我最近的一个科研项目中，我从事的是将飞行器动力转向元宇宙的研究。在这个项目中，我负责数据的采集和分析，使用了机器学习算法来预测和优化性能参数。这个项目不仅对我的技术能力是一个挑战，也让我对元宇宙领域有了更深入的了解。

**面试官**: 听起来你有很丰富的经验。我们现在来做一道编程题，**LC143重排链表**。你准备好了吗？
![image.png](https://oss1.aistar.cool/elog-offer-now/857d8cb64dba9ac005f5aec4db37fcbd.png)
**求职者**: 好的，我来试一下。这道题目的目的是重新排列链表，使得原链表的第一个元素后跟最后一个元素，然后是第二个元素和倒数第二个元素，以此类推。我会先找到链表的中点，然后翻转后半部分，最后将两个链表合并。

```java
public void reorderList(ListNode head) {
    if (head == null || head.next == null) return;

    // Find the middle of the list
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // Reverse the second half of the list
    ListNode prev = null, curr = slow, tmp;
    while (curr != null) {
        tmp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = tmp;
    }
    
    // Merge two halves
    ListNode first = head, second = prev;
    while (second.next != null) {
        tmp = first.next;
        first.next = second;
        first = tmp;
        
        tmp = second.next;
        second.next = first;
        second = tmp;
    }
}
```

**面试官**: 非常棒，我们会尽快给你反馈。

