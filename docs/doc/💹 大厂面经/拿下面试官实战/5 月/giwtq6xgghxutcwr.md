---
title: 5.32 不愧是华为，这个薪资离谱了。。
urlname: giwtq6xgghxutcwr
date: '2024-06-13 21:14:36'
updated: '2024-06-13 21:14:44'
cover: 'https://cdn.nlark.com/yuque/0/2024/png/22382235/1717080395966-8bb343ec-c196-4911-a4b0-e13476f3def8.png'
description: "大家好，我是白露啊。 在我的博客、博客分享网站的留言里，经常能够看到学生问“华为应届生薪资是多少？”、“评级13级对应的总包有多少？”等等问题。今天想和大家讨论一下华为这个神奇的存在。不愧是华为，这薪资真的令人惊叹啊！  拿好小本本，记下来吧！ \U0001F539智能制造与精密制造工程师：13.5k * 1..."
---
大家好，我是白露啊。 

在我的博客、博客分享网站的留言里，经常能够看到学生问“**华为应届生薪资是多少？**”、“**评级13级对应的总包有多少？**”等等问题。

今天想和大家讨论一下华为这个神奇的存在。不愧是华为，**这薪资真的令人惊叹啊！ **

 拿好小本本，记下来吧！ 
🔹智能制造与精密制造工程师：**13.5k * 14** 
🔹AI工程师：**32k *（14-16）** 
🔹通用软件开发：**14k *（具体级别不详，估计更高）** 
🔹结构材料与工程师：**20k * 14** 
🔹硬件开发：**25k *（14-16）** 
🔹数字能源：**19k * 16** 
🔹无线算法：**36k * 12 + 10w** 
🔹软件开发：**25k *（14-16）** 
🔹GTS：**18k *（15-17）** 
![image.png](https://oss1.aistar.cool/elog-offer-now/23784d76873dac9b08870ebe33acaf9c.png)
无疑，华为的薪资待遇在行业内非常具有竞争力，难怪吸引了大量优秀的应届生和职场老手们纷纷前来求职。 
![image.png](https://oss1.aistar.cool/elog-offer-now/7910306ef9ad71516e71062d185bb2e9.png)
然而，高薪背后也意味着高压和高强度的工作环境。华为人常说“华为工时不破法”，这也是对他们努力工作的肯定和写照。

每一个进入华为并成功扎根的人，都承受了巨大的付出。 

作为过来人，我深知每一个职场选择都有它的风雨和彩虹。**无论你选择了哪个方向，招聘的薪资高低都不是唯一的衡量标准**。

重要的是找到能够让你实现自我价值的舞台，寻找内心真正的热爱。 

不管你是刚毕业的应届生，还是有多年经验的职场老手，希望大家都能在自己的职场道路上，找到适合自己的位置。

现在，还没有拿到offer的同学，可以看看一次**华为的**面试题目了，已经稳定的同学，**可以直接跳转最后，有惊喜哦~**
# 开始面试

**面试官**: 你好，欢迎参加面试。首先，请介绍一下你的项目。

**求职者**: 您好，我参与的项目是一个基于Go语言开发的实时数据处理系统，它能够处理和分析来自不同数据源的大量数据。系统利用Go的并发特性来实现高效的数据处理，支持数据的实时采集、清洗、聚合和存储。我们使用了微服务架构，每个服务都是独立部署，通过gRPC进行通信。项目中我主要负责数据清洗和聚合模块的开发，以及与前端服务的数据接口设计。

**面试官**: 在并发访问数据库时，你是如何保证访问安全的？

**求职者**: 在Go中，可以通过使用`sync`包中的`Mutex`锁来保证并发访问数据库的安全。在访问数据库前加锁，在访问结束后释放锁。另外，也可以使用数据库本身的事务处理机制，通过设置合适的隔离级别来避免脏读、不可重复读和幻读问题，保证数据库操作的原子性、一致性、隔离性和持久性。

**面试官**: 能简述一下关系数据库和非关系数据库的区别吗？

**求职者**: 关系数据库使用表格的形式来组织数据，支持SQL查询，强调ACID属性，适合结构化数据和复杂查询。而非关系数据库，如文档数据库、键值存储、列族存储和图数据库等，它们不严格遵循ACID属性，支持灵活的数据模型，适合非结构化或半结构化数据，通常在水平扩展和处理大规模数据方面表现更好。

**面试官**: 多线程和单线程的区别？

**求职者**: 多线程程序可以同时执行多个任务，能够充分利用多核CPU的计算资源，提高程序的执行效率和响应速度。单线程程序一次只能执行一个任务，执行过程中的任何阻塞都会导致整个程序的暂停。但多线程也带来了更复杂的状态管理和同步问题，而单线程模型（如Go的协程）可以通过事件循环和非阻塞I/O来实现高并发。

**面试官**: 现在让我们进入算法题环节。第一个问题：多条公交线，从某一站到另一站（两站可能不在同一号线），最少换线次数是多少？

**求职者**: 这个问题可以通过构建一个图来解决，其中节点表示公交站，边表示公交线路。然后使用广度优先搜索（BFS）算法来找到从起点到终点的最短路径，路径上的边数即为最少换线次数。在Go中，可以使用队列来实现BFS。

```go
// 假设有一个函数getNeighbors来获取某站可以直接到达的其他站点
// 为了简化，这里不展示具体实现细节

func minTransfer(start, end int) int {
    visited := make(map[int]bool)
    queue := []int{start}
    transfers := 0

    for len(queue) > 0 {
        size := len(queue)
        for i := 0; i < size; i++ {
            current := queue[0]
            queue = queue[1:]
            if current == end {
                return transfers
            }
            for _, neighbor := range getNeighbors(current) {
                if !visited[neighbor] {
                    visited[neighbor] = true
                    queue = append(queue, neighbor)
                }
            }
        }
        transfers++
    }
    return -1 // 如果无法到达，则返回-1
}
```

**面试官**: 第二个问题：一个字符串中，取长度为k的子串，找出子串中a,b,c的个数最多的字符串？

**求职者**: 这个问题可以通过滑动窗口算法来解决。我们可以维护一个长度为k的窗口，统计窗口内a,b,c的数量，然后滑动窗口遍历整个字符串，记录下包含a,b,c最多的子串。

```go
func maxABCSubstring(s string, k int) string {
    count := make(map[byte]int)
    maxCount, start := 0, 0

    for i := 0; i < len(s); i++ {
        if s[i] == 'a' || s[i] == 'b' || s[i] == 'c' {
            count[s[i]]++
        }

        if i >= k {
            if s[i-k] == 'a' || s[i-k] == 'b' || s[i-k] == 'c' {
                count[s[i-k]]--
            }
        }

        currentCount := count['a'] + count['b'] + count['c']
        if currentCount > maxCount {
            maxCount = currentCount
            start = i - k + 1
        }
    }

    if maxCount == 0 {
        return ""
    }
    return s[start : start+k]
}
```

**面试官**: 非常好！今天的面试就到这里。

