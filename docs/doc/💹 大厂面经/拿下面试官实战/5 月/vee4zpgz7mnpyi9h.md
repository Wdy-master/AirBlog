---
title: 5.7 字节薪资解密。。张一鸣啥等级？
urlname: vee4zpgz7mnpyi9h
date: '2024-06-13 21:14:38'
updated: '2024-06-13 21:30:13'
cover: 'https://cdn.nlark.com/yuque/0/2024/jpeg/22382235/1715176258995-f9432213-e1dc-43e8-9587-72d19f9528d6.jpeg'
description: 大家好，我是白露啊。 之前说BAT，可能是指百度、阿里、腾讯，但是现在，这个 B，大多数时候指的是字节跳动了。随着抖音系产品的流量持续升温，字节跳动已经是一个毋庸置疑的互联网大厂了，不管是想进去，还是已经入职的，大家其实对一件事情最感兴趣：那就是字节跳动的薪资到底有多少？。今天，我分享一下我从...
---
大家好，我是白露啊。 
![698d35748650191a2ded5756f781ebe.jpg](https://oss1.aistar.cool/elog-offer-now/ba01d626b28b2562a13868503981a976.jpeg)
之前说BAT，可能是指**百度、阿里、腾讯**，但是现在，这个 B，大多数时候指的是**字节跳动**了。

随着抖音系产品的流量持续升温，字节跳动已经是一个毋庸置疑的互联网大厂了，不管是想进去，还是已经入职的，大家其实对一件事情最感兴趣：**那就是字节跳动的薪资到底有多少？**。

今天，我分享一下我从字节的朋友了解到的**字节的薪资和职级体系**。
（广告）

---

我们先简单聊一聊职级和大概的晋升逻辑。

字节跳动的职级共分为10个级，研发序列从1-1到5-2一共10级，每个大级别下又细分为1到2个小级别。
![image.png](https://oss1.aistar.cool/elog-offer-now/f63a2a96aabfc5ee1b7ea651b838852a.jpeg)
虽然有1-1的职级，但是现在校招入职的应届生一般是**1-2**。

在1-2 待 2年左右可以升级到2-1，**部分优秀的同学可能一年就升职了**，这主要是看业务发展以及领导是否**看重**你。

2-1和2-2 属于研发主力，到了这一步，你的技术已经成熟，拿到的项目和责任也更加重大。不过2-2通常会主要负责团队的某个子领域，一般称其为**Owner**。

3级属于领导层，也就是**所谓的ld**，到3-1和3-2，**基本上已经不会参与实际的代码研发**。

但并不绝对，如果是纯技术部门，比如内部基建、技术架构，某些团队LD仍然热衷于搞一线开发；但是如果是业务为导向的部门，你一直搞开发，ld的ld会觉得你领导力不太行……

另外，从2-2升级到3-1是一道坎，并且如果一直呆在字节内部，这个时间可能会持续很长··· 很多时候反而是外部招聘来的人员更容易成为3-1，**毕竟外来的和尚好念经**。

而且，3级这个层级，基本上已经是普通开发人员**可能**达到的天花板了。

至于4-1和4-2，已经是高层领导了，其实绝大部分程序员都达不到，**努力和运气缺一不可，坑少人多**。

最上面的5-1和5-2级，可以不考虑了，**是张一鸣/梁汝波那个等级的**。

然后我们再来看看薪资。
![image.png](https://oss1.aistar.cool/elog-offer-now/85dc7570516aa046250e8ac96731b848.png)

| **职级** | **工资/年** | **年终奖** | **股权激励/年** | **总薪酬/年** |
| --- | --- | --- | --- | --- |
| 1-2 | ¥33万 | ¥8万 | -- | ¥41万 |
| 2-1 | ¥46万 | ¥12万 | -- | ¥58万 |
| 2-2 | ¥63万 | ¥20万 | ¥30万 | ¥113万 |
| 3-1 | ¥71.5万 | ¥30万 | ¥50万 | ¥150万 |
| 3-2 | ¥100万 | ¥40万 | ¥70万 | ¥210万 |
| 4-1 | ¥130万 | ¥50万 | ¥120万 | ¥300万 |
| 4-2 | ¥180万 | ¥80万 | ¥300万 | ¥560万 |

1-2的薪资中位数大约为33w，某些校招入职拿到ssp的学生会更高，有可能达到50w。2-1的薪资中位数大约为42.3w，而一旦你升到2-2，就会增至57.9w。

然后每升一个职级，大概会增加10~30%左右的薪资，这取决于你当时拿的绩效等级是m+还是e。

而到了3-1或更高级别，年薪超百万已成为常态。

注意，我上面说的只是部分采样所了解到的情况，**实际情况可能更高或更低（比如有的校招入职就年薪60万的）**，毕竟HR是根据不同的人报价的。

此外，年终奖的分配也是相当慷慨，多数员工的年终奖为0至6个月不等，一般是15薪，如果业绩超群，还有可能拿到更多。 

其实除了薪资之外，**字节的福利也很nice**。
1、**免费三餐**，大闸蟹、小龙虾等随机掉落
2、每月房补1500元（北京、上海），其他城市递减 
3、周末**加班1.5倍工资 **
4、**晚间打车报销 **
5、公司全额五险一金 
6、免费健身房+免费年度体检 
7、每年6天-15天年假，8天带薪病假 
8、每日下午茶供应（不过据了解，**已经逐年降低餐标了··哈哈**）

在我看来，一个人应当对未来有所规划，无论是立志于技术领域还是管理岗位，了解行业薪酬标准，定位自己的目标职级，为自己的职业生涯设定清晰的导向，才能一步一个脚印，稳健地朝着理想前进。 

好啦，介绍就到这里，如果大家对这份职级和薪资报告感兴趣，想要深入了解更多互联网大厂的职级晋升和薪酬体系，或者有想了解其他内容的，留言告诉我吧。

接下来我们来看一篇最新出炉的字节跳动面经，这一次面试的部门是国际电商。
# 面经内容
 **面试官**: 欢迎来到字节跳动的后端二面，让自我介绍吧。 

**求职者**: 好的！我是一名计算机科学与技术专业的学生，对后端开发充满热情。在校期间，我专注于提高我的编程技能和系统设计能力，并在多个项目中实践了这些技能。我熟悉Java和C++，并对数据库和网络编程有一定的了解。 
（此处我省略500字，你们自行组织）

**面试官**: 好的，现在让我们聊聊你的项目经历。 

**求职者**: 在我最近的项目中，我负责开发了一个基于微服务架构的电子商务平台。我在项目中主要负责订单管理模块，实现了订单的创建、查询和状态更新功能。我还参与了服务间的通信设计，并对订单服务进行了性能优化。 
（此处我省略500字，你们自行组织）

**面试官**: 很好，那你能解释一下什么是**进程**和**线程**吗？它们之间有什么区别和联系？ 

**求职者**: **进程**是操作系统进行资源分配和调度的基本单位，它包含了运行程序所需的代码和数据以及执行上下文。而**线程**是进程中的执行单元，它们共享进程的资源但拥有自己的执行栈和程序计数器。线程之间的切换开销小于进程，提高了程序的并发性能。进程和线程的主要区别在于资源的独立性和开销，它们共同构成了程序的并发执行结构。 

**面试官**: 谈谈你对**MySQL索引**的理解，包括它的类型和底层数据结构。索引在哪些情况下会失效？ 

**求职者**: MySQL的主要索引类型有**B+树索引**和**哈希索引**。B+树索引是最常用的索引类型，适用于范围查询；哈希索引适用于等值查询。索引可能因为多种原因失效，比如使用了前置通配符的LIKE查询、对索引列进行计算或函数操作，以及索引列参与了类型不匹配的比较等。 

**面试官**: 你了解**Redis**吗？用过哪些功能？

**求职者**: 它是一种基于键值的NoSQL数据库，常用来实现缓存策略。我使用过它的字符串、列表、集合、有序集合等数据结构来存储和管理数据。我还利用它的发布订阅功能实现了服务间的消息通信。 

**面试官**: 关于**Redis持久化**，你能详细说明一下吗？

**求职者**: 当然。Redis提供了两种主要的持久化方法：**RDB（Redis Database）**和**AOF（Append Only File）**。
**RDB**是通过创建数据集的快照来实现持久化的，它在特定的时间间隔内执行，适合需要快速加载和备份的场景。
而**AOF**持久化则是记录每个写操作到一个日志文件中，这种方式可以提供更高的数据安全性，因为即使发生故障，也能通过重放日志来恢复数据。AOF文件可以配置为每次写入、每秒写入或不定期写入，以平衡性能和数据安全性的需要。

**面试官**: 如果**Redis满了**，你会怎么处理？

**求职者**: 如果Redis满了，首先我会检查当前的淘汰策略是否合适，比如是否可以调整为更适合当前使用模式的策略。然后，我会考虑是否有不必要的数据可以删除，或者是否可以通过数据分片将部分数据迁移到其他Redis实例。此外，对热点数据和不常访问的数据进行区分，将不常访问的数据转移到其他存储系统也是一个可行的选择。 

**面试官**: 有实现过**LRU**或**LFU**缓存淘汰算法吗？能简单描述一下实现思路吗？ 

**求职者**: 实现LRU的一个简单方法是使用HashMap结合双向链表。HashMap用来存储键和指向链表节点的指针，以O(1)的时间复杂度访问缓存项。双向链表则按照访问顺序存储每个键，最近访问的节点移到链表头部，当缓存满时，链表尾部的节点（即最久未访问的节点）被淘汰。通过这种方式，我们可以在O(1)的时间复杂度内完成缓存项的访问、添加和删除操作。

**面试官**: 你有在**服务器上部署过程序**吗？部署过程是怎样的？ 

**求职者**: 是的。部署过程大概是：首先在本地编写和测试代码，然后将代码通过版本控制系统推送到服务器。在服务器上，我会编译代码生成可执行文件，并配置必要的环境变量和依赖库。最后，我会使用systemd或其他进程管理工具来启动和监控程序的运行。 

**面试官**: 了解过**集群**的概念吗？ 

**求职者**: 集群是一组协同工作的服务器，它们可以提供高可用性和负载均衡。集群中的服务器可以处理相同的任务，如果某个服务器失败，其他服务器可以接管其工作，从而提高了系统的稳定性和扩展性。 

**面试官**: 那你能介绍一下**虚拟内存**吗？ 

**求职者**: 虚拟内存是计算机系统内存管理的一部分，它允许程序认为它拥有连续的地址空间，而实际上这些内存可能被分散存储在物理内存和磁盘上。它通过内存分页机制实现，可以使得程序使用的内存超过物理内存大小。

**面试官**: 能解释一下**HTTPS**吗？ 

**求职者**: HTTPS是HTTP协议的安全版本，它在HTTP和TCP层之间加入了SSL/TLS加密层。通过使用HTTPS，数据在传输过程中可以被加密，从而保护了数据的安全性和完整性，防止了数据被窃听和篡改。 

**面试官**: 那么**TCP和UDP**的区别是什么？ 

**求职者**: TCP是一种面向连接的、可靠的传输协议，它提供了数据传输的确认、顺序和重传机制，适用于需要可靠传输的应用。而UDP则是一种无连接的协议，它发送的数据包不保证顺序和可靠性，但传输速度快，适用于实时应用如视频会议和在线游戏。 

**面试官**: 来看两道算法题，第一道，是 **搜索旋转排序数组**
![image.png](https://oss1.aistar.cool/elog-offer-now/77546451ad6ae6b12e14434f1ff8491c.png)

**求职者**: 这个问题可以通过二分搜索来解决。因为数组是旋转的，所以我们需要判断目标值可能位于哪个部分，然后相应地调整搜索的范围。
```python
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        if (n == 0) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
}

```

**面试官**: 很好，下一道，是 **排序链表**
![image.png](https://oss1.aistar.cool/elog-offer-now/3fae8290901dadd429cdfcffec62fd09.png)
**求职者**: 当然，我可以使用递归的方式来实现归并排序。首先，我需要使用快慢指针来找到链表的中点，然后递归地对两部分进行排序，最后将排序好的两部分合并。
```python
class Solution {
    public ListNode sortList(ListNode head) {
        return sortList(head, null);
    }

    public ListNode sortList(ListNode head, ListNode tail) {
        if (head == null) {
            return head;
        }
        if (head.next == tail) {
            head.next = null;
            return head;
        }
        ListNode slow = head, fast = head;
        while (fast != tail) {
            slow = slow.next;
            fast = fast.next;
            if (fast != tail) {
                fast = fast.next;
            }
        }
        ListNode mid = slow;
        ListNode list1 = sortList(head, mid);
        ListNode list2 = sortList(mid, tail);
        ListNode sorted = merge(list1, list2);
        return sorted;
    }

    public ListNode merge(ListNode head1, ListNode head2) {
        ListNode dummyHead = new ListNode(0);
        ListNode temp = dummyHead, temp1 = head1, temp2 = head2;
        while (temp1 != null && temp2 != null) {
            if (temp1.val <= temp2.val) {
                temp.next = temp1;
                temp1 = temp1.next;
            } else {
                temp.next = temp2;
                temp2 = temp2.next;
            }
            temp = temp.next;
        }
        if (temp1 != null) {
            temp.next = temp1;
        } else if (temp2 != null) {
            temp.next = temp2;
        }
        return dummyHead.next;
    }
}

```
**面试官**: 很好，等后续面试通知吧。
