---
title: 4/21 六个月滴滴实习：轻松、舒心又高薪！
urlname: yz0tvggwqsckul9e
date: '2024-06-13 21:14:39'
updated: '2024-06-13 21:14:47'
cover: 'https://cdn.nlark.com/yuque/0/2024/png/22382235/1713967235272-e1f0b889-27e8-4ef3-887a-d2f71bb98446.png'
description: 'https://www.nowcoder.com/discuss/610130751605981184?sourceSSR=post不久前，一位在滴滴后端研发部门实习了六个月的小伙伴在牛客网上分享了他的实习体验， 作者详细描述了他在滴滴的实习生活。从他的叙述中，我们可以感受到与其他互联网公司相...'
---
> [https://www.nowcoder.com/discuss/610130751605981184?sourceSSR=post](https://www.nowcoder.com/discuss/610130751605981184?sourceSSR=post)

不久前，一位在滴滴后端研发部门实习了六个月的小伙伴在牛客网上分享了他的实习体验， 作者详细描述了他在滴滴的实习生活。

从他的叙述中，我们可以感受到与其他互联网公司相比，**滴滴的工作环境显得相对轻松和舒适**。

他提到，自己在西二旗附近的两个职场工作过，**环境优美，绿植环绕，配备的办公设备也是业内顶尖水准**。 
![image.png](https://oss1.aistar.cool/elog-offer-now/67ad2fdf65cad2b622f1a561f3ef6dc7.png)
滴滴的工作福利虽然没有过多花哨的项目，但在基本饮食上做得很不错，尤其是晚餐的选择多样，价格合理。

此外，工作氛围友好，工作与生活的平衡得到了良好的保证，很少有加班的情况，且员工与领导之间关系融洽，相互尊重。 

更重要的是，作为北京互联网行业的一份子，**滴滴为实习生提供的薪资待遇也是相当可观的**。这样的工作稳定性和收入水平，对于很多正在寻找实习机会的年轻人来说，无疑具有很大的吸引力。 

在这篇分享中，这位同学不仅带给我们滴滴轻松舒适的工作环境感受，更向我们展示了在这家公司实习的独特价值和体验。

在最后，他分享了滴滴一面的面试问题，让我们跟随他的步伐，看看滴滴面试的难度呢。 

-----------------------------开始面试------

**面试官**: 你好，欢迎参加今天的面试。首先，能否讲讲你最近参与的项目？

**求职者**: 当然可以。最近我主要参与了一个电商平台的后端开发项目。在这个项目中，我负责商品管理模块，实现了商品的增删改查功能，以及与订单系统的对接。我们使用Spring Boot作为主要框架，利用MyBatis进行数据持久化操作，并且通过Redis实现了商品信息的缓存，以提高系统的响应速度。

**面试官**: 很好。请解释一下接口和抽象类的区别？

**求职者**: 接口和抽象类都可以用来定义抽象类型，但它们有几个主要区别。首先，接口可以定义方法签名，但不能包含方法实现（除了Java 8中的default方法），而抽象类可以包含方法实现。其次，一个类可以实现多个接口，但只能继承一个抽象类。此外，接口主要用于定义类型的契约，而抽象类则更多地被用来共享方法实现。

**面试官**: 那Java 8为什么要在接口中增加default方法呢？

**求职者**: Java 8中引入default方法主要是为了增强接口的功能和提供向后兼容的能力。通过default方法，接口可以有具体的实现，这样，当一个接口需要扩展新的方法时，不会破坏已有的实现类。这对于在不改变现有代码基础上扩展API非常有用。

**面试官**: 你能说说在什么情况下会使用接口或抽象类吗？

**求职者**: 通常，如果我们要定义一组类型必须遵守的契约，而不关心具体实现，那么就使用接口。如果我们既想定义契约又想提供一些方法的默认实现，那么可以使用抽象类。简而言之，如果多个类之间有很强的是“有能力做”的关系，用接口；如果是“是一个”的关系，使用抽象类更合适。

**面试官**: 谈谈`synchronized`的底层实现。

**求职者**: `synchronized`在底层主要通过对象监视器（Monitor）来实现同步。在JVM中，对象头会存储锁的状态和指向锁记录的指针。当一个线程尝试进入同步块时，它会检查对象头的标记字段。如果未被锁定，JVM会将锁的所有权标记为当前线程，并允许进入同步块。如果对象已被其他线程锁定，当前线程将会被阻塞，直到锁被释放。

**面试官**: 说说线程池的参数。

**求职者**: Java中线程池的核心参数包括：

1. **corePoolSize**：核心线程数，即使线程是空闲的，线程池也会尽量维持该数量的线程。
2. **maximumPoolSize**：最大线程数，线程池允许创建的最大线程数。
3. **keepAliveTime**：当线程数大于核心线程数时，这是多余空闲线程在终止前等待新任务的最长时间。
4. **unit**：`keepAliveTime`的时间单位。
5. **workQueue**：工作队列，用于存放等待执行的任务。
6. **threadFactory**：线程工厂，用于创建新线程。
7. **handler**：拒绝策略，当任务太多来不及处理时，如何拒绝任务。

**面试官**: 谈谈MySQL索引的底层实现。为什么用**B+树**不用**B树**？ 

**求职者**: MySQL索引的底层实现一般使用的是B+树数据结构。B+树相对于B树的优势在于它有更高的查询性能和范围查询能力。B+树的所有值都存在于叶子节点，并且叶子节点之间是相互链接的，这使得范围查询可以通过遍历叶子节点的链表来高效完成。而B树的值分布在整个树中，不利于快速范围检索。此外，B+树的内节点不存储数据，只存储键值，这意味着相同高度的B+树可以拥有更多的节点，减少了树的高度，从而减少了磁盘IO次数。 

**面试官**: Spring事务的底层实现是如何的？ 

**求职者**: Spring事务的底层实现主要基于AOP（面向切面编程）和事务抽象。当一个方法被@Transactional注解标记时，Spring会通过AOP为这个方法创建一个代理，该代理会在方法执行前后添加事务管理的逻辑。如果方法执行期间没有异常发生，那么事件顺利进行。

**面试官**: 那么，**MySQL索引的底层实现**是什么？

**求职者**: MySQL索引的底层实现主要是通过**B+树**数据结构，特别是InnoDB存储引擎的默认索引类型。B+树是一种平衡多路查找树，它可以保持数据排序，同时支持快速的插入、删除和查找操作。在B+树中，所有的值都存在叶子节点上，而且叶子节点之间是以链表形式相连的，这对于范围查询非常有效。

**面试官**: 为什么使用**B+树而不是B树**作为索引结构？

**求职者**: B+树相比B树有几个优点使其更适合用作数据库索引：

1. B+树的**磁盘读写性能更优**，因为它的内部节点不存储数据，只存储键值，这样可以有更多的键值放在同一页面，减少了IO次数。
2. B+树的**查询性能更加稳定**，因为所有查询都要查找到叶子节点，查询路径的长度相同。
3. B+树的叶子节点之间是相互链接的，这使得**范围查询更加高效**。

**面试官**: 谈谈**Spring事务的底层实现**机制。

**求职者**: Spring事务的底层是通过**AOP**（面向切面编程）和**事务抽象**来实现的。当在方法上使用`@Transactional`注解时，Spring会通过AOP在运行时创建一个代理，该代理会在方法执行前后添加事务管理的逻辑。如果方法执行成功，事务就会提交；如果方法执行过程中出现异常，则会回滚事务。Spring事务抽象还允许开发者定义事务的传播行为和隔离级别。

**面试官**: 那么在什么情况下**Spring事务可能会失效**？

**求职者**: Spring事务可能会在以下几种情况下失效：

1. **私有方法或非公共方法**上使用`@Transactional`，因为Spring事务代理默认只能应用于公共方法。
2. **同一个类内部的方法调用**，这种情况下事务的传播不会生效。
3. **方法没有抛出运行时异常或指定的异常**，事务默认只在出现运行时异常时回滚。
4. **事务管理配置错误**，如事务管理器没有正确配置或没有启用注解驱动的事务管理。

**面试官**: 讲讲**Redis的基本数据结构**。

**求职者**: Redis支持的基本数据结构包括：

1. **String**：字符串，可以包含任何数据，如文本或二进制数据。
2. **List**：列表，可以在头部或尾部添加元素，实现栈或队列的功能。
3. **Set**：集合，存储不重复的元素，支持集合间的运算如并集、交集。
4. **Hash**：哈希表，用于存储对象及其属性。
5. **ZSet (Sorted Set)**：有序集合，元素存储时会关联一个分数，按分数进行排序。

**面试官**: 那**ZSet数据结构**是由哪些部分组成的，以及常用的命令有哪些？

**求职者**: ZSet是由一对一映射的有序键值对组成的，每个元素都有一个**分数（score）**，用来进行排序。常用的命令包括：

1. `ZADD`：向ZSet添加元素。
2. `ZRANGE`和`ZREVRANGE`：根据排名范围获取元素。
3. `ZRANGEBYSCORE`和`ZREVRANGEBYSCORE`：根据分数范围获取元素。
4. `ZREM`：删除元素。
5. `ZINCRBY`：增加元素的分数。

**面试官**: 最后一个工程题，如何使用ZSet实现7_24小时的热搜词排行榜_，并每小时更新？

**求职者**: 使用Redis的ZSet来实现热搜词排行榜是非常合适的。我们可以将热搜词作为键，搜索次数作为分数存入ZSet。每当有新的搜索请求时，我们可以使用`ZINCRBY`命令来增加该热搜词的分数。为了实现每小时更新，我们可以设置一个定时任务，每小时对ZSet进行处理，比如移除分数最低的元素或者重置分数。此外，我们还可以使用滑动窗口算法来保留最近一小时内的热搜数据。


 
