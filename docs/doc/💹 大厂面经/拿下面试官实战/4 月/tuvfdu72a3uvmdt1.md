---
title: 3/27 太难了！阿里云面试令人发指！
urlname: tuvfdu72a3uvmdt1
date: '2024-06-13 21:14:42'
updated: '2024-06-13 21:14:50'
description: 'https://www.nowcoder.com/?type=818_1【提醒】通过这次面试经验，你将可以复习到以下知识点：面向对象编程（OOP）的基本概念：封装、继承、多态。Golang中goroutine与线程的区别和GMP模型的理解。Go的垃圾回收机制以及与Python垃圾回收的对比。G...'
---
> [https://www.nowcoder.com/?type=818_1](https://www.nowcoder.com/?type=818_1)

【提醒】通过这次面试经验，你将可以复习到以下知识点：

1. **面向对象编程（OOP）的基本概念：封装、继承、多态。**
2. **Golang中goroutine与线程的区别和GMP模型的理解。**
3. **Go的垃圾回收机制以及与Python垃圾回收的对比。**
4. **Go语言中对象存储位置的决策（栈 vs 堆）。**
5. **SQL索引的使用和优化策略。**
6. **缓存和数据库一致性保证的策略。**
7. **Redis的哈希实现、扩容机制和高并发支持。**
8. **Redis分布式存储的通信协议和数据一致性问题。**
9. **Kafka消费者数据积压的处理方法。**
10. **LeetCode 238 题目的解题思路和算法分析。**

**面试官**: 你好，欢迎参加阿里云的Golang开发岗位面试。首先，请你进行自我介绍。
**求职者**: 你好，我是一名热爱编程和技术挑战的开发者，对Go语言有深入的研究和实践经验。我有扎实的计算机科学基础，并且熟悉云计算和分布式系统。我希望能在阿里云这样充满活力和创新的环境中进一步发展我的职业生涯。
**面试官**: 很好。那你对OOP（面向对象编程）有什么理解？
**求职者**: OOP是一种编程范式，它使用"对象"来设计软件。对象可以包含数据（属性）和代码（方法）。OOP的核心概念包括封装、继承和多态。封装是指隐藏对象的内部状态和实现细节，只通过一个公共接口暴露功能。继承允许新创建的类（子类）继承父类的属性和方法。多态则是指不同类的对象可以以相同的方式被处理。
**面试官**: 那你能解释一下多态和继承的概念吗？
**求职者**: 当然。多态是指不同对象可以根据不同的实际类型来响应相同的消息。继承是一种机制，它允许一个类继承另一个类的特性，包括属性和方法，这样就可以重用和扩展现有的代码。
**面试官**: 如果你是语言开发者，你会怎么去设计和实现多态和继承的特性？
**求职者**: 设计多态和继承时，我会在语言层面提供类和接口的概念。对于继承，我会允许类通过extends关键字来继承另一个类。对于多态，我会使用接口和虚函数，允许子类通过implements关键字实现接口，并且可以覆写父类的方法来提供特定的行为。
**面试官**: 以Python为例，如果一个子对象覆盖了父对象的方法，会发生什么操作？
**求职者**: 在Python中，如果子类覆盖了父类的方法，那么当我们调用子类的该方法时，实际执行的是子类中定义的版本。这是多态性的一种表现。子类可以通过super()函数调用父类的方法。
**面试官**: 那么，Go里goroutine和线程的区别是什么？你了解GMP模型吗？
**求职者**: 是的，goroutine是Go语言的并发体，它比线程更轻量级，启动更快，内存占用更小，切换开销更低。GMP是Go运行时的调度模型，它由Goroutine、M（操作系统线程）和P（处理器）组成。每个P都会有一组本地的goroutine队列，M会从这个队列中获取goroutine来执行。
**面试官**: 如果goroutine阻塞了，会怎么做？
**求职者**: 如果一个goroutine在M上执行时发生了阻塞，比如进行了系统调用，Go运行时会将该M与goroutine分离，M会阻塞等待系统调用返回，而P会找一个新的M来继续执行其他goroutine。
**面试官**: 如果M对应的goroutine运行完了，其他M还有G，会怎么做？
**求职者**: 如果一个M上的goroutine运行完毕，而其他M上还有待运行的goroutine，那么这个M会尝试从其他P的本地队列或全局队列中偷取goroutine来执行，这个过程称为工作窃取。
**面试官**: Go的垃圾回收机制和Python有什么区别？循环引用，能否回收掉？
**求职者**: Go的垃圾回收是基于三色标记清除算法的，它会在运行时进行垃圾回收，不需要开发者显式释放内存。Go的垃圾回收器可以处理循环引用的情况。而Python使用引用计数来进行垃圾回收，它对循环引用的处理依赖于一个名为gc的模块。
**面试官**: Go会把新建的对象放到栈还是堆上？
**求职者**: Go语言的编译器会决定新建对象的位置，这取决于对象的逃逸分析结果。如果编译器确定一个对象在函数返回后不再被引用，它会将该对象分配在栈上；如果对象在函数返回后还会被引用，或者因为其他原因逃逸到函数外部，它就会被分配到堆上。
**面试官**: 如果前端请求的数据没有收到对应的消息，你会怎么排查？
**求职者**: 我会从前端开始逐步排查，首先检查网络请求是否正确发出，然后检查网络层面是否有丢包或延迟现象，再检查服务器端是否有接收到请求以及是否有正常响应。如果服务器端也没有问题，我会检查中间件或代理服务器是否有拦截或修改请求。
**面试官**: 前端收到的数据不符合预期，有时是乱码，怎么排查？
**求职者**: 首先，我会检查数据的编码格式是否一致，比如UTF-8编码是否在发送和接收时都得到了正确处理。然后，我会检查是否有数据传输过程中的损坏，如HTTP压缩错误。此外，我还会检查服务器端是否有正确处理数据，并且返回的HTTP头部中Content-Type字段是否正确。
**面试官**: 如果有A、B、C形成的联合索引，查询条件只有BC，能否使用到索引？
**求职者**: 是的，可以使用到索引，但是只有B和C一起使用时才能最优地利用索引。如果只有C，则不能利用索引，因为索引是按照A、B、C的顺序来创建的。
**面试官**: 如果SQL查询非常慢，你会怎么排查？
**求职者**: 我会首先使用EXPLAIN命令来分析查询语句，查看执行计划是否合理，比如是否有全表扫描、是否正确使用了索引。然后，我会检查数据库的性能指标，如磁盘I/O、CPU使用率和内存使用情况。我还会考虑查询语句本身的优化，比如减少不必要的JOIN操作和复杂的子查询。
**面试官**: 如果是回表操作导致的慢查询，你会怎么优化？
**求职者**: 回表操作通常发生在使用了覆盖索引的查询中。我可以通过调整查询语句或索引结构来优化，比如将查询中需要的列都包含在索引中，从而避免回表。同时，我也会考虑是否可以通过增加缓存层来减少数据库的压力。
**面试官**: 假如数据库遭受不住过高的QPS（每秒查询率），你会怎么办？
**求职者**: 我会考虑从应用层和数据库层两个方面来解决问题。在应用层，可以通过增加缓存来减少对数据库的直接访问。在数据库层，可以通过读写分离、数据库分库分表、增加读副本来提高并发处理能力。此外，还可以考虑使用更高效的数据存储解决方案，如NoSQL数据库。
**面试官**: 如何保证缓存和和数据库的一致性？
**求职者**: 保证缓存和数据库一致性的策略包括缓存穿透、缓存雪崩和缓存击穿的预防。具体来说，可以使用缓存更新策略，如写入时更新缓存、定时更新缓存或使用发布订阅模式来同步数据变更。另外，还可以使用版本号或时间戳来检查数据的新鲜度。
**面试官**: Redis里哈希的实现了解吗？
**求职者**: Redis的哈希是通过一个内部的数据结构实现的，它可以是ziplist或者hashtable。当哈希中的元素数量较少且每个元素的大小也较小的时候，Redis会使用ziplist来节省空间。当元素数量增加或元素大小变大时，Redis会将ziplist转换为一个更标准的hashtable。
**面试官**: 你知道其他的哈希实现方式吗？Redis哈希的扩容过程是怎样的？
**求职者**: 其他的哈希实现方式包括链表法、开放寻址法等。Redis的哈希在扩容时会进行渐进式rehashing。它会分配一个新的、更大的hashtable，然后在后续的操作中，逐渐将旧hashtable中的元素迁移到新hashtable中，这个过程不会阻塞主线程。
**面试官**: 扩容时会把程序给停止吗，还是说是一个多线程的方式？
**求职者**: Redis的rehashing是渐进式的，不会停止程序，也不是多线程方式。它是在主线程中，每次执行命令时，会顺带迁移一部分键值对到新的hashtable中，这样可以避免长时间的停顿。
**面试官**: Redis单线程怎么支持那么高的并发？
**求职者**: Redis是基于内存的存储，访问速度非常快，加上它的单线程模型避免了线程切换和锁的开销，所以即使是单线程也能支持高并发。此外，Redis的操作大多是O(1)复杂度，这也大大提高了其性能。
**面试官**: 你知道最新版本Redis有哪些优化特性吗？
**求职者**: 最新版本的Redis进行了许多优化，包括对内存的优化、更快的保存和加载数据的机制、更高效的集群模式等。它还增加了许多新的数据类型和命令，以支持更多的使用场景。
**面试官**: Redis分布式存储的底层通信协议是什么？这种协议能保证强一致性吗？
**求职者**: Redis分布式存储主要通过Redis协议进行通信。在Redis集群中，数据一致性是通过最终一致性来保证的，而不是强一致性。这意味着在一些情况下，如网络分区，数据可能会暂时不一致，但最终会达到一致状态。
**面试官**: 强一致性和非强一致性的区别是什么？
**求职者**: 强一致性意味着系统在更新数据后，任何后续的访问都会立即看到这个更新。而非强一致性（最终一致性）允许系统在更新数据后，经过一段时间后才对所有节点可见。非强一致性系统在可用性和分区容忍度上有更好的表现，但牺牲了一致性。
**面试官**: 你有没有碰到过Kafka消费者数据积压的情况？
**求职者**: 是的，我有处理过Kafka消费者数据积压的经验。通常情况下，积压可能是由于消费者处理速度跟不上生产者的速度，或者消费者出现了故障。解决方法包括增加消费者的数量，优化消费者的处理逻辑，或者调整Kafka的分区策略。
**面试官**: 你对命名空间有了解吗？
**求职者**: 命名空间通常用于隔离资源和权限，不同的命名空间下可以有相同的资源名称，但它们互不影响。在Kubernetes中，命名空间被广泛用于隔离不同的应用和环境。
**面试官**: 最后一个问题，算法方面。你熟悉LeetCode 238. 除自身以外数组的乘积这道题目吗？能简单描述一下解题思路吗？
**求职者**: [LeetCode 题解 | 238. 除自身以外数组的乘积](https://zhuanlan.zhihu.com/p/109306706?utm_id=0) 是的，这道题目的目标是输出一个数组，其元素是原数组中除了元素本身之外其他元素的乘积。一种解决方法是使用两个数组，一个存储从左到右的累积乘积，另一个存储从右到左的累积乘积。然后，对于输出数组的每个位置，我们可以通过左边的累积乘积乘以右边的累积乘积来得到结果。
**面试官**: 好，感谢你的参与，我们的面试到此结束。我们会尽快通知你面试结果。再次感谢你今天的到来。
**求职者**: 谢谢，期待您的回复。
