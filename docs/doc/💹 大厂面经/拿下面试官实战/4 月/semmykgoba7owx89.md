---
title: 4/11 百度| 三面凉经：百度Go实习生技术面试实录
urlname: semmykgoba7owx89
date: '2024-06-13 21:14:40'
updated: '2024-06-13 21:14:48'
description: '作者：nemurubaka链接：https://www.nowcoder.com/?type=818_1来源：牛客网下面分享一位同学在百度后端Golang实习的三面面试经历，对于这次面试，他的评价是，充满挑战。面试过程中遇到了网络信号问题，以及一些陌生的问题，让我们看看他是怎样应对这场战斗的。...'
---
作者：nemurubaka
链接：[https://www.nowcoder.com/?type=818_1](https://www.nowcoder.com/?type=818_1)
来源：牛客网
下面分享一位同学在百度后端Golang实习的三面面试经历，对于这次面试，**他的评价是，充满挑战**。面试过程中遇到了网络信号问题，以及一些陌生的问题，让我们看看他是怎样应对这场战斗的。

【提醒】通过这次面试经验，你将可以复习到以下知识点：

1. 从Python到Golang的技术选型思考
2. Redis的数据结构和键管理机制
3. TCP协议的连接建立过程
4. Golang的GMP调度模型和channel通信
5. MySQL事务的ACID特性及其实现
6. 系统设计：频率控制和分配问题解决方案
7. 算法：数组快速排序实现

【备选标题】
![](https://oss1.aistar.cool/elog-offer-now/53599936f96c8421c420da2ec2183891.jpeg)

**面试官**: 你好，欢迎来到百度的面试。能先给我做个自我介绍吗？

**求职者**: 您好，我是...（此处略去详细介绍）

**面试官**: 很好，那你能谈谈你之前的实习项目经历吗？

**求职者**: 在我的上一个实习中，我参与了...（此处略去详细描述）

**面试官**: 嗯，我注意到你之前用Python比较多，为什么这次选择Go语言呢？

**求职者**: 我选择Go是因为它在并发处理和系统性能方面的优势。Go的协程比Python的线程轻量，而且Go的静态类型和编译时检查能提供更好的性能和可靠性。我也想扩展我的技术栈，并在分布式系统和微服务架构中有更深入的了解和实践。

**面试官**: 说得好。那你了解Redis的string类型的底层结构是怎样的吗？

**求职者**: Redis的字符串类型可以用来存储字符串、整数或浮点数。底层实现是一个简单的动态字符串（SDS，Simple Dynamic String），这个结构比C语言的原生字符串类型更加灵活和安全，因为它记录了字符串的长度，避免了缓冲区溢出的问题，并且附加操作的效率更高。

**面试官**: 那Redis的键如何判断是否存在？

**求职者**: 我们可以使用`EXISTS`命令来检查一个或多个键是否存在。如果键存在，它会返回1；如果不存在，返回0。这个命令在键的检查上是非常高效的。

**面试官**: 好的。Redis的扩容方式和触发方式你知道吗？

**求职者**: Redis的扩容主要指的是集群的扩容，使用的是resharding过程，也就是重新分配键到不同的节点上。扩容可以手动触发，也可以在集群达到一定的负载或内存使用时自动触发。在Redis 3.0以上，扩容可以通过添加新的节点和迁移键来实现，过程中不会影响服务的可用性。

**面试官**: 讲得很清晰。接下来，请解释一下TCP三次握手的过程。

**求职者**: 在TCP连接的建立过程中，三次握手是确保双方能够通信的一种机制。第一次握手是客户端发送一个携带SYN标志的数据包到服务器以请求建立连接；第二次握手是服务器响应客户端的请求并发送一个携带SYN和ACK标志的数据包；第三次握手是客户端再次发送一个携带ACK标志的数据包作为对服务器响应的确认。这个过程确保了双方都知道彼此已准备好进行通信。

**面试官**: 那你对Golang的GMP模型和channel通信模型有了解吗？

**求职者**: 当然。Golang的GMP模型是Go的运行时调度器的基础。其中G代表Goroutine，是执行用户级代码的实体；M代表Machine，是工作线程；P代表Processor，是执行Goroutine所需的资源。Scheduler会将G分配到P上，并由M来执行。这个模型使得Go在并发调度上非常高效。而channel是Go中用于Goroutines之间的通信机制，它可以安全地在Goroutines之间传递数据，从而避免数据竞争。

**面试官**: 很好，那再谈谈你对MySQL事务的理解吧，它的特性是什么？

**求职者**: MySQL事务是一系列操作，要么全部成功，要么全部失败，它保证了数据的完整性。事务的特性通常由ACID来表示，即**原子性（Atomicity）**，**一致性（Consistency）**，**隔离性（Isolation）**，和**持久性（Durability）**。原子性确保事务中的所有操作都是作为一个整体执行的，一致性确保事务完成时，数据库从一个一致性状态转移到另一个一致性状态。隔离性保证了并发事务的操作互不干扰，持久性确保一旦事务提交，它对数据库的修改是永久性的。

**面试官**: 那隔离性是如何实现的呢？

**求职者**: 在MySQL中，隔离性是通过锁机制和多版本并发控制（MVCC）来实现的。锁机制包括共享锁和排他锁，用于控制对资源的并发访问。而MVCC则是在不同的隔离级别下，通过保持数据在特定时间点的多个版本，从而使读操作可以不阻塞写操作，反之亦然。

**面试官**: 假设在某个场景下，你只能保证事务的原子性，那么能保持数据的一致性吗？可以举个具体的例子吗？

**求职者**: 单纯的原子性并不能保证数据的一致性。比如，假设有一个简单的银行转账操作，从账户A转账到账户B。即使这些操作是原子性的（整个转账要么发生要么不发生），如果没有隔离性，可能会出现两个并发的转账事务互相干扰，导致总金额不一致。如果没有一致性检查，比如账户A的余额可能会变成负数，这就违反了业务规则。

**面试官**: 说得很清楚。那么，如果我们要求任意30秒内最多只能有5次请求，你会如何实现这个功能？

**求职者**: 这可以通过令牌桶算法来实现。我们可以设置一个令牌桶，每6秒添加一个令牌，桶的容量设为5。每个请求到来时，如果桶里有令牌，就从桶中取出一个令牌并处理请求；如果没有令牌，则拒绝该请求。这样就可以保证在任意30秒内，最多只处理5个请求。

**面试官**: 挺好的实现方法。现在有100个苹果，要放在最多10个篮子里，如何放置能保证无论选定1到100之间的任何一个数，都能用苹果的总数组成这个数？

**求职者**: 我们可以使用二进制来表示这100个苹果。也就是说，第一个篮子放1个苹果，第二个篮子放2个苹果，第三个篮子放4个苹果，依次类推，直到第七个篮子放64个苹果。因为100在二进制下是1100100，所以我们还需要一个篮子放32个苹果。这样，我们使用7个篮子，就能组合出1到100之间的任何一个数了。

**面试官**: 很聪明。最后，让我们来解决一个算法问题：编写快速排序算法，可以是链表也可以是数组的版本。
![image.png](https://oss1.aistar.cool/elog-offer-now/4810af430081486abbfd0e3f4b3789df.png)
**求职者**: 这是一个数组快速排序的实现：

```go
package main

import (
    "fmt"
)

func quickSort(arr []int, left, right int) {
    if left < right {
        pivotIndex := partition(arr, left, right)
        quickSort(arr, left, pivotIndex-1)
        quickSort(arr, pivotIndex+1, right)
    }
}

func partition(arr []int, left, right int) int {
    pivot := arr[right]
    i := left
    for j := left; j < right; j++ {
        if arr[j] < pivot {
            arr[i], arr[j] = arr[j], arr[i]
            i++
        }
    }
    arr[i], arr[right] = arr[right], arr[i]
    return i
}

func main() {
    arr := []int{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5}
    quickSort(arr, 0, len(arr)-1)
    fmt.Println(arr)
}
```

**面试官**: 代码写得不错。今天的面试到此结束，如果有任何问题，欢迎随时向我们咨询。谢谢你的参与。

**求职者**: 没有问题，感谢您的时间。

**面试官**: 不客气，祝你好运。再见。

**求职者**: 再见。

