---
title: 4/26 真香！腾讯拿到SP了！
urlname: bw0l9y2hx0qxc9w2
date: '2024-06-13 21:14:39'
updated: '2024-06-13 21:14:47'
cover: 'https://cdn.nlark.com/yuque/0/2024/png/22382235/1714305011026-7dc3654c-3e1c-45ab-b620-b0937b2d2bd4.png'
description: 面试腾讯需要做什么？大家好，我是青玉白露。为了准备面试腾讯的后台开发岗位，你需要全面地准备以下几个方面：1. 项目经验准备项目介绍：准备清晰的项目介绍，包括项目背景、你的具体角色、技术栈、关键功能、解决的难题以及项目的成果。深入理解项目：了解项目的每个细节，包括架构设计、数据库设计、性能优化等...
---
# 面试腾讯需要做什么？
大家好，我是青玉白露。

为了准备面试腾讯的后台开发岗位，你需要全面地准备以下几个方面：
### 1. 项目经验

- **准备项目介绍**：准备清晰的项目介绍，包括项目背景、你的具体角色、技术栈、关键功能、解决的难题以及项目的成果。
- **深入理解项目**：了解项目的每个细节，包括架构设计、数据库设计、性能优化等。
- **准备项目亮点**：准备一两个技术难点或亮点，准备好讲解这些亮点是如何实现和解决的。

### 2. 技术和知识准备

- **Java基础**：熟悉Java的基本语法、关键字和基本类型，掌握面向对象的概念、异常处理、集合框架等。
- **JVM知识**：理解JVM的内存模型、垃圾回收机制和性能调优。
- **数据结构和算法**：掌握常见的数据结构和算法，包括链表、树、图、排序和搜索算法，能够手写常见算法题。
- **数据库和SQL**：了解MySQL的基础知识，包括索引的使用、查询优化、事务和锁。
- **系统设计**：了解基本的系统设计概念，包括负载均衡、缓存策略、数据库分库分表等。
- **网络知识**：熟悉网络协议，如HTTP、TCP/IP，理解RESTful API设计原则。

### 3. 自我介绍

- **准备自我介绍**：清晰简洁地介绍自己的背景、技能和为什么对腾讯的职位感兴趣。
- **突出优势**：强调你的技术能力、解决问题的能力和任何与职位相关的专业经验。

### 4. 软技能

- **沟通能力**：展示你的沟通能力，如何有效地与团队合作，以及如何清晰地表达技术问题和解决方案。
- **学习能力**：展现你的快速学习和适应新技术的能力。

### 5. 面试态度

- **积极主动**：表现出你对技术的热情和对工作的认真态度。
- **准备反问问题**：准备一些问题来反问面试官，显示出你对腾讯和岗位的兴趣和研究。

### 6. 面试流程准备

- **模拟面试**：与朋友或同学进行模拟面试，以适应面试的环境和流程。
- **时间管理**：学会在面试中有效管理时间，尤其是在编写代码和解决问题时。

最近腾讯给的薪资特别高！大家加油啊！
![1714305000711.png](https://oss1.aistar.cool/elog-offer-now/9e9378bb1c05dd786c077eabb906ff5e.png)

# 面试经验
**面试官**: 你好，我是来自腾讯**部门的面试官。希望我们能有一个愉快的交流。 

**求职者**: 您好，面试官，我非常期待今天的面试，希望能展示我的技术能力。 

**面试官**: 很好。为了更好地了解你，你能先做一个自我介绍吗？ 

**求职者**: 当然可以。我是一个热爱后端开发的学生，主要技术栈是Java。在实习期间，我主要负责一些CRUD操作和项目部署。虽然我觉得我的项目经验还不够丰富，但我一直在努力提升自己，包括在业余时间刷力扣和背面经。 

**面试官**: 那么，**讲讲基本类型和引用类型有什么区别**？ 

**求职者**: 基本类型是存储简单数据值的类型，如int、double等，它们通常存储在栈上，直接包含值。引用类型则是存储到堆上的对象的引用，比如String、数组和其他对象。引用本身存储在栈上，而对象实际上存储在堆上。 

**面试官**: 对于对象的存储，**一个对象一定在堆里面吗？JVM是怎么分析的？**

**求职者**: 并不是所有对象都存储在堆中。JVM引入了逃逸分析的概念，来分析对象的作用域和生命周期。如果JVM通过逃逸分析确定一个对象不会逃逸出方法范围，并且没有其他线程访问它，那么这个对象可能会被分配在栈上。这样做可以提高内存分配效率，减少垃圾回收压力。 

**面试官**: 那就说说**Int和Integer的区别**，特别是在内存上。 

**求职者**: int是Java的基本类型，直接存储数值，而Integer是int的包装类，是一个对象。在JVM中，Integer对象除了存储数值外，还包含一些对象头信息，如标记字、哈希码等。**Integer**也利用了缓存池来优化小整数值的存储。 

**求职者**: 在JVM中，`ArrayList a`是在堆内存中创建的，而引用`a`存储在Main函数的栈帧中。当Function被调用时，引用`b`是传递给Function栈帧的`a`的副本，它们指向堆中同一个`ArrayList`对象。在Function中对`b`进行`add`操作实际上是在堆中的这个`ArrayList`对象上添加元素，这就是为什么Main函数中的`a`也能看到这个变化。

**面试官**: 如果Function中`b`被重新赋值为一个新的`ArrayList`，**那Main函数中的**`**a**`**会怎么样**？

**求职者**: 如果在Function中`b`被赋值为一个新的`ArrayList`对象，Main函数中的`a`不会受到影响。这是因为`b`的重新赋值只改变了Function栈帧中的引用，而不影响原来`a`引用的对象。所以，Main函数中的`a`仍然指向原来的`ArrayList`对象，包含先前添加的元素。

**面试官**: 那我们来聊聊**深浅拷贝**。你能解释一下它们的区别，并给我展示如何在代码中实现它们吗？

**求职者**: 浅拷贝只复制对象的引用，不复制对象本身，而深拷贝则是创建一个新的对象，并复制原对象的内容。在Java中，浅拷贝可以简单地通过赋值实现，或者使用`clone()`方法，如果只是复制集合的话，可以使用`new ArrayList<>(existingList)`。对于深拷贝，通常需要重写`clone()`方法并递归地复制所有可达的对象，或者使用序列化和反序列化的方法来实现。

```java
// 浅拷贝示例
ArrayList<Integer> a = new ArrayList<>();
ArrayList<Integer> shallowCopy = new ArrayList<>(a);

// 深拷贝示例
// 假设ArrayList中存储的是可克隆的对象
ArrayList<CloneableType> deepCopy = new ArrayList<>();
for (CloneableType item : a) {
    deepCopy.add(item.clone());
}
```

**面试官**: 现在，**让我们讨论一下反射**。你能告诉我你是怎么使用反射的，以及它有什么优缺点吗？

**求职者**: 反射主要用于在运行时检查或修改类和对象的属性。我使用过反射来动态地创建对象，调用方法，或者修改字段，尤其是在需要动态加载类或者在编译时不可知的情况下操作对象时。反射的优点是它非常灵活，可以增强程序的可扩展性和通用性。缺点是它会降低性能，因为它绕过了正常的方法调用机制，而且也降低了代码的可读性和安全性。

**面试官**: 那么，**为什么反射的效率比直接创建对象和调用方法低？**

**求职者**: 反射效率低的原因是因为它必须在运行时解析类或方法的元数据，查找方法或字段的名称，然后才能进行调用或访问。这个过程涉及到很多额外的步骤，比如加载类的定义信息，检查安全权限等，这些都是直接调用方法或直接访问字段时不需要的。

**面试官**: **在JVM上，直接构造对象和通过反射获取对象有哪些不同的过程？**

**求职者**: 当直接构造对象时，JVM会根据类的直接引用来定位类的元数据，然后在堆上分配内存，并执行构造函数。而通过反射获取对象时，JVM需要首先确定类的全名，然后加载类的Class对象，接着查找构造函数或方法，最后通过`newInstance()`或`invoke()`来创建对象和调用方法。这个过程更加复杂，涉及到更多的检查和间接的步骤，因此效率较低。

**面试官**: 好，**让我们接着聊聊垃圾回收。你提到了JVM的内存结构和回收算法，那JVM是怎么标记对象的？**

**求职者**: JVM中的垃圾回收主要使用可达性分析来标记对象。它从一组称为GC Roots的对象开始，这些对象包括被线程栈指针指向的对象、静态引用指向的对象和JNI引用等。然后，JVM通过这些根对象遍历所有可达的对象。在遍历过程中，每个遇到的对象都会被标记为活动的，这样，未被标记的对象就可以确定为垃圾，并在回收过程中被清除。

**面试官**: **在JVM上，这棵可达性分析的树是怎么构造出来的？**

**求职者**: 构造可达性分析树主要是通过对象的引用关系。JVM从GC Roots开始，检查它们的直接引用，然后是这些引用对象的引用，以此类推，形成了一棵引用树。这棵树的构造实际上是通过遍历对象图来完成的，对象图是由对象及其引用关系形成的网络结构。

**面试官**: 那么，**怎么知道一条链要不要回收，或者说，怎么确定这条链和根节点的关系呢**？

**求职者**: 一条链要不要回收，是通过检查它是否与GC Roots有连接来确定的。如果从GC Roots开始无法到达某个对象，那么这个对象就认为是不可达的，可以被回收。JVM在遍历过程中会使用一些算法和数据结构，如标志位和引用队列，来追踪和记录对象的可达性状态。

**面试官**: 很全面的回答。现在，**让我们转向MySQL索引**。你了解索引吗？

**求职者**: 是的，我对MySQL的索引有一定的了解。索引是帮助MySQL高效获取数据的数据结构。

**面试官**: **聚簇索引和非聚簇索引在叶子节点和非叶子节点上有什么区别？**

**求职者**: 在非聚簇索引中，叶子节点存储的是键值和指向行数据物理地址的指针。而非叶子节点则存储键值和指向子节点指针的索引条目。在聚簇索引中，叶子节点存储的是键值和完整的行数据，也就是说数据和索引是一起存储的。而非叶子节点和非聚簇索引的非叶子节点相似，存储的是键值和指向子节点的指针。

**面试官**: **数据的物理地址是什么？它是怎么得到的？**

**求职者**: 数据的物理地址指的是数据在存储介质上的实际存储位置。在InnoDB存储引擎中，这通常是指行数据在磁盘上的页内偏移量。物理地址是通过索引结构来获取的，当我们对一行数据进行索引时，索引条目会包含指向数据行的物理地址信息。

**面试官**: **那你能讲讲索引失效的场景吗？**

**求职者**: 索引失效可能发生在多种场景中，比如：

1. **使用了不等式运算符**：如果查询条件使用了`<>`或者`!=`，那么索引可能不会被使用，因为这些条件不是范围查询。
2. **在列上进行了函数操作**：如果对索引列使用了函数，比如`WHERE YEAR(date_column) = 2021`，那么索引也可能不会被使用。
3. **隐式数据类型转换**：如果列的数据类型与查询条件中的类型不一致，可能会导致索引失效。
4. **使用了OR条件**：如果OR条件中的每个列都有索引，但是没有一个复合索引来覆盖所有情况，那么索引可能也不会被使用。
5. **使用了LIKE模糊匹配**：对于以通配符开头的LIKE模式，比如`LIKE '%abc'`，索引不会被使用。

**面试官**: **在使用联合索引的场景下，有哪些因素会导致索引不被选用？**

**求职者**: 在使用联合索引时，如果查询条件没有按照索引列的顺序来使用，或者查询条件中省略了联合索引中的第一个列，那么索引可能不会被选用。此外，如果查询条件中包含了范围查询，那么范围查询之后的列在索引中也不会被使用。

**面试官**: **那么，在**`**WHERE gender = 'male'**`**的情况下，为什么引擎有时候不走性别字段上的二级索引呢？**

**求职者**: 这可能是因为性别字段的基数不高，即男性和女性的数量大致相同，这使得查询优化器认为使用索引来筛选性别可能不会比全表扫描更高效。在MySQL中，如果查询优化器认为使用索引的代价高于全表扫描的代价，它可能会选择不使用索引。

**面试官**: **那么，索引的选择代价是怎么计算的？**

**求职者**: 索引的选择代价是由查询优化器通过统计信息来计算的。它会考虑索引的基数、数据分布、索引页的IO成本等因素。查询优化器会将这些信息结合起来，估算出使用索引查询所需的IO操作数量，这就是索引选择的代价。

**面试官**: **除了代价估算，还有哪些因素可能影响索引的选择？**

**求职者**: 其他影响索引选择的因素可能包括索引的物理结构、查询中涉及的数据量、内存中索引的缓存情况、并发查询的影响以及服务器的配置等。

**面试官**: **对于**`**WHERE A*A < 10**`**这样的条件，为什么不走索引呢？**

**求职者**: 这是因为`A*A < 10`中的`A*A`实质上是一个计算表达式，它改变了列`A`原有的值。这种情况下，索引无法直接应用于计算后的结果，因为索引是基于列原始数据构建的。因此，优化器会选择不使用索引。

**面试官**: **如果有**`**WHERE A*A+B*B < C*C**`**这种条件，它走不走索引？**

**求职者**: 同样，这个条件中包含了多个列的计算表达式，优化器通常会认为这种复杂的计算不适合使用索引。因为索引是为了快速定位原始数据而设计的，而不是为了支持这种计算密集型的查询。

**面试官**: 很详细的解释，现在，**我们试试看看斐波那契数列的问题**。

**求职者**: 当然，斐波那契数列是一个经典的算法问题，它可以通过递归或动态规划来解决。如果要求第n个斐波那契数，一种简单的递归实现可能是这样的：

```java
public int fib(int n) {
    if (n <= 1) {
        return n;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}
```

但这个递归方法的效率是非常低的，因为它包含了大量的重复计算。一种更高效的方法是使用动态规划，我们可以从底向上计算斐波那契数，存储已计算的结果以避免重复计算：

```java
public int fib(int n) {
    if (n <= 1) {
        return n;
    }
    int[] fibCache = new int[n + 1];
    fibCache[1] = 1;
    for (int i = 2; i <= n; i++) {
        fibCache[i] = fibCache[i - 1] + fibCache[i - 2];
    }
    return fibCache[n];
}
```

这个动态规划版本的时间复杂度是O(n)，空间复杂度也是O(n)，但通过优化可以将空间复杂度降低到O(1)。

