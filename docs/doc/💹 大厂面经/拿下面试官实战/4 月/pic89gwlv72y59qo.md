---
title: 4/14 无offer，但有所得：美团技术中心面试心得分享
urlname: pic89gwlv72y59qo
date: '2024-06-13 21:14:40'
updated: '2024-06-13 21:14:48'
description: 最近关于美团平台增长技术和智能引擎部业务技术中心的面试话题在论坛上引起了不少讨论。有一位同学分享了他的面试经历，听说这个部门主要负责美团app打开后的推荐feed流后端。面试过程中，面试官在闲聊环节后，深入探讨了C++的智能指针和STL容器等技术实现。虽然最后没有拿到offer，但这位同学的经...
---
最近关于美团平台增长技术和智能引擎部业务技术中心的面试话题在论坛上引起了不少讨论。有一位同学分享了他的面试经历，听说这个部门主要负责美团app打开后的推荐feed流后端。面试过程中，面试官在闲聊环节后，深入探讨了C++的智能指针和STL容器等技术实现。**虽然最后没有拿到offer**，但这位同学的经历对很多准备面试的人来说都非常有参考价值。
【提醒】你将复习到以下知识点：

1. C++智能指针及其实现原理
2. 引用计数的工作机制
3. shared_ptr的使用场景和源码分析
4. STL deque的数据结构和迭代器实现
5. STL容器的线程安全性
6. Vector的resize操作对元素内存地址的影响
7. 不同编程语言（Golang, Java, C++）的对比
8. 提升编程水平的方法和途径

---

**面试官**: 你好，欢迎来到美团的技术面试。今天我们主要会聊一聊你对后端技术的理解。首先，可以给我介绍一下**C++智能指针**的概念吗？
**求职者**: 当然可以。C++智能指针是一种封装了原始指针的类，它能够帮助程序员避免内存泄漏。主要有三种类型的智能指针：**std::unique_ptr**、**std::shared_ptr**和**std::weak_ptr**。其中**std::shared_ptr**是一种引用计数的智能指针，它会跟踪有多少个shared_ptr实例指向同一个资源，当引用计数降到零时，它会自动释放该资源。
**面试官**: 那你能解释一下引用计数是如何实现的吗？
**求职者**: 引用计数通常是通过在shared_ptr中包含一个计数器来实现的。每次当一个新的shared_ptr实例被创建并指向同一个资源时，这个计数器就会增加。当一个shared_ptr被销毁或者被赋予新的资源时，计数器会减少。如果计数器的值变为零，说明没有任何shared_ptr实例指向这个资源了，资源就会被释放。
**面试官**: 很清楚。那在什么情况下引用计数会增加，又在什么情况下会减少？
**求职者**: 引用计数会在**复制shared_ptr**实例时增加，比如通过拷贝构造函数或者拷贝赋值操作。当一个shared_ptr实例离开其作用域或者被重新赋值时，引用计数会减少。
**面试官**: 你有没有看过std::shared_ptr的源码？能简单谈谈你的理解吗？
**求职者**: 看过一些。std::shared_ptr的源码实现了上述引用计数的逻辑，它通常有两个成员变量，一个是指向被管理资源的指针，另一个是指向控制块的指针。控制块中包含了引用计数器。除了管理资源和计数器，它还负责处理类型转换和自定义删除器等高级功能。
**面试官**: 接下来，说一下**STL deque的底层数据结构实现**和**deque的迭代器是怎么实现的**？
**求职者**: STL deque的底层是一个分段连续的存储空间，也就是说它由一系列固定大小的数组构成，这些数组的引用被存储在一个中央控制器中。这种实现让deque在前端和后端都能高效地插入或删除元素。至于迭代器，deque的迭代器是随机访问迭代器，它需要处理跨越多个分段数组的跳转，所以比vector的实现更复杂，但仍然可以提供类似数组的指针操作。
**面试官**: 好的解释。我们知道STL容器普遍不是线程安全的，你能介绍一下STL容器的线程安全性吗？
**求职者**: 是的，大多数STL容器都不是线程安全的。这意味着如果多个线程同时对同一个容器进行写操作，可能会导致数据损坏。如果需要在多线程环境中使用STL容器，我们必须使用额外的同步机制，比如互斥锁，来保证操作的原子性。
**面试官**: 了解了。那么对于Vector，**resize()函数**会改变之前已放入元素的内存地址吗？
**求职者**: vector的resize()函数可能会改变元素的内存地址。这是因为如果新的大小超过了当前的容量，vector需要分配一个更大的内存块来存储元素，然后把旧元素复制或移动到新的内存地址上。这个过程会改变已经放入元素的内存地址。
**面试官**: 明白了，现在让我们聊聊你的实习项目。能简单介绍一下你在实习中做的项目吗？
**求职者**: 在我的实习项目中，我负责开发了一个用于数据分析的内部工具。这个工具主要帮助团队对用户行为数据进行聚合和可视化，从而更好地理解用户的需求并优化产品功能。我使用Java语言完成了后端服务的编写，并且利用了Spring框架来简化开发流程。对于前端，我使用了React来构建用户界面，实现了一个交云互动的仪表板。
**面试官**: 听起来是个很有实用价值的项目。那么，你能对比一下**Golang, Java和C++**在开发效率和学习门槛方面的差别吗？
**求职者**: 当然。**Java**是一种比较成熟的语言，有大量的框架和库，这使得开发效率相对较高，而且它有严格的类型系统和垃圾回收机制，降低了学习门槛。**C++*_在性能方面有优势，但由于需要手动管理内存，学习门槛相对较高，开发效率也不如Java。至于__*_Golang**，它的语法简洁，学习门槛较低，内置的并发支持让开发并发程序变得简单，但是由于它的生态系统不如Java丰富，可能在一些方面会有些限制。
**面试官**: 那对于陌生的语言，你通常通过哪些途径来提高自己的编程水平？

**求职者**: 对于陌生的语言，我通常首先会通过阅读官方文档和一些基础的教程来建立起整体的理解。然后，我会通过在线课程或者教学视频深入学习。最重要的步骤是实践，我会通过编写一些小项目来应用我所学的知识。此外，我还会参与开源项目或者阅读一些高质量的代码库来学习最佳实践和高级技巧。

**面试官**: 很好，那我们继续。你对Golang了解多少？可以分享一下你的认识和使用经验吗？

**求职者**: 我对Golang有一定的了解和实践经验。Golang，也就是Go语言，是由Google开发的一种静态强类型、编译型语言，它具有语法简洁、并发支持良好、执行效率高等特点。Go语言的一个亮点是它的**并发模型**，它使用**goroutines**来实现并发，它们是由Go运行时管理的轻量级线程，通过**channels**进行通信，这使得编写并发程序变得非常简单和高效。

Go语言的**标准库**非常强大，提供了大量的工具和库来支持网络、并发、加密等多种功能。并且，Go语言的**垃圾收集**性能也越来越好，对于需要长时间运行的服务来说，这是非常有用的。
我在之前的项目中使用Go语言来开发了一些微服务，我发现使用Go语言可以使得服务的部署和维护变得更加容易。它的跨平台特性也为我们提供了很大的便利，我们可以很容易地为不同的操作系统构建程序。
**面试官**: 听起来你对Go有不少实践经验。既然提到了Go的并发模型，你能详细解释一下**goroutines**和**channels**的概念以及它们如何工作的吗？
**求职者**: 当然。**goroutines**是Go语言中实现并发的基本单位，它比线程更轻量，创建和销毁的成本更低，可以轻松创建成千上万个goroutines。在Go程序中，可以使用**go**关键字非常简单地启动一个goroutine来执行任何函数。goroutines之间是并发执行的，Go运行时会在物理线程上调度这些goroutines。
**Channels**是用于goroutines之间通信的一种机制。它们是一种类型安全的队列，可以使一个goroutine将值发送到另一个goroutine。使用channels，我们可以避免共享内存的并发问题，因为它提供了一种优雅的方式来传递数据。Channels可以是**阻塞**的或者**非阻塞**的，它们可以用于信号通知和数据传输。
**面试官**: 很好，你对Go的并发特性有清晰的理解。对于编程语言来说，性能总是一个被广泛讨论的话题。你认为Go语言在性能上有哪些优势？
**求职者**: Go语言在性能上有几个显著的优势。首先，它是静态编译型语言，编译后的程序可以直接在操作系统上运行，这使得执行效率较高。其次，Go语言的并发模型允许程序更好地利用多核处理器的能力，提高程序的执行效率。Go的运行时还包括一个现代化的垃圾收集器，它可以有效地管理内存，减少了程序的暂停时间。此外，Go语言的代码编译速度非常快，这可以加快开发和部署周期，从而间接提高性能。

**面试官**: 对于Go语言，有些人提到它的包管理系统。你能谈谈Go的包管理和依赖性管理吗？

**求职者**: Go语言最初使用GOPATH环境变量来管理包和项目的依赖关系，这在多项目开发中会造成一些问题。但自从Go 1.11版本引入了**模块**（Go Modules）后，包管理和依赖性管理得到了显著改进。Go Modules为每个项目提供了版本控制和包依赖管理，这使得项目依赖更加明确，也简化了不同环境下的构建过程。

使用Go Modules，你可以在项目的根目录下执行`go mod init`来初始化一个新的模块，这将创建一个`go.mod`文件，其中列出了项目的所有依赖项及其版本。当你导入一个包或者更新项目时，Go工具链会自动修改这个`go.mod`文件，也可以使用`go get`来更新依赖。此外，`go.sum`文件用于保证所依赖的模块不会被更改，增强了安全性。

**面试官**: 很详细。在实际的开发工作中，我们经常会进行代码测试。你能分享一下在Go中进行单元测试的方法吗？

**求职者**: Go语言在标准库中内置了测试工具，这使得编写和运行单元测试变得非常简单。你只需要在测试文件中导入`testing`包，然后编写以`Test`开头的函数，这些函数接受一个`*testing.T`类型的参数用于控制测试流程。

测试函数通常会创建一个或多个要测试的函数或方法的实例，并对其执行操作，然后使用`*testing.T`提供的方法，如`Error`或`Fail`，来报告测试失败的情况。Go提供了`go test`命令来自动发现和运行所有的测试，这些测试代码通常与源代码在相同的包中，但存放在以`_test.go`结尾的文件中。

例如，一个测试`Add`函数的代码可能看起来像这样：
```go
package math

import "testing"

func TestAdd(t *testing.T) {
    sum := Add(1, 2)
    if sum != 3 {
        t.Errorf("Add(1, 2) = %d; want 3", sum)
    }
}
```

**面试官**: 好的，你对Go语言的测试机制非常熟悉。那么，你有没有使用过Go的并行测试或者基准测试？

**求职者**: 是的，Go的测试框架也支持并行测试和基准测试。你可以在测试函数内部调用`*testing.T`的`Parallel`方法来标记该测试可以与其他测试并行运行。这在你有多个不相互依赖的测试并且想要充分利用系统资源时非常有用。

基准测试则用来测量代码的性能，它们是通过编写以`Benchmark`开头的函数来实现的，这些函数接受一个`*testing.B`类型的参数，用于控制基准测试的执行。Go提供了`go test -bench`命令来运行基准测试，这些测试通常会执行多次以收集平均执行时间等性能指标。

例如，一个基准测试可能看起来像这样：

```go
package math

import "testing"

func BenchmarkAdd(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Add(1, 2)
    }
}
```

**面试官**: 非常好。看来你对Go语言有相当深入的了解。今天的面试到这里就结束了。非常感谢你的分享，我们会尽快给你反馈。祝你好运！

**求职者**: 非常感谢您的面试机会，期待您的好消息。再见！

