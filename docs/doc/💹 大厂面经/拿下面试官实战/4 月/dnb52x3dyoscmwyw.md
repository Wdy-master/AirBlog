---
title: 4/12  美团技术部一面深度解析：后端开发岗位你能答对几题？
urlname: dnb52x3dyoscmwyw
date: '2024-06-13 21:14:40'
updated: '2024-06-13 21:14:48'
description: 好像和4/8 一样这里是一位同学在美团转正实习到店平台技术部的一面面试分享，面试题目涉及了Zookeeper、Kafka和MySQL等多个重点技术领域，面试官很和气，引导式的提问让整个面试过程充满学习和成长。现在我们就来一起回顾这些问题，并深入探讨其中的技术细节。【提醒】通过这次面试经验，你将...
---
> 好像和4/8 一样

这里是一位同学在美团转正实习到店平台技术部的一面面试分享，面试题目涉及了Zookeeper、Kafka和MySQL等多个重点技术领域，**面试官很和气，引导式的提问让整个面试过程充满学习和成长**。现在我们就来一起回顾这些问题，并深入探讨其中的技术细节。

【提醒】通过这次面试经验，你将可以复习到以下知识点：

1. Zookeeper与Kafka的基本概念和原理
2. Kafka的存储单元、消息索引和消费模式
3. Kafka的事务处理和数据一致性保证
4. Kafka性能优化技术：顺序写和零拷贝
5. MySQL的索引类型和区别
6. InnoDB与MyISAM的特点和区别
7. MySQL事务实现机制和锁策略



![](https://oss1.aistar.cool/elog-offer-now/53599936f96c8421c420da2ec2183891.jpeg)

**面试官**: 你好，欢迎参加美团的面试。我们今天有很多问题要讨论，首先来谈谈Zookeeper。你知道它的节点是如何持久化的吗？

**求职者**: 是的，Zookeeper中的节点有两种类型：持久节点和临时节点。**持久节点**一旦创建，就会一直存储在Zookeeper中，直到它被显式删除。这些节点的数据被存储在磁盘上，并且会在Zookeeper重新启动时恢复。

**面试官**: 对的，那Kafka的最小存储单元是什么？

**求职者**: Kafka的最小存储单元是**消息**。但在更宏观的层面上，我们通常会谈论**分区**，它是一组消息的集合，分区中的消息是有序的。

**面试官**: 那你能描述一下Kafka数据存储过程吗？

**求职者**: 当生产者发布消息到Kafka时，它首先会发送到一个特定的**主题（Topic）**和其中的一个分区。Kafka的**分区是追加日志文件**，新的消息会被追加到日志文件的末尾。每个消息在分区内都有一个唯一的偏移量。

**面试官**: Kafka的topic的每个分区是否独立？

**求职者**: 是的，每个Topic的分区是相互独立的。每个分区都有自己的日志文件，可以独立存储和服务消息。这种设计可以使Kafka实现高吞吐量和伸缩性。

**面试官**: 那如何根据索引找到消息？

**求职者**: Kafka为每个分区维护了一个索引文件，存储的是消息偏移量到文件位置的映射。当需要查找特定偏移量的消息时，Kafka会使用这个索引来快速定位消息在日志文件中的位置。

**面试官**: Kafka索引的键和值分别存储的是什么？

**求职者**: Kafka索引的**键**存储的是消息的偏移量，而**值**存储的是该偏移量对应的消息在日志文件中的物理位置。

**面试官**: Kafka的消费模式是怎样的？

**求职者**: Kafka采用的是**拉（Pull）模式**。消费者主动从服务器拉取消息，而不是等待服务器推送。

**面试官**: 那为什么要使用拉模式呢？

**求职者**: 使用拉模式可以让消费者更好地控制消息的消费速率和时间，避免了推模式可能引起的消息积压问题。拉模式也使得消费者可以根据自己的处理能力来消费消息，增加了系统的灵活性和稳定性。

**面试官**: 很好。消费者如何记录消费位置，存在哪里？ 

**求职者**: Kafka的消费者会记录它们的消费位置，称为**偏移量（offset）**。这些偏移量存储在一个特殊的Kafka主题中，称为__consumer_offsets。每当消费者读取了消息后，它会异步地提交这些偏移量，这样即使消费者发生故障也能从上次的位置继续消费。

 **面试官**: 在消费者组里面，每个消费者是独立的吗？ 

**求职者**: 在消费者组中，**每个消费者实例处理不同分区的消息是独立的**。但它们在消费相同主题的不同分区时是协作的，以此确保消费者组作为一个整体能够处理所有消息。 

**面试官**: 一个分区能被几个消费者（同一消费者组）消费，为什么？ 

**求职者**: 在同一消费者组中，**一个分区只能被一个消费者消费**。这是为了保证分区内消息的顺序消费，如果允许多个消费者并行消费同一分区，则可能违反这一顺序。 

**面试官**: 那Kafka为什么能顺序消费？ 

**求职者**: Kafka能够顺序消费的原因是它保证了每个分区内的消息是有序的，并且每次只有一个消费者消费该分区的消息。这样一来，消费者就能够按照消息被追加到日志的顺序逐一消费消息。

 **面试官**: Kafka支持事务吗？ 

**求职者**: 是的，从0.11版本开始，Kafka引入了事务支持。它允许生产者将消息的生产和消费封装成一个事务，要么全部成功，要么全部失败。 

**面试官**: Kafka能保证一致性吗，为什么？ 

**求职者**: Kafka可以通过**复制**和**事务日志**来保证一致性。每条消息都可以被复制到多个副本，当多数副本都保存了这条消息时，它才被认为是"提交"的。同时，事务日志确保了即使发生故障，事务的状态也能被正确恢复。 

**面试官**: 生产者生产消息到Kafka上是怎么写到磁盘上的？ 

**求职者**: 当生产者发送消息到Kafka时，消息首先会被写入到**操作系统的页缓存**中，然后Kafka会利用**顺序写**的高效率将数据从页缓存异步刷写到磁盘上。 

**面试官**: 如何保证消息不被重复消费？ 

**求职者**: Kafka通过消费者在消费消息后提交偏移量来保证消息不被重复消费。如果消费者因为某些原因重启，它会从最后提交的偏移量开始消费，从而避免重复消费之前的消息。 

**面试官**: Kafka数据存储基于磁盘还是内存？ 

**求职者**: Kafka的数据存储主要基于**磁盘**。这样做的主要原因是磁盘的顺序写性能非常高，而且比内存便宜很多，可以存储更多的数据。 

**面试官**: 那为什么Kafka的性能高呢？ 

**求职者**: Kafka的性能高是因为它针对磁盘操作进行了优化，特别是**顺序写**和**零拷贝（zero-copy）**技术。顺序写可以减少磁盘头的移动次数，而零拷贝技术可以减少CPU的数据复制操作，直接从磁盘传输数据到网络。 

**面试官**: 顺序写和非顺序写有什么区别？ 

**求职者**: 顺序写是指数据连续写入磁盘，通常在同一个区域，这样可以大大减少磁盘寻道时间。而非顺序写，或者称为随机写，是指数据被写入磁盘的随机位置，这会导致磁盘寻道时间增加，从而降低写入性能。 

**面试官**: 零拷贝是怎样的技术？ 

**求职者**: 零拷贝是操作系统的一种技术，它允许数据从磁盘被直接发送到网络接口，而不需要先复制到用户空间然后再复制到内核空间。这减少了CPU的负载和内存的使用，提高了数据传输的效率。 

**面试官**: 很好。现在让我们转向MySQL。你知道MySQL的索引有哪几种吗？ 

**求职者**: MySQL主要有以下几种索引类型：**B-Tree索引**，这是最常用的索引类型，适用于全键值、键值范围或键值排序查询；**哈希索引**，适用于等值查询；**FULLTEXT（全文索引）**，用于文本数据的全文搜索；还有**R-Tree索引**，主要用于空间数据查询。 

**面试官**: 那B+树和B树的区别是什么？ 

**求职者**: B树和B+树都是平衡多路查找树。在B树中，节点既存储键也存储数据，而且不同节点的子树之间不相连。相比之下，**B+树的叶子节点只存放数据，并且所有叶子节点之间按照键的顺序是相互链接的**，且非叶子节点不存储数据，只存储键，这让B+树更适合于数据库系统，因为它能够提供更好的读写性能和范围查询性能。

 **面试官**: 说到InnoDB和MyISAM，它们有什么区别？ 

**求职者**: InnoDB和MyISAM是MySQL最常用的两种存储引擎。**InnoDB支持事务**，具有提交、回滚和崩溃恢复能力的ACID特性。它使用B+树作为索引结构，支持外键，并默认使用行级锁。而MyISAM不支持事务，它更适用于只读数据或者表级锁定的场景，它的索引和数据是分开存储的，并且MyISAM表支持全文索引。 

**面试官**: 那B+树的叶子节点链表是单向还是双向，为什么？ 

**求职者**: **B+树的叶子节点链表是双向链表**。这样设计可以让叶子节点之间的遍历更加高效，不仅可以正向查询，也可以逆向查询，支持范围查询和快速的顺序访问。 

**面试官**: 叶子节点存储的数据是固定的吗？ 

**求职者**: 不是固定的。叶子节点可以根据数据的大小和B+树页面的大小来存储不同数量的数据。一般来说，一个叶子节点会存储尽可能多的数据来减少I/O操作。

 **面试官**: 那么，一个叶子节点能存多条数据吗？ 

**求职者**: 是的，**一个叶子节点可以存储多条数据记录**。B+树的设计目的之一就是要提高空间利用率，所以每个节点会尽量存储更多的数据。 

**面试官**: 里面的结构是怎样的？ 

**求职者**: 在B+树中，叶子节点包含了所有键值以及对应记录的指针。这些键值是有序的，叶子节点通过指针链接到下一个节点，这样可以高效地进行范围查询。非叶子节点则包含了键值和子节点指针，但不含记录的实际数据。 

**面试官**: 这些多条数据也会有索引吗？ 

**求职者**: 在B+树中，叶子节点的键值本身就是索引，它们指向实际的数据记录。 

**面试官**: MySQL支持哪些事务？ 

**求职者**: MySQL支持具有ACID属性的事务，特别是当使用InnoDB存储引擎时。ACID代表原子性、一致性、隔离性和持久性。 

**面试官**: 如何实现的事务？ 

**求职者**: MySQL中的事务是通过InnoDB存储引擎实现的。InnoDB使用**日志文件**和**锁机制**来保证事务的ACID属性。它有一个日志缓冲区和事务日志来支持事务的原子性和持久性，使用锁和MVCC（多版本并发控制）来实现隔离性。 

**面试官**: 为什么要有redo log？ 

**求职者**: Redo log是为了确保事务的**持久性**。在事务提交时，即使数据库发生故障导致数据丢失，redo log也能够用来恢复已提交的事务，因为它记录了事务所做的修改。 

**面试官**: undo log与redo log里面记录的是物理数据还是逻辑数据？ 

**求职者**: Redo log记录的是**物理数据**，即对磁盘页面的修改。Undo log记录的是**逻辑操作**，它用于在事务回滚时撤销已做的修改。 

**面试官**: MySQL锁一行有哪些方式？ 

**求职者**: 在MySQL中，可以使用**锁定读**，如SELECT ... FOR UPDATE或SELECT ... LOCK IN SHARE MODE，来锁定一行数据。InnoDB存储引擎也会在执行UPDATE、DELETE或INSERT操作时自动对涉及的数据行使用排他锁。 

**面试官**: 单纯的select对表加锁了吗？ 

**求职者**: 一般情况下，简单的SELECT操作不会对表加锁，它会使用快照读，基于MVCC机制避免读取时加锁。 

**面试官**: update，delete，insert会加锁吗，加什么锁？ 

**求职者**: 是的，UPDATE、DELETE和INSERT操作会对涉及的数据行加排他锁（X锁），这样其他事务就不能对这些行进行修改，直到当前事务完成。 

**面试官**: MySQL自增ID能回滚吗？ 

**求职者**: 自增ID即便在事务回滚后也不会回滚。这是因为自增ID是为了保证唯一性而设计的，就算事务失败，ID也不能重新使用。 

**面试官**: 最后来个算法题：删除最少的字母使字符串中不含最长偶数回文串。 

**求职者**: 这个问题可以通过动态规划解决。我们首先计算出字符串中所有偶数长度的回文子串，然后找出其中最长的那个。最后，我们移除掉构成这个回文子串的字符，确保剩下的字符串中不包含任何偶数长度的回文串。 

**面试官**: 好的，今天的面试就到此为止。如果有任何问题，可以随时与我们联系。谢谢你的参与，希望你能有下一轮面试的机会。 

**求职者**: 没有问题，感谢您的时间和反馈。 

**面试官**: 不客气，祝你好运。再见。 

**求职者**: 再见。 
