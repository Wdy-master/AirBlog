---
title: 4/29 中科大研二：字节实习半年的感悟和求职经验
urlname: yle9x1mig3opkp9m
date: '2024-06-13 21:14:39'
updated: '2024-06-13 21:14:46'
description: 'https://www.nowcoder.com/discuss在科技巨头字节跳动的实习经历无疑是一段难忘之旅。我有幸作为中科大软件学院研二学生，获得了这样的机会。实习的总时长超过半年，让我深刻体会到了字节跳动对实习生的重视与培养。在这里，我不仅技术能力得到了锤炼，更在mentor的指导下，解...'
---
> [https://www.nowcoder.com/discuss](https://www.nowcoder.com/discuss/614511697260212224)

在科技巨头字节跳动的实习经历无疑是一段难忘之旅。我有幸作为中科大软件学院研二学生，获得了这样的机会。实习的总时长超过半年，让我深刻体会到了字节跳动对实习生的重视与培养。

在这里，我不仅技术能力得到了锤炼，更在mentor的指导下，解决了一个又一个具有挑战性的问题。

如今，我想把这些珍贵的经验和大家共享，帮助那些正准备投身暑期实习的朋友们。

# 面试指南
## 自我介绍
这是给面试官的第一印象。建议提前准备一套自我介绍稿，有选择性地展示自己的优点和长处。
自我介绍也是一个展示你表达能力的机会。建议大家在招聘季需要密集面试的时候准备一份自我介绍稿，包含“学校-专业-所修课程-在校荣誉-竞赛奖项-实习经历-项目经历-社交经历”等内容。如果对某个项目或实习细节把握很好，可以在自我介绍中重点突出，以引导面试官后续提问。
## 基础知识与项目问答
熟悉计算机网络、操作系统、内存管理、数据结构、编程语言等基础知识是面试中的关键。

求职者必须对简历上的项目了如指掌，并能清晰阐述自己的角色和项目的优化改进。

建议参考公众号《二进制耳语#拿下面试官》系列等资源进行复习。遇到不熟悉的问题时，可以诚实地表达自己的理解和思考过程。
## 编程题
刷题是必不可少的准备工作。除了熟悉常见题目，还要适应不同的面试模式，包括leetcode模式和ACM模式。

编程题对许多同学来说可能是面试中的难点。

作为ACM竞赛选手出身的我，建议大家可以通过刷题来准备，例如在LeetCode上按照算法分类练习题目，刷完“Hot100”等题库。

同时要熟悉leetcode和ACM两种模式，准备头文件、输入输出等。在编程题环节，注意询问面试官题目的细节，清晰表述解题思路，并注意代码规范。
## 反问环节
面试的结尾通常是面试官询问是否有问题。

这是展现对岗位兴趣的机会，可以提问关于部门业务、未来工作内容、面试结果反馈时间等问题。

无论面试结果如何，保持礼貌并表达感谢。

# 实习感受

- **学习和成长**：字节跳动内部的ByteTech技术分享平台让我不仅能接触到我工作相关的知识内容，还能通过平台学习到其他团队的先进经验，从而拓宽我的技术视野。
- **团队文化**：字节跳动的团队文化尊重每个人的意见，为我提供了发展个人潜力的机会。我能够独立负责多个有挑战性的任务，从技术选型到发布，从代码实现到最终上线，使我获得了巨大的成就感。
- **个人发展**：字节跳动提供的培训和发展计划帮助实习生们一步步成长。我有机会与同伴们交流技术，参加健身和兴趣小组，这些都为我的个人发展提供了有力支持。
- **社交与协作**：与同事的交流与合作不仅提高了我的技术能力，也锻炼了我的团队协作和解决问题的能力。

最后，我想对每位有志于加入字节跳动的同学说，勇敢地迈出这一步，和优秀的人一起做有挑战的事情，祝你们面试顺利，**offer连连**！
# 面经分享
**面试官**: 欢迎参面试。我会问你一些问题，我们就从基础知识开始吧。告诉我，你对**最终一致性**有什么了解？

**求职者**: **最终一致性**是分布式系统中一种弱一致性的形式，它不保证系统的所有副本在同一时间具有相同的数据，但承诺在没有新的更新操作后，数据会最终达到一致的状态。

**面试官**: 不错。那么，能否简要介绍一下数据库的**几个范式**？

**求职者**: 数据库的范式主要包括第一范式（1NF）、第二范式（2NF）、第三范式（3NF）和BCNF。**1NF**要求字段具有原子性；**2NF**要求表要有主键，非主键字段必须完全依赖于主键；**3NF**要求非主键字段必须直接依赖于主键，不能存在传递依赖；而**BCNF**是在3NF的基础上，即使是候选键也必须满足依赖。

**面试官**: 视图在数据库中扮演什么角色？你怎么理解它的？

**求职者**: 视图是基于SQL语句的结果集的可视化表现。它像一个窗口，提供了查看数据的一种方式。视图可以简化复杂的SQL查询，增强数据的安全性，并且可以展现数据的部分内容而不暴露全部细节。

**面试官**: SQL关键字执行顺序是怎样的？

**求职者**: SQL关键字的执行顺序是：**FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY**。首先是指定数据源的FROM，接着是筛选条件的WHERE，然后是分组的GROUP BY，接着是分组后筛选的HAVING，然后是查询的SELECT，最后是排序的ORDER BY。

**面试官**: 那么Java连接数据库通常需要哪些步骤？

**求职者**: 在Java中连接数据库，通常需要以下步骤：**加载数据库驱动**、**建立连接**、**创建语句对象**、**执行SQL语句**、**处理结果集**和**关闭连接**。

**面试官**: 转到数据结构，你能说一下几种常见的**排序算法的时间复杂度**吗？

**求职者**: 当然。例如，**冒泡排序、选择排序和插入排序**的时间复杂度都是O(n^2)；**快速排序、归并排序和堆排序**的时间复杂度通常是O(n log n)；而**计数排序、基数排序和桶排序**的时间复杂度则取决于数据的特点，理论上可以达到O(n)。

**面试官**: 什么是**稳定的排序算法**？

**求职者**: 稳定的排序算法指的是在排序过程中，相等的元素的相对顺序不会改变。例如，归并排序就是稳定的排序算法，而快速排序则不是。

**面试官**: 你对**哈希表**这种数据结构熟悉吗？

**求职者**: 是的，**哈希表**是一种通过哈希函数来计算数据存储位置的数据结构，它支持高效的插入、删除和查找操作。但是，哈希表可能会遇到哈希冲突问题，通常可以通过链表或开放寻址方法来解决。

**面试官**: 那你能给我解释一下**红黑树的定义**吗？

**求职者**: **红黑树**是一种自平衡二叉查找树，它有以下特性：每个节点是红色或黑色的；根节点是黑色的；每个叶子节点（NIL节点，空节点）是黑色的；如果一个节点是红色的，则它的子节点必须是黑色的；从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

**面试官**: 谈谈**TCP三次握手和四次挥手的过程**吧。

**求职者**: TCP三次握手包括：第一次，客户端发送SYN包到服务器，并进入SYN_SEND状态；第二次，服务器收到SYN包，回复一个SYN+ACK包，进入SYN_RECV状态；第三次，客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK，然后双方进入ESTABLISHED状态。至于四次挥手，则是断开连接的过程，包括FIN和ACK的交换，确保数据完全传输完成。

**面试官**: 那三次握手的序号消耗情况是怎样的？

**求职者**: 在TCP三次握手中，初始序号是随机的。第一次握手消耗一个序号，第二次握手ACK确认回复的序号是接收到的序号加一，然后客户端与服务器的序号各自增加。

**面试官**: 你知道HTTP状态码**302**代表什么吗？

**求职者**: 是的，HTTP状态码**302**表示**临时重定向**，告诉客户端资源临时移动到了新的URL，客户端应该跟随这个新的URL获取资源。

**面试官**: Ping命令的原理是什么？

**求职者**: Ping命令的原理是利用ICMP协议发送一个回显请求消息到目标主机，并等待目标主机返回一个回显应答。它通常用于测试网络连接的质量。

**面试官**: 使用**C++如何建立socket连接**？需要哪些参数和步骤？

**求职者**: 在C++中，建立socket连接需要使用`socket`、`bind`、`listen`和`accept`函数。首先，我们需要创建一个socket，然后用bind函数将其绑定到一个地址上，之后使用listen函数开始监听端口。最后，当客户端请求连接时，使用accept函数来接受连接。

**面试官**: 谈谈**Linux中的进程和线程**。

**求职者**: 在Linux中，**进程**是程序的执行实例，是系统进行资源分配和调度的基本单位；而**线程**是进程中的执行流，是CPU调度的基本单位。线程相比进程更轻量级，共享进程资源，切换开销小。

**面试官**: 如何**创建线程**？如何**同步线程**？

**求职者**: 在Linux中，可以使用`pthread_create()`函数来创建线程。线程同步通常使用互斥锁（mutex）、条件变量、读写锁等机制来实现。互斥锁可以保证同一时间只有一个线程访问特定的资源。

**面试官**: **死锁**是如何产生的？你能写一个**死锁的代码**吗？

**求职者**: 死锁通常发生在多个线程因相互等待对方持有的锁而无法继续执行时。我可以写一个死锁的例子：

```java
public class DeadLockDemo {
    private static Object lock1 = new Object();
    private static Object lock2 = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (lock1) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock2) {
                    System.out.println("Thread 1 has both locks");
                }
            }
        }).start();

        new Thread(() -> {
            synchronized (lock2) {
                synchronized (lock1) {
                    System.out.println("Thread 2 has both locks");
                }
            }
        }).start();
    }
}
```

**面试官**: 在程序运行时，什么情况下会导致从**用户态切换到内核态**？

**求职者**: 当程序执行系统调用如读写文件、网络通信等操作时，需要切换到内核态，因为这些操作涉及到操作系统核心的资源管理。另外，硬件中断也会导致从用户态切换到内核态。

**面试官**: 你对这些概念理解得很清晰。现在让我们深入一点，你能详细解释一下**TCP的流量控制**和**拥塞控制**吗？ 

**求职者**: 当然。**TCP的流量控制**是通过滑动窗口机制来实现的，确保发送方不会发送超过接收方缓冲区能处理的数据量。而**拥塞控制**则是为了避免过多的数据注入到网络中，导致网络拥塞。TCP使用一系列算法，比如慢启动、拥塞避免、快速重传和快速恢复来实现拥塞控制。

**面试官**: 说得好。那你能给我讲讲**CAP定理**吗？在实际系统设计中，我们如何权衡这三个要素？ 

**求职者**: **CAP定理**提出，在分布式系统中，Consistency（一致性）、Availability（可用性）和Partition tolerance（分区容错性）三者不可兼得。在实际系统设计中，根据业务需求的不同，我们可能需要在一致性和可用性之间做出权衡。例如，如果系统更注重用户体验，则可能优先保证可用性；而如果系统需要严格的数据一致性，则可能会牺牲一些可用性。 

**面试官**: 很好的解释。对于**数据库系统**，如果要设计一个可以承受高并发的系统，你会如何设计？ 

**求职者**: 设计一个可以承受高并发的数据库系统，我会考虑使用分布式数据库，以及读写分离的架构来提高系统的扩展性和并发处理能力。此外，我还会利用缓存技术来减轻数据库的压力，以及使用负载均衡器来分散请求。 

**面试官**: 那么最后一个问题，你能谈谈在**云计算环境**下，如何保证数据的**弹性和可扩展性**吗？ 

**求职者**: 在云计算环境下保证数据的弹性和可扩展性，关键在于使用自动扩展的服务，如AWS的Auto Scaling和数据库服务如Amazon RDS。这些服务可以根据负载的变化自动调整资源。此外，使用无服务器架构如AWS Lambda也可以提高弹性和可扩展性，因为它允许你运行代码而无需管理服务器。 

**面试官**: 我们会对你的面试表现进行评估，如果有后续的进展，我们会与你联系。祝你今天过得愉快，并祝你好运！ 
