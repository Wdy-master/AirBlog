---
title: 3/29 打穿！得物青训营Golang面试全记录！
urlname: hknd17h7i6hsgxwg
date: '2024-06-13 21:14:41'
updated: '2024-06-13 21:14:49'
description: 'https://www.nowcoder.com/?type=818_1下面我将分享一位同学在得物青训营的面试经历，对于这次面试，他的评价是，很有难度，你试试呢？【提醒】通过这次面试经验，你将可以复习到以下知识点，注意汇总，不超过10个快排算法动态规划的概念面向对象的理解Golang的调度模型...'
---
> [https://www.nowcoder.com/?type=818_1](https://www.nowcoder.com/?type=818_1)

下面我将分享一位同学在得物青训营的面试经历，对于这次面试，他的评价是，很有难度，你试试呢？

【提醒】通过这次面试经验，你将可以复习到以下知识点，注意汇总，不超过10个

1. 快排算法
2. 动态规划的概念
3. 面向对象的理解
4. Golang的调度模型GMP
5. 并发安全问题和读写锁
6. 分布式锁设计
7. Redis的使用和常见问题
8. 链表和哈希的应用场景
9. Innodb B+树的描述和索引覆盖
10. Kafka的使用和概念理解
11. Docker的基本知识和与虚拟机的区别
12. 接口的幂等性解决方案
13. Git的使用

**面试官**: 你好，首先请做一个自我介绍。

**求职者**: 你好，我叫...，我在...大学学习计算机科学，我熟悉Golang编程...

**面试官**: 很好，那你能简要描述一下快速排序算法吗？

**求职者**: 当然可以。快速排序是一种分治的排序算法。它首先选择一个'基准'元素，然后将所有比基准小的元素移动到基准的左边，所有比基准大的元素移动到基准的右边。然后，对左边和右边的两个子数组递归地进行快速排序。由于每次都能确定一个元素的最终位置，所以它的平均时间复杂度是O(nlogn)。

**面试官**: 非常好。那你能告诉我动态规划是什么意思吗？

**求职者**: 动态规划是一种用于求解最优化问题的数学方法。它的基本思想是将一个复杂的问题分解成一系列简单的子问题，每个子问题只解决一次，然后将其结果存储起来，以便下次需要同样的结果时，可以直接查找，不用重新计算。这种方法是以空间换取时间。

**面试官**: 非常详细的解答，谢谢你。现在，我们来谈谈面向对象编程，你怎么理解它？

**求职者**: 面向对象编程是一种程序设计范式，它使用“对象”作为基本的构建块。在面向对象编程中，对象是包含数据和操作数据的方法的实体。这种设计范式提供了一种将复杂问题简化为易于理解和操作的对象的方式。面向对象编程的主要特点包括封装、继承和多态。

**面试官**: 很好。接下来，我想问你关于Golang的调度模型，GMP是什么？

**求职者**: GMP是Golang的运行时调度模型中的三个主要组成部分，G表示Goroutine，M表示Machine，P表示Processor。在Go中，每一个Goroutine都会在M上运行，而P则代表了可以执行Goroutine的资源。

**面试官**: 那么，在使用goroutine的时候，并发安全问题有哪些？

**求职者**: 在使用goroutine进行并发编程时，如果多个goroutine同时操作同一份数据，可能会出现竞态条件，这就需要我们注意并发安全问题。为了解决这个问题，Go提供了一些同步原语，比如sync包中的互斥锁（Mutex）和读写锁（RWMutex），以及channel等机制来保证并发安全。

**面试官**: 那你能解释一下读写锁的概念吗？

**求职者**: 读写锁是一种特殊类型的锁，它分为读锁和写锁。当一个goroutine获取读锁后，其他的goroutine如果是读操作，也可以获取到读锁，但是如果要进行写操作，就必须等待读锁释放。相反，如果一个goroutine获取了写锁，其他的无论是读操作还是写操作，都必须等待写锁释放。读写锁适用于读多写少的场景，可以提高系统的并发性能。

**面试官**: 接下来，我们来谈谈消息队列，在什么场景下会使用到？ 

**求职者**: 消息队列通常用于处理异步任务，比如用户发送一个请求后，服务器接收请求，将任务放入消息队列，然后立即返回，这样就不会阻塞用户的请求。此外，消息队列也可以作为系统解耦的工具，使得系统的各个部分可以独立地扩展和维护。还可以用于流量削峰，当请求量突然增大时，通过消息队列可以缓冲部分请求，保证系统的稳定性。 

**面试官**: 非常好。那你能解释一下Kafka中的broker、topic partition和consumer的概念吗？ 

**求职者**: Kafka是一个分布式的、可分区的、可复制的消息系统。在Kafka中，broker是一个独立的Kafka服务器，负责消息的接收和发送。Topic是Kafka中数据的主题，可以理解为一个分类或者是队列名字。Partition是topic的分区，每一个topic可以分为多个partition，每个partition是有序的。Consumer则是消费者，负责从Kafka中读取数据。 

**面试官**: 那么，如果有三台broker，五个consumer，那么在这个场景下，你认为应该设置一个topic里面的partition设置多少个比较合理呢？ 

**求职者**: 这个问题没有一个固定的答案，它取决于实际的需求和环境。一般来说，partition的数量应该比consumer的数量多，这样可以使得每个consumer都有数据可读，提高并发性能。另一方面，partition的数量也不应该过多，因为每个partition都会带来一些额外的开销。 

**面试官**: 非常好，那么在consumer进行扩容的时候，会发生什么？ 

**求职者**: 当consumer扩容的时候，Kafka会重新分配partition到新的consumer上。这个过程叫做rebalance。在rebalance过程中，所有的consumer都会停止读取数据，等待rebalance完成。所以，虽然扩容可以提高并发性能，但是也会带来一些额外的开销。 

**面试官**: 很好。现在我们来谈谈Docker和虚拟机，你认为它们有哪些区别？ 

**求职者**: Docker和虚拟机都是用于实现应用隔离和部署的工具，但是它们的工作方式和性能特性有很大的不同。虚拟机通过模拟硬件来运行操作系统，每个虚拟机都有自己的完整操作系统，这使得虚拟机有很好的隔离性，但是也带来了较大的资源开销。相比之下，Docker是基于Linux的容器技术，它直接运行在宿主机的操作系统上，每个容器共享同一个操作系统，但是在文件系统和网络等方面是隔离的。这使得Docker在性能上接近原生的应用，同时又具有一定的隔离性。 

**面试官**: 那么，你能说说**Docker的三大基座是什么吗？ **

**求职者**: 当然。Docker的三大基座，即**镜像（Image）、容器（Container）和仓库（Repository）**，它们共同构成了Docker的核心功能。镜像是一个只读的模板，包含了运行应用所需的代码、库、环境变量和配置文件。容器是镜像的运行实例，可以被启动、开始、停止和删除。每个容器都是隔离的、安全的，并且包含了全部运行某个应用所需的环境。仓库是镜像的集合，它可以是公共的或者私有的，用户可以上传或者下载镜像。

**面试官: **好的，这次面试到此为止。你的表现非常出色，我们会尽快给你反馈。感谢你今天的参与。
