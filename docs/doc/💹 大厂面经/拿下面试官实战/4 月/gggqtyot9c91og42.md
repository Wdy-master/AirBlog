---
title: 4/13 腾讯一面：HTTP和HTTPS我终于搞明白了！
urlname: gggqtyot9c91og42
date: '2024-06-13 21:14:40'
updated: '2024-06-13 21:14:48'
cover: 'https://cdn.nlark.com/yuque/0/2024/jpeg/22382235/1713276096800-adda1632-d5ca-4010-a317-16929ddd5f12.jpeg'
description: 嘿，今天我们来看看一位同学在腾讯音乐的面试经历。面试的内容涵盖了项目难点、Redis锁、进程通信方式、进程与线程的区别、CPU使用率查看方法、空文件创建、抓包工具、HTTP与HTTPS的区别等多个方面，真是内容丰富，挑战性十足啊。特别是在算法部分，面试官从堆排序切换到快排，可见面试的灵活性。对...
---
嘿，今天我们来看看一位同学在腾讯音乐的面试经历。面试的内容涵盖了项目难点、Redis锁、进程通信方式、进程与线程的区别、CPU使用率查看方法、空文件创建、抓包工具、HTTP与HTTPS的区别等多个方面，真是内容丰富，挑战性十足啊。特别是在算法部分，面试官从堆排序切换到快排，可见面试的灵活性。对于每一位求职者来说，这样的面试经历无疑是一次宝贵的学习与成长机会。接下来，让我们一起深入探讨一下这场面试中提到的几个关键技术问题，看看我们能从中学到什么。
【提醒】你将复习到以下知识点：

- 进程与线程的区别
- Redis锁的实现方式
- TCP通信机制及其四次握手过程
- HTTP与HTTPS的区别及其安全性
- Redis的数据类型及持久化方式
- MySQL索引类型和防范SQL注入攻击的方法

![](https://oss1.aistar.cool/elog-offer-now/f85771cc805611703ffbafa235d63566.jpeg)
**面试官**: 嗨，欢迎参加腾讯音乐的面试。我看你的简历上有提到一些项目经验，能简单谈谈你在项目中遇到的难点以及你是怎么解决的吗？
**求职者**: 当然可以，我之前负责了一个...
**面试官**: 好的，听起来你解决问题的能力很不错。那我们接下来聊一聊**Redis锁**。你知道Redis锁有几种实现方式吗？
**求职者**: 嗯，Redis锁主要有两种实现方式，一种是通过**SETNX**命令实现的**互斥锁**，另一种是使用**RedLock算法**实现的**分布式锁**。
**面试官**: 很好，你能详细解释一下SETNX命令如何用于实现锁吗？
**求职者**: 当然。SETNX是set if not exists的缩写，在使用时，我们可以通过SETNX命令给一个key设置一个value，如果这个key不存在，那么命令会执行成功，并返回1，表示设置了这个锁。如果这个key已经存在，命令执行失败，返回0，表示获取锁失败。
**面试官**: 非常详细。那在检查锁的过程中，这个操作是原子的吗？
**求职者**: 是的，SETNX命令的操作是原子的。它保证了在设置值的同时检查值是否存在，避免了在多个客户端之间出现竞争条件。
**面试官**: 明白了。接下来，让我们聊聊进程通信。你能说说进程间通信的几种方式吗？
**求职者**: 进程间通信主要有几种方式，包括**管道(pipe)*_、*_信号(signal)*_、*_共享内存**、**消息队列**、**信号量**以及**套接字(socket)**。
**面试官**: 很好。那你能说说**进程和线程的主要区别**吗？
**求职者**: 当然。**进程是操作系统进行资源分配和调度的基本单位**，每个进程都有独立的地址空间，一个进程崩溃后，在保护模式下不会影响到其他进程，是完全独立的。而**线程是进程中执行运算的最小单位**，它被包含在进程之中，是进程中的实际运作单位。线程共享其所属进程的地址空间和资源，但是每个线程有自己的调度堆栈。
**面试官**: 赞，解释得很清楚。那你知道如何查看一个进程的CPU使用率吗？
**求职者**: 是的，我可以通过在Linux系统中使用**top**命令来查看进程的CPU使用率。在Windows系统中，我可以通过任务管理器来查看。
**面试官**: 对，这两个工具都很实用。接下来，请问你知道怎么在Linux系统下创建一个空文件吗？
**求职者**: 嗯，虽然我不太熟悉Linux，但我知道可以使用**touch**命令来创建一个空文件，比如touch filename。
**面试官**: 没错。那如果是在Windows系统下呢？
**求职者**: 在Windows系统下，我可以在命令提示符下使用type nul > filename来创建一个空文件。
**面试官**: 很好。那平时你用什么工具来抓包分析网络问题？
**求职者**: 我通常使用**Wireshark**来抓包。它是一个网络协议分析工具，可以捕获网络中传输的数据包，非常有助于网络问题的分析和调试。
**面试官**: Wireshark确实是个强大的工具。那你能解释一下HTTP和HTTPS有什么区别吗？
**求职者**: 当然。**HTTP是超文本传输协议**，它是一个无状态的、明文传输的协议。而**HTTPS则是HTTP的安全版**，它在HTTP的基础上通过SSL或TLS提供了数据加密、完整性保护和身份验证，确保了数据传输的安全性。
**面试官**: 对，HTTPS的引入大大增加了网络传输的安全性。那HTTPS的安全性体现在哪里呢？
**求职者**: HTTPS的安全性主要体现在三个方面：**加密**、**数据完整性**和**身份验证**。加密确保了数据传输过程中的隐私，数据完整性保护了数据不被篡改，身份验证则确保了通信双方的真实性。
**面试官**: 非常精准的总结。HTTP2.0和HTTP1.0相比有哪些改进呢？
**求职者**: HTTP2.0相比于HTTP1.0主要有以下几个方面的改进：**二进制分帧**、**多路复用**、**头部压缩**、**服务器推送**。这些改进有效地减少了延迟，提高了网页的加载速度和效率。
**面试官**: 很好，你对这些协议的理解非常到位。接下来，TCP的四次挥手为什么是四次，而不是三次呢？
**求职者**: TCP的四次挥手是因为当一方想要关闭连接时，它发送一个FIN消息。这时候对方知道了这一方没有数据发送了，但是可能仍有数据要发送给这一方，所以它只能回复一个ACK，表示确认收到了关闭请求，但还没准备好关闭连接。只有在另一方也没有数据要发送，并且准备好关闭连接时，它才发送自己的FIN消息。这时候第一方回复一个ACK，完成连接的关闭。因此，需要四次挥手来确保双方都能够安全地关闭连接。
**面试官**: 对，你说得很清楚。现在咱们继续，**TCP是如何保证数据传输的安全性的**？
**求职者**: TCP保证数据传输的安全主要是通过**校验和**、**序列号**、**确认应答**以及**重传机制**来实现的。校验和可以检测数据在传输过程中的任何变化；序列号和确认应答机制确保了数据包的正确排序和确认；而重传机制则确保了在数据传输过程中丢失的包能够被重新发送。
**面试官**: 非常好，你对TCP的工作机制掌握得很扎实。那么，**TCP半连接队列是什么状态**？
**求职者**: TCP半连接队列，也就是**SYN队列**，是指存储那些已发送了SYN包但是还没有收到ACK包的连接请求的队列。这是TCP三次握手过程中的一部分，当一个SYN包到达时，TCP协议会将这个包放入SYN队列中，然后发送一个SYN+ACK包给请求方，等待其回复ACK。
**面试官**: 很好，这个解释非常准确。现在来谈谈Redis。Redis的部署方式都有哪些，它们各自有什么优缺点？
**求职者**: Redis主要有三种部署方式：**单机模式**、**主从复制模式**和**集群模式**。单机模式简单易部署，但不具备高可用性和扩展性；主从复制模式通过复制可以提高数据的可靠性和读取性能，但写入性能受限于单个主节点；集群模式通过分片提高了扩展性和高可用性，但配置和管理相对复杂。
**面试官**: 很全面的回答。那么，在主从复制中，有什么缺点？
**求职者**: 主从复制的一个缺点是，如果主节点发生故障，虽然可以通过选举产生新的主节点，但是在故障转移的过程中会有短暂的不可用或数据不一致的情况。此外，所有写入操作都必须经过主节点，这可能成为系统的瓶颈。
**面试官**: 是的，这些是需要考虑的问题。在谈到Redis，我们不得不提的是**脑裂问题**。你能解释一下Redis的脑裂问题吗？
**求职者**: 脑裂问题发生在Redis集群中，当网络分区故障导致集群中的一部分节点无法与另一部分节点通信时，集群可能会出现多个主节点被同时选举出来，这样就会造成数据不一致的问题。
**面试官**: 了解到脑裂的情况非常好。那在Redis中，**数据类型**有哪些？
**求职者**: Redis支持多种数据类型，包括**字符串(String)*_、__*_哈希(Hash)*_、__*_列表(List)*_、__*_集合(Set)*_、__*_有序集合(ZSet)*_还有__*_位图(Bitmap)*_和__*_HyperLogLog**等。
**面试官**: 正确。那你知道**ZSet的底层数据结构**是什么吗？
**求职者**: 是的，ZSet的底层数据结构是**跳跃列表(Skip List)*_和__*_哈希表**。跳跃列表用于保持元素的排序，而哈希表则用于保持成员到分数的映射。
**面试官**: 很好，你对Redis的数据结构也很熟悉。接下来，**什么情况下会使用压缩列表**呢？
**求职者**: 压缩列表是一种为了节省空间而设计的紧凑数据结构，它在**列表、哈希和有序集合等数据类型的元素个数较少且元素大小较小**时会被使用。
**面试官**: 对，这是为了优化空间效率的设计。现在，让我们来聊聊**Redis的数据持久化方式**。Redis有哪些数据持久化的方式呢？
**求职者**: Redis的数据持久化主要有两种方式：**RDB(Redis DataBase)**和**AOF(Append Only File)**。RDB是在指定的时间间隔内生成数据集的快照，而AOF则是记录每次对服务器写的操作。
**面试官**: 那么，**AOF和RDB持久化有何区别**？
**求职者**: AOF持久化可以提供更强的数据安全性，因为它记录了所有写操作的日志，可以在Redis崩溃后重建数据集，但是文件体积可能会很大且恢复速度较慢。RDB持久化则是通过保存某个时间点的数据快照来实现的，它的恢复速度快，但是在发生故障时可能会丢失最后一次快照之后的所有数据。
**面试官**: 说得不错。那你知道**Redis 6.0引入的多线程**主要用在了什么地方吗？
**求职者**: Redis 6.0引入的多线程主要用于提高I/O操作的速度。具体来说，是在执行网络输入输出，比如读请求和发送响应时，使用多线程来提高效率，而不是数据操作本身。
**面试官**: 没错。既然提到了Redis的锁，那我们就来更深入一点。除了redission这种分布式锁，你知道还有哪些**其他实现方式**吗？
**求职者**: 除了Redission分布式锁，我们还可以用**基于数据库的乐观锁**或**悲观锁**，或者是**用ZooKeeper实现的分布式锁**。
**面试官**: 很好，多种锁的了解对于解决并发问题很有帮助。那现在我们换个话题，谈谈数据库。**MySQL有几种索引？**
**求职者**: MySQL主要有两种索引，**B-Tree索引**和**哈希索引**。B-Tree索引是最常见的索引类型，适用于全键值、键值范围或键值前缀查找。而哈希索引则适用于等值查询，它能提供更快的查询响应速度。
**面试官**: 对，了解索引类型很重要。那**如何防范SQL注入攻击呢**？
**求职者**: 防范SQL注入的关键是防止用户输入的数据直接用于构造SQL语句。我们可以通过使用**预处理语句(prepared statements)*_和__*_参数化查询**来实现。这样，即使用户输入了恶意的SQL代码，它也只会被当作参数处理，而不会执行。此外，我们还应该限制应用程序数据库的权限，只授予必要的权限，并进行详尽的输入验证。
**面试官**: 很好，你提到的这些方法都是有效的防护措施。再来，你对**分布式系统里的CAP理论**了解吗？
**求职者**: 当然，分布式系统的CAP理论指的是在一个分布式系统中，**一致性(Consistency)**、**可用性(Availability)**和**分区容错性(Partition tolerance)**这三个特性不可能同时完全满足。根据CAP理论，我们可以根据不同场景的需求，选择强调其中两个特性。
**面试官**: 非常精辟的总结。现在，**常见的消息队列都有哪些**？
**求职者**: 目前市面上常见的消息队列有**RabbitMQ**、**Kafka**、**ActiveMQ**、**RocketMQ**等。它们在不同的实现细节、性能和可靠性方面各有特点。
**面试官**: 对，消息队列在处理大规模数据流、系统解耦合和负载均衡方面扮演着重要角色。那我们回到Redis，**Redis有几种锁**呢？
**求职者**: 在Redis中，我们通常使用**SETNX**命令实现**互斥锁**。我们也可以通过**RedLock**算法实现更复杂的**分布式锁**。此外，有些场景下，我们还可以利用**LIST**或**ZSET**实现轻量级的锁机制。
**面试官**: 很好。那**MySQL的表级锁有几种**，它们分别是什么？
**求职者**: MySQL的表级锁有两种，**表共享锁（Table Read Lock）**和**表独占锁（Table Write Lock）**。表共享锁允许多个读操作同时进行，但不允许写操作。表独占锁则在写操作进行时，不允许其他的读操作和写操作。
**面试官**: 对，了解这些锁的类型和它们的工作方式对于优化性能和并发控制至关重要。面试到这里，我们结束了。非常感谢你今天的分享，你的技术基础很扎实，思维清晰，期待你在团队中的表现，期待我们的合作！
**求职者**: 谢谢面试官，非常期待能与腾讯音乐团队合作，再见！
