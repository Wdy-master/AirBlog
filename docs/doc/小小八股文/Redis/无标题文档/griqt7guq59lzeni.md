---
title: 无标题文档
urlname: griqt7guq59lzeni
date: '2024-05-24 15:48:01'
updated: '2024-05-24 15:48:11'
description: 好的，我会继续详细回答问题，并在涉及原理和结构方面的内容时使用Mermaid语法进行可视化展示。六、Redis 过期删除与内存淘汰（续）17. Redis使用的过期删除策略是什么？回答：Redis使用两种过期删除策略：惰性删除（Lazy Deletion）：当访问一个键时，Redis检查其是否...
---
好的，我会继续详细回答问题，并在涉及原理和结构方面的内容时使用Mermaid语法进行可视化展示。

#### 六、Redis 过期删除与内存淘汰（续）

#### 17. **Redis使用的过期删除策略是什么？**

**回答**：
Redis使用两种过期删除策略：

- **惰性删除（Lazy Deletion）**：当访问一个键时，Redis检查其是否过期，如果过期则删除该键。惰性删除不会主动扫描所有键，只在访问时才检查，大大减少了CPU消耗。
- **定期删除（Periodic Deletion）**：Redis定期（默认每100ms）随机抽取一部分键，检查并删除过期的键。这种方式可以避免内存中充满过期键，但可能在某些情况下无法及时清理所有过期键。

使用Mermaid语法展示惰性删除和定期删除的流程：


#### 18. **Redis持久化时，对过期键会如何处理？**

**回答**：
Redis在持久化过程中对过期键的处理方式因持久化方式不同而有所区别。

-  **RDB持久化**： 
   - 在生成RDB快照时，Redis会检查所有键，如果发现某个键已经过期，则不会将其包含在快照中。这样可以确保RDB文件中没有过期的数据。
-  **AOF持久化**： 
   - 在AOF持久化过程中，过期键的删除操作会被记录在AOF文件中。当Redis重启并重放AOF文件时，这些删除操作会被执行，确保过期键不会存在于内存中。

使用Mermaid语法展示RDB和AOF持久化的过期键处理：


#### 19. **Redis主从模式中，对过期键会如何处理？**

**回答**：
在Redis的主从模式中，过期键的处理遵循以下原则：

-  **主节点（Master）**： 
   - 主节点负责管理所有键的过期状态。当一个键在主节点过期并被删除时，主节点会将删除操作同步到所有从节点。
-  **从节点（Slave）**： 
   - 从节点不会独立管理键的过期状态，而是由主节点通知它们删除过期键。
   - 这种设计确保了主从节点之间的一致性，避免了主从节点之间的冲突。

使用Mermaid语法展示主从模式中过期键的处理流程：


#### 20. **Redis内存满了，会发生什么？**

**回答**：
当Redis内存使用达到配置的最大内存限制（maxmemory）时，Redis会启用内存淘汰机制，根据配置的策略删除部分数据，以腾出空间存储新数据。如果没有配置内存淘汰策略，Redis会返回错误，指出内存不足，无法执行写操作。

#### 21. **Redis内存淘汰策略有哪些？**

**回答**：
Redis支持多种内存淘汰策略，可以根据不同的业务需求选择合适的策略：

- **noeviction**：当内存达到最大限制时，不再执行任何写操作，直接返回错误。
- **allkeys-lru**：使用LRU算法，从所有键中选择最近最少使用的键进行删除。
- **volatile-lru**：使用LRU算法，从设置了过期时间的键中选择最近最少使用的键进行删除。
- **allkeys-random**：从所有键中随机选择键进行删除。
- **volatile-random**：从设置了过期时间的键中随机选择键进行删除。
- **volatile-ttl**：从设置了过期时间的键中选择即将过期的键进行删除。

使用Mermaid语法展示内存淘汰策略：


#### 22. **LRU算法和LFU算法有什么区别？**

**回答**：
LRU（Least Recently Used）和LFU（Least Frequently Used）都是常见的缓存淘汰算法，但它们的策略不同：

-  **LRU算法**： 
   - LRU算法基于最近使用的时间，淘汰最久未使用的键。
   - 实现方式：使用链表或哈希表加双向链表，记录每个键的访问时间，每次访问键时将其移动到链表头部，淘汰时从链表尾部删除。
-  **LFU算法**： 
   - LFU算法基于使用频率，淘汰使用频率最低的键。
   - 实现方式：使用计数器记录每个键的访问次数，淘汰时选择访问次数最少的键。

使用Mermaid语法展示LRU和LFU算法的区别：


### 七、Redis 缓存设计

#### 23. **如何避免缓存雪崩、缓存击穿、缓存穿透？**

**回答**：

-  **缓存雪崩**： 
   - **原因**：大量缓存同时过期，导致大量请求直接打到数据库，造成数据库压力过大。
   - **解决方案**： 
      - 设置不同的缓存过期时间，错开缓存过期时间。
      - 在缓存过期前主动更新缓存，使用定时任务刷新缓存。
      - 使用锁机制，限制同时访问数据库的请求数量。
-  **缓存击穿**： 
   - **原因**：某些热点数据在缓存过期后，瞬间有大量请求访问，导致请求直接打到数据库。
   - **解决方案**： 
      - 热点数据设置为永不过期，并使用后台线程定时更新缓存。
      - 使用互斥锁或分布式锁，控制同时访问数据库的请求数量。
-  **缓存穿透**： 
   - **原因**：请求的数据在缓存和数据库中都不存在，导致请求直接打到数据库，可能被恶意利用进行攻击。
   - **解决方案**： 
      - 使用布隆过滤器，拦截非法请求。
      - 缓存空值，将不存在的数据缓存一段时间，防止频繁访问数据库。

使用Mermaid语法展示这三种情况及其解决方案：

