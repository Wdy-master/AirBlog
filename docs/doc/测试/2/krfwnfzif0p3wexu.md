---
title: "4"
urlname: krfwnfzif0p3wexu
date: "2024-05-13 20:36:23"
updated: "2024-05-16 22:17:48"
cover: "https://cdn.nlark.com/yuque/0/2024/png/22382235/1715869046951-1f11133a-068d-45c2-b9c0-b932028aa0b4.png"
description: OSI七层模型物理层首先解决两台物理机之间的通信需求，具体就是机器A往机器B发送比特流，机器B能收到比特流。物理层主要定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率。主要作用是传输比特流（0101二进制数据），将比特流转化为电流强弱传输，到达目的后再转化为比特流，即...
---

## OSI 七层模型

**物理层**
首先解决两台物理机之间的通信需求，具体就是机器 A 往机器 B 发送比特流，机器 B 能收到比特流。
物理层主要定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率。
主要作用是传输比特流（0101 二进制数据），将比特流转化为电流强弱传输，到达目的后再转化为比特流，即常说的数模转化和模数转换。
这层数据叫做比特。**网卡工作在这层**。
物理层是 OSI 七层模型的物理基础，没有它就谈不上数据传输了
物理层就是由实物所承载的，所以作比喻的话，公路、汽车和飞机等承载货物（数据）的交通工具，就是物理层的象征
**数据链路层**
在传输比特流的过程中，会产生错传、数据传输不完整的可能。
数据链路层定义了**如何格式化数据进行传输**，以及如何控制对物理介质的访问。通常提供错误检测和纠正，以确保数据传输的准确性。
本层将比特数据组成帧，交换机工作在这层，对帧解码，并根据帧中包含的信息把数据发送到正确的接收方。
该层负责物理层面上互连的节点之间的通信传输。例如与 1 个以太网相连的两个节点间的通讯。
常见的协议有 HDLC、PPP、SLIP 等
数据链路层会将 0、1 序列划分为具有意义的数据帧传送给对端（**数据帧的生成与接收**）
**网络层**
随着网络节点的不断增加，点对点通讯需要通过多个节点，如何找到目标节点，如何选择最佳路径成为首要需求。
网络层主要功能是将网络地址转化为对应的物理地址，并决定如何将数据从发送方路由到接收方。
网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点 A 到另一个网络中节点 B 的最佳路径。
由于网络层处理并智能指导数据传送，路由器连接网络隔断，所以路由器属于网络层。
此层的数据称之为数据包。本层需要关注的协议 TCP/IP 协议中的 IP 协议。
网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责**寻址和路由选择**。主要由 IP、ICMP 两个协议组成
网络层将数据从发送端的主机发送到接收端的主机，两台主机间可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址使用的是 IP 地址。IP 地址通过不断转发到更近的 IP 地址，最终可以到达目标地址
**传输层**
随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很长时间，网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发送出去的数据进行切分，切割为一个一个的段落（Segement）发送，其中一个段落丢失是否重传，段落是否按顺序到达，是传输层需要考虑的问题。
传输层解决了主机间的数据传输，数据间的传输可以是不同网络，并且传输层解决了**传输质量**的问题。
传输层需要关注的协议有 TCP/IP 协议中的 TCP 协议和 UDP 协议。
**会话层**
自动收发包，自动寻址。
会话层作用是**负责建立和断开通信连接**，何时建立，断开连接以及保持多久的连接。常见的协议有 ADSP、RPC 等
**表示层**
Linux 给 WIndows 发包，不同系统语法不一致，如 exe 不能在 Linux 下执行，shell 不能在 Windows 不能直接运行。于是需要表示层。
解决**不同系统之间通信语法问题**，在表示层数据将按照网络能理解的方案进行格式化，格式化因所使用网络的不同而不同。
它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有 ASCII、SSL/TLS 等
**应用层**
规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，消息头中必须记录消息体的长度等信息，方便接收方正确解析发送方发送的数据。
应用层旨在更**方便应用从网络中接收的数据**，重点关注 TCP/IP 协议中的 HTTP 协议
四层传输层数据被称作**段**（Segments）；
三层网络层数据被称做**包**（Packages）；
二层数据链路层时数据被称为**帧**（Frames）；
一层物理层时数据被称为**比特流**（Bits）。
![](https://oss1.aistar.cool/elog-offer-now/288606e8dc4e08f4b77444879d4d8200.png)

## [#](https://javabetter.cn/cs/wangluo.html#tcp%E5%92%8Cip%E6%A8%A1%E5%9E%8B)TCP 和 IP 模型

OSI 模型注重通信协议必要的功能；TCP/IP 更强调在计算机上实现协议应该开发哪种程序
**TCP/IP 划分了四层网络模型**

- 第一层：应用层，主要有负责 web 浏览器的 HTTP 协议， 文件传输的 FTP 协议，负责电子邮件的 SMTP 协议，负责域名系统的 DNS 等
- 第二层：传输层，主要是有**可靠传输**的 TCP 协议，特别**高效**的 UDP 协议。主要负责传输应用层的数据包。
- 第三层：网络层，主要是 IP 协议。主要负责寻址（找到目标设备的位置）
- 第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。

![](https://oss1.aistar.cool/elog-offer-now/c6903afab20261ac0b8635d1ef7725b0.png)
**四层网络协议的作用**

- 发送端是由上至下，把上层来的数据在头部加上各层协议的数据（部首）再下发给下层。
- 接受端则由下而上，把从下层接受到的数据进行解密和去掉头部的部首后再发送给上层。
- 层层加密和解密后，应用层最终拿到了需要的数据。

**举个例子：**
我们需要发送一个**index.html**。
两台电脑在应用层都使用 HTTP 协议（即都使用浏览器）。
在传输层，TCP 协议会将 HTTP 协议发送的数据看作一个数据包，并在这个数据包前面加上 TCP 包的一部分信息（部首）
在网络层，IP 协议会将 TCP 协议要发送的数据看作一个数据包，同样的在这个数据包前端加上 IP 协议的部首
在数据链路层，对应的协议也会在 IP 数据包前端加上以太网的部首。
![](https://oss1.aistar.cool/elog-offer-now/3e8d4ec843a238f44a4a5fc164199567.png)
源设备和目标设备通过网线连接，就可以通过物理层的二进制传输数据。
数据链路层，会使用对应的协议找到物理层的二进制数据，解码得到以太网的部首信息和对应的 IP 数据包，再将 IP 数据包传给上层的网络层。
数据链路层>网络层>传输层>应用层，一层层的解码，最后就可以在浏览器中得到目标设备传送过来的**index.html**。
![](https://oss1.aistar.cool/elog-offer-now/47f5d7b9476cf814006fe756b6d9a281.png)
**TCP/IP 协议族**
从字面意义上来讲，TCP/IP 是指**传输层**的 TCP 协议和**网络层**的 IP 协议。
实际上，TCP/IP 只是利用 IP 进行通信时所必须用到的协议群的统称。
具体来说，在网络层是 IP/ICMP 协议、在传输层是 TCP/UDP 协议、在应用层是 SMTP、FTP、以及 HTTP 等。他们都属于 TCP/IP 协议。
![](https://oss1.aistar.cool/elog-offer-now/509394b2458005d4847e9ef033e23e16.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87)网络设备

### [#](https://javabetter.cn/cs/wangluo.html#%E4%BA%A4%E6%8D%A2%E6%9C%BA)交换机

交换机可以接入多台电脑
每个电脑网卡的 **MAC 地址**都是不一样的，电脑发送数据时，数据头部携带网卡的 MAC 地址，用 MAC 地址标识来不同的电脑
交换机就可以识别数据头部的 MAC 地址来区分不同的电脑
交换机除了能识别不同的电脑，还需要找到电脑连接的**交换机端口**，才能顺利的把数据从相应端口发送出去
交换机通过**自学机制**，把学习到的设备 MAC 地址和交换机端口号添加到 **MAC 地址表**，并根据 MAC 地址表进行数据**转发**

### [#](https://javabetter.cn/cs/wangluo.html#%E8%B7%AF%E7%94%B1%E5%99%A8)路由器

交换机需要记录的 MAC 地址表也越来越多，需要的交换机也越来越多
但是交换机的**容量和性能有限**，MAC 地址表无法记录全世界电脑的 MAC 地址和对应的端口号，MAC 地址表太大也无法快速查找到对应的 MAC 地址表项
于是就有了三层网络设备**路由器**，路由器可以把全世界的网络连接起来
局域网内的网络连接可以使用**交换机**，例如一个公司内的网络或者一个校园内的网络通过交换机连接
不同区域的局域网互联使用**路由器**
那么如何区分不同的网络区域呢？又是如何跨网络区域进行数据转发的呢？
路由器有多个端口，分别连接不同的网络区域，不同网络区域的 IP 地址**网络号不同**
它通过识别目的 IP 地址的**网络号**，再根据**路由表**进行数据转发
![](https://oss1.aistar.cool/elog-offer-now/4f5553da06fd2dac39d1bbec096b3417.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#http)HTTP

**请求方法**
HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。
HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

| 序 号 | 方法    | 描述                                                                                                                                     |
| ----- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| 1     | GET     | 请求指定的页面信息，并返回实体主体。                                                                                                     |
| 2     | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头                                                                          |
| 3     | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
| 4     | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。                                                                                         |
| 5     | DELETE  | 请求服务器删除指定的页面。                                                                                                               |
| 6     | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。                                                                                |
| 7     | OPTIONS | 允许客户端查看服务器的性能。                                                                                                             |
| 8     | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                                                                                               |
| 9     | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。                                                                                       |

**GET 请求和 POST 请求的区别**

1. GET 请求的请求参数是添加到 head 中，可以在 url 中可以看到；POST 请求的请求参数是添加到 body 中，在 url 中不可见。
2. 请求的 url 有长度限制，这个限制由浏览器和 web 服务器决定和设置的，例如 IE 浏览器对 URL 的最大限制为 2083 个字符，如果超过这个数字，提交按钮没有任何反应，因为 GET 请求的参数是添加到 URL 中，所以 GET 请求的 URL 的长度限制需要将请求参数长度也考虑进去。而 POST 请求不用考虑请求参数的长度。
3. GET 请求产生一个数据包; POST 请求产生 2 个数据包，在火狐浏览器中，产生一个数据包，这个区别点在于浏览器的请求机制，先发送请求头，再发送请求体，因为 GET 没有请求体，所以就发送一个数据包，而 POST 包含请求体，所以发送两次数据包，但是由于火狐机制不同，所以发送一个数据包。
4. GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
5. GET 是幂等的，而 POST 不是(幂等表示执行相同的操作，结果也是相同的)
6. GET 是获取数据，POST 是修改数据

### [#](https://javabetter.cn/cs/wangluo.html#%E7%8A%B6%E6%80%81%E7%A0%81)状态码

**状态码由 3 位数字组成，第一位定义响应的类别**
1XX：指示信息，表示请求以接收，继续处理
2XX：成功，表示请求已经被成功接收、理解、接受

- 200 OK 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
- 204 No Content 也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 206 Partial Content 是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

3XX：状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 301 Moved Permanently 表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。
- 302 Moved Permanently 表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问，搜索引擎会抓取新的内容而保存旧的网址。

301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 304 Not Modified 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。

4XX：状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 400 Bad Request 表示客户端请求的报文有错误。
- 401 Unauthorized：缺失或错误的认证，这个状态代码必须和 WWW-Authenticate 报头域一起使用。
- 403 Forbidden 表示服务器禁止访问资源，并不是客户端的请求出错。
- 404 Not Found 表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

5XX：状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 501 Not Implemented 表示客户端请求的功能还不支持。
- 502 Bad Gateway 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务器。
- 504 Gateway Timeout：网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。

**301 和 302 的区别**
301 重定向，指页面永久性转移，表示为资源或页面永久性地转移到了另一个位置。
301 是 HTTP 协议中的一种状态码，当用户或搜索引擎向服务器发出浏览请求时，服务器返回的 HTTP 数据流中头信息中包含状态码 301 ，表示该资源已经永久改变了位置。
302 重定向是页面暂时性转移，搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。

### [#](https://javabetter.cn/cs/wangluo.html#http1-1)HTTP1.1

**长连接**
HTTP 1.1 支持长连接
HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。
HTTP 1.1 则支持持久连接 Persistent Connection，并且默认使用，在同一个 TCP 的连接中可以传送多个 HTTP 请求和响应，多个请求和响应可以重叠，多个请求和响应可以同时进行，更加多的请求头和响应头
HTTP 1.1 的持续连接，也需要增加新的请求头来帮助实现，例如，Connection 请求头的值为 Keep-Alive 时，客户端通知服务器返回本次请求结果后保持连接；Connection 请求头的值为 Close 时，客户端通知服务器返回本次请求结果后关闭连接。
**管道网络传输**
HTTP/1.1 采用了长连接的方式，这使得管道网络传输成为了可能。
即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**
举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求，管道机制则是允许浏览器同时发出 A 请求和 B 请求。
但是服务器还是按照**顺序**，先回应 A 请求，完成后再回应 B 请求，要是 前面的回应特别慢，后面就会有许多请求排队等着。
**Host 字段**
在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。
HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。
此外，服务器应该接受以绝对路径标记的资源请求。
**100Status**
HTTP/1.1 加入了一个新的状态码 100。
客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码 401（Unauthorized）；
如果服务器接收此请求就回送响应码 100，客户端就可以继续发送带实体的完整请求了。
100 状态代码的使用，允许客户端在发 request 消息 body 之前先用 request header 试探一下 server，看 server 要不要接收 request body，再决定要不要发 request body。
**Chunked Transfer Coding**
HTTP/1.1 将发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。
这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。
**Cache**
HTTP/1.1 在 1.0 的基础上加入了一些 Cache 的新特性，当缓存对象的 Age 超过 Expire 时变为 Stable 对象，Cache 不需要直接抛弃 Stable 对象，而是与源服务器进行重新激活。

### [#](https://javabetter.cn/cs/wangluo.html#http2-0)HTTP2.0

**HTTP2.0 和 HTTP1.X 相比的新特性**

- 新的二进制格式，HTTP1.x 的解析是基于文本
- 多路复用，即连接共享，即每一个 request 都是是用作连接共享机制的，一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面
- header 压缩，HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小
- 服务端推送

HTTP/2 还在一定程度上改善了传统的请求 - 应答工作模式，服务不再是被动地响应，也可以**主动**向客户端发送消息。
举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，**减少延时的等待**，也就是服务器推送。
**数据流**
HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。
因此，必须要对数据包做标记，指出它属于哪个回应。
每个请求或回应的所有数据包，称为一个数据流（Stream）。
每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数
客户端还可以**指定数据流的优先级**。优先级高的请求，服务器就先响应该请求。
**HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别**

- HTTP/1.1 的 Pipeling 为若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法；
- HTTP2.0 多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行

### [#](https://javabetter.cn/cs/wangluo.html#http3-0)HTTP3.0

**使用 UDP 协议**
HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。
所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来**。

- HTTP/1.1 中的管道传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了
- HTTP/2 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。

这都是基于 TCP 传输层的问题，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**

### [#](https://javabetter.cn/cs/wangluo.html#https)HTTPS

**HTTP 与 HTTPS 的区别**
HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全

- HTTPS 比 HTTP 更加安全，对搜索引擎更友好，利于 SEO，谷歌、百度优先索引 HTTPS 网页
- HTTPS 需要用到 SSL 证书，而 HTTP 不用
- HTTPS 标准端口 443，HTTP 标准端口 80
- HTTPS 基于传输层，HTTP 基于应用层
- HTTPS 在浏览器显示绿色安全锁，HTTP 没有显示

**工作原理**
HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现
HTTPS 的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：
![](https://oss1.aistar.cool/elog-offer-now/b8e79041cfe365580f8910e1707116f9.png)

- Client 发起一个 HTTPS 的请求
- Server 把事先配置好的公钥证书返回给客户端。
- Client 验证公钥证书：比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书），如果验证通过则继续，不通过则显示警告信息。
- Client 使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给 Server。
- Server 使用自己的私钥解密这个消息，得到对称密钥。至此，Client 和 Server 双方都持有了相同的对称密钥。
- Server 使用对称密钥加密明文内容 A，发送给 Client。
- Client 使用对称密钥解密响应的密文，得到明文内容 A。
- Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的明文内容 B，然后 Server 使用对称密钥解密密文，得到明文内容 B。

#### [#](https://javabetter.cn/cs/wangluo.html#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6)数字证书

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
这就存在些问题，如何保证公钥不被篡改和信任度？
所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将**服务器公钥放在数字证书**（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。
通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。
![](https://oss1.aistar.cool/elog-offer-now/0ee9de562c063f87507d6687fe5c213e.png)

### [#](https://javabetter.cn/cs/wangluo.html#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87)请求报文

**请求头**
HTTP 请求报文由 3 部分组成(请求行+请求头+请求体)
![](https://oss1.aistar.cool/elog-offer-now/966897b2d876233f4dfc7af3f93c9696.png)
**常见的 HTTP 报文头属性**

- Accpet
  - 告诉服务端，客户端接收什么类型的响应
- Referer
  - 表示这是请求是从哪个 URL 进来的,比如想在网上购物，但是不知道选择哪家电商平台，你就去问度娘，说哪家电商的东西便宜啊，然后一堆东西弹出在你面前，第一给就是某宝，当你从这里进入某宝的时候，这个请求报文的 Referer 就是：[www.baidu.com](https://javabetter.cn/cs/www.baidu.com)
- Cache-Control
  - 对缓存进行控制，如一个请求希望响应的内容在客户端缓存一年，或不被缓可以通过这个报文头设置
- Accept-Encoding
  - 这个属性是用来告诉服务器能接受什么编码格式，包括字符编码,压缩形式(一般都是压缩形式)
    - 例如:Accept-Encoding:gzip, deflate(这两种都是压缩格式)
- Host
  - 指定要请求的资源所在的主机和端口
- User-Agent：告诉服务器，客户端使用的操作系统、浏览器版本和名称
- Connection

决定当前事务（三次握手和四次挥手）完成后，是否关闭网络连接。

- 持久连接，事务完成后不关闭网络连接 ： Connection: keep-alive
- 非持久连接，事务完成后关闭网络连接： Connection: close

### [#](https://javabetter.cn/cs/wangluo.html#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87)响应报文

响应报文与请求报文一样，由三个部分组成(响应行,响应头,响应体)
![](https://oss1.aistar.cool/elog-offer-now/1aae4883ba2cceb3c197e601b5415a86.png)
**HTTP 响应报文属性**

- Cache-Control
  - 响应输出到客户端后，服务端通过该属性告诉客户端该怎么控制响应内容的缓存
- ETag
  - 表示你请求资源的版本，如果该资源发生啦变化，那么这个属性也会跟着变
- Location
  - 在重定向中或者创建新资源时使用
- Set-Cookie
  - 服务端可以设置客户端的 cookie

![](https://oss1.aistar.cool/elog-offer-now/880b2806395ced0a748725073ccad9e0.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#tcp)TCP

TCP 是一个传输层协议，提供可靠传输，支持全双工，是一个连接导向的协议。
**双工/单工**
在任何一个时刻，如果数据只能单向发送，就是单工。
如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫作半双工；半双工需要至少 1 条线路。
如果任何时刻数据都可以双向收发，这就是全双工，全双工需要大于 1 条线路。
TCP 是一个双工协议，数据任何时候都可以双向传输。
这就意味着客户端和服务端可以平等地发送、接收信息。

## OSI 七层模型

**物理层**
首先解决两台物理机之间的通信需求，具体就是机器 A 往机器 B 发送比特流，机器 B 能收到比特流。
物理层主要定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率。
主要作用是传输比特流（0101 二进制数据），将比特流转化为电流强弱传输，到达目的后再转化为比特流，即常说的数模转化和模数转换。
这层数据叫做比特。**网卡工作在这层**。
物理层是 OSI 七层模型的物理基础，没有它就谈不上数据传输了
物理层就是由实物所承载的，所以作比喻的话，公路、汽车和飞机等承载货物（数据）的交通工具，就是物理层的象征
**数据链路层**
在传输比特流的过程中，会产生错传、数据传输不完整的可能。
数据链路层定义了**如何格式化数据进行传输**，以及如何控制对物理介质的访问。通常提供错误检测和纠正，以确保数据传输的准确性。
本层将比特数据组成帧，交换机工作在这层，对帧解码，并根据帧中包含的信息把数据发送到正确的接收方。
该层负责物理层面上互连的节点之间的通信传输。例如与 1 个以太网相连的两个节点间的通讯。
常见的协议有 HDLC、PPP、SLIP 等
数据链路层会将 0、1 序列划分为具有意义的数据帧传送给对端（**数据帧的生成与接收**）
**网络层**
随着网络节点的不断增加，点对点通讯需要通过多个节点，如何找到目标节点，如何选择最佳路径成为首要需求。
网络层主要功能是将网络地址转化为对应的物理地址，并决定如何将数据从发送方路由到接收方。
网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点 A 到另一个网络中节点 B 的最佳路径。
由于网络层处理并智能指导数据传送，路由器连接网络隔断，所以路由器属于网络层。
此层的数据称之为数据包。本层需要关注的协议 TCP/IP 协议中的 IP 协议。
网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责**寻址和路由选择**。主要由 IP、ICMP 两个协议组成
网络层将数据从发送端的主机发送到接收端的主机，两台主机间可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址使用的是 IP 地址。IP 地址通过不断转发到更近的 IP 地址，最终可以到达目标地址
**传输层**
随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很长时间，网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发送出去的数据进行切分，切割为一个一个的段落（Segement）发送，其中一个段落丢失是否重传，段落是否按顺序到达，是传输层需要考虑的问题。
传输层解决了主机间的数据传输，数据间的传输可以是不同网络，并且传输层解决了**传输质量**的问题。
传输层需要关注的协议有 TCP/IP 协议中的 TCP 协议和 UDP 协议。
**会话层**
自动收发包，自动寻址。
会话层作用是**负责建立和断开通信连接**，何时建立，断开连接以及保持多久的连接。常见的协议有 ADSP、RPC 等
**表示层**
Linux 给 WIndows 发包，不同系统语法不一致，如 exe 不能在 Linux 下执行，shell 不能在 Windows 不能直接运行。于是需要表示层。
解决**不同系统之间通信语法问题**，在表示层数据将按照网络能理解的方案进行格式化，格式化因所使用网络的不同而不同。
它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有 ASCII、SSL/TLS 等
**应用层**
规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，消息头中必须记录消息体的长度等信息，方便接收方正确解析发送方发送的数据。
应用层旨在更**方便应用从网络中接收的数据**，重点关注 TCP/IP 协议中的 HTTP 协议
四层传输层数据被称作**段**（Segments）；
三层网络层数据被称做**包**（Packages）；
二层数据链路层时数据被称为**帧**（Frames）；
一层物理层时数据被称为**比特流**（Bits）。
![](https://oss1.aistar.cool/elog-offer-now/288606e8dc4e08f4b77444879d4d8200.png)

## [#](https://javabetter.cn/cs/wangluo.html#tcp%E5%92%8Cip%E6%A8%A1%E5%9E%8B)TCP 和 IP 模型

OSI 模型注重通信协议必要的功能；TCP/IP 更强调在计算机上实现协议应该开发哪种程序
**TCP/IP 划分了四层网络模型**

- 第一层：应用层，主要有负责 web 浏览器的 HTTP 协议， 文件传输的 FTP 协议，负责电子邮件的 SMTP 协议，负责域名系统的 DNS 等
- 第二层：传输层，主要是有**可靠传输**的 TCP 协议，特别**高效**的 UDP 协议。主要负责传输应用层的数据包。
- 第三层：网络层，主要是 IP 协议。主要负责寻址（找到目标设备的位置）
- 第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。

![](https://oss1.aistar.cool/elog-offer-now/c6903afab20261ac0b8635d1ef7725b0.png)
**四层网络协议的作用**

- 发送端是由上至下，把上层来的数据在头部加上各层协议的数据（部首）再下发给下层。
- 接受端则由下而上，把从下层接受到的数据进行解密和去掉头部的部首后再发送给上层。
- 层层加密和解密后，应用层最终拿到了需要的数据。

**举个例子：**
我们需要发送一个**index.html**。
两台电脑在应用层都使用 HTTP 协议（即都使用浏览器）。
在传输层，TCP 协议会将 HTTP 协议发送的数据看作一个数据包，并在这个数据包前面加上 TCP 包的一部分信息（部首）
在网络层，IP 协议会将 TCP 协议要发送的数据看作一个数据包，同样的在这个数据包前端加上 IP 协议的部首
在数据链路层，对应的协议也会在 IP 数据包前端加上以太网的部首。
![](https://oss1.aistar.cool/elog-offer-now/3e8d4ec843a238f44a4a5fc164199567.png)
源设备和目标设备通过网线连接，就可以通过物理层的二进制传输数据。
数据链路层，会使用对应的协议找到物理层的二进制数据，解码得到以太网的部首信息和对应的 IP 数据包，再将 IP 数据包传给上层的网络层。
数据链路层>网络层>传输层>应用层，一层层的解码，最后就可以在浏览器中得到目标设备传送过来的**index.html**。
![](https://oss1.aistar.cool/elog-offer-now/47f5d7b9476cf814006fe756b6d9a281.png)
**TCP/IP 协议族**
从字面意义上来讲，TCP/IP 是指**传输层**的 TCP 协议和**网络层**的 IP 协议。
实际上，TCP/IP 只是利用 IP 进行通信时所必须用到的协议群的统称。
具体来说，在网络层是 IP/ICMP 协议、在传输层是 TCP/UDP 协议、在应用层是 SMTP、FTP、以及 HTTP 等。他们都属于 TCP/IP 协议。
![](https://oss1.aistar.cool/elog-offer-now/509394b2458005d4847e9ef033e23e16.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87)网络设备

### [#](https://javabetter.cn/cs/wangluo.html#%E4%BA%A4%E6%8D%A2%E6%9C%BA)交换机

交换机可以接入多台电脑
每个电脑网卡的 **MAC 地址**都是不一样的，电脑发送数据时，数据头部携带网卡的 MAC 地址，用 MAC 地址标识来不同的电脑
交换机就可以识别数据头部的 MAC 地址来区分不同的电脑
交换机除了能识别不同的电脑，还需要找到电脑连接的**交换机端口**，才能顺利的把数据从相应端口发送出去
交换机通过**自学机制**，把学习到的设备 MAC 地址和交换机端口号添加到 **MAC 地址表**，并根据 MAC 地址表进行数据**转发**

### [#](https://javabetter.cn/cs/wangluo.html#%E8%B7%AF%E7%94%B1%E5%99%A8)路由器

交换机需要记录的 MAC 地址表也越来越多，需要的交换机也越来越多
但是交换机的**容量和性能有限**，MAC 地址表无法记录全世界电脑的 MAC 地址和对应的端口号，MAC 地址表太大也无法快速查找到对应的 MAC 地址表项
于是就有了三层网络设备**路由器**，路由器可以把全世界的网络连接起来
局域网内的网络连接可以使用**交换机**，例如一个公司内的网络或者一个校园内的网络通过交换机连接
不同区域的局域网互联使用**路由器**
那么如何区分不同的网络区域呢？又是如何跨网络区域进行数据转发的呢？
路由器有多个端口，分别连接不同的网络区域，不同网络区域的 IP 地址**网络号不同**
它通过识别目的 IP 地址的**网络号**，再根据**路由表**进行数据转发
![](https://oss1.aistar.cool/elog-offer-now/4f5553da06fd2dac39d1bbec096b3417.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#http)HTTP

**请求方法**
HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。
HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

| 序 号 | 方法    | 描述                                                                                                                                     |
| ----- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| 1     | GET     | 请求指定的页面信息，并返回实体主体。                                                                                                     |
| 2     | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头                                                                          |
| 3     | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
| 4     | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。                                                                                         |
| 5     | DELETE  | 请求服务器删除指定的页面。                                                                                                               |
| 6     | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。                                                                                |
| 7     | OPTIONS | 允许客户端查看服务器的性能。                                                                                                             |
| 8     | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                                                                                               |
| 9     | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。                                                                                       |

**GET 请求和 POST 请求的区别**

1. GET 请求的请求参数是添加到 head 中，可以在 url 中可以看到；POST 请求的请求参数是添加到 body 中，在 url 中不可见。
2. 请求的 url 有长度限制，这个限制由浏览器和 web 服务器决定和设置的，例如 IE 浏览器对 URL 的最大限制为 2083 个字符，如果超过这个数字，提交按钮没有任何反应，因为 GET 请求的参数是添加到 URL 中，所以 GET 请求的 URL 的长度限制需要将请求参数长度也考虑进去。而 POST 请求不用考虑请求参数的长度。
3. GET 请求产生一个数据包; POST 请求产生 2 个数据包，在火狐浏览器中，产生一个数据包，这个区别点在于浏览器的请求机制，先发送请求头，再发送请求体，因为 GET 没有请求体，所以就发送一个数据包，而 POST 包含请求体，所以发送两次数据包，但是由于火狐机制不同，所以发送一个数据包。
4. GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
5. GET 是幂等的，而 POST 不是(幂等表示执行相同的操作，结果也是相同的)
6. GET 是获取数据，POST 是修改数据

### [#](https://javabetter.cn/cs/wangluo.html#%E7%8A%B6%E6%80%81%E7%A0%81)状态码

**状态码由 3 位数字组成，第一位定义响应的类别**
1XX：指示信息，表示请求以接收，继续处理
2XX：成功，表示请求已经被成功接收、理解、接受

- 200 OK 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
- 204 No Content 也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 206 Partial Content 是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

3XX：状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 301 Moved Permanently 表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。
- 302 Moved Permanently 表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问，搜索引擎会抓取新的内容而保存旧的网址。

301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 304 Not Modified 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。

4XX：状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 400 Bad Request 表示客户端请求的报文有错误。
- 401 Unauthorized：缺失或错误的认证，这个状态代码必须和 WWW-Authenticate 报头域一起使用。
- 403 Forbidden 表示服务器禁止访问资源，并不是客户端的请求出错。
- 404 Not Found 表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

5XX：状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 501 Not Implemented 表示客户端请求的功能还不支持。
- 502 Bad Gateway 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务器。
- 504 Gateway Timeout：网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。

**301 和 302 的区别**
301 重定向，指页面永久性转移，表示为资源或页面永久性地转移到了另一个位置。
301 是 HTTP 协议中的一种状态码，当用户或搜索引擎向服务器发出浏览请求时，服务器返回的 HTTP 数据流中头信息中包含状态码 301 ，表示该资源已经永久改变了位置。
302 重定向是页面暂时性转移，搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。

### [#](https://javabetter.cn/cs/wangluo.html#http1-1)HTTP1.1

**长连接**
HTTP 1.1 支持长连接
HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。
HTTP 1.1 则支持持久连接 Persistent Connection，并且默认使用，在同一个 TCP 的连接中可以传送多个 HTTP 请求和响应，多个请求和响应可以重叠，多个请求和响应可以同时进行，更加多的请求头和响应头
HTTP 1.1 的持续连接，也需要增加新的请求头来帮助实现，例如，Connection 请求头的值为 Keep-Alive 时，客户端通知服务器返回本次请求结果后保持连接；Connection 请求头的值为 Close 时，客户端通知服务器返回本次请求结果后关闭连接。
**管道网络传输**
HTTP/1.1 采用了长连接的方式，这使得管道网络传输成为了可能。
即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**
举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求，管道机制则是允许浏览器同时发出 A 请求和 B 请求。
但是服务器还是按照**顺序**，先回应 A 请求，完成后再回应 B 请求，要是 前面的回应特别慢，后面就会有许多请求排队等着。
**Host 字段**
在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。
HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。
此外，服务器应该接受以绝对路径标记的资源请求。
**100Status**
HTTP/1.1 加入了一个新的状态码 100。
客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码 401（Unauthorized）；
如果服务器接收此请求就回送响应码 100，客户端就可以继续发送带实体的完整请求了。
100 状态代码的使用，允许客户端在发 request 消息 body 之前先用 request header 试探一下 server，看 server 要不要接收 request body，再决定要不要发 request body。
**Chunked Transfer Coding**
HTTP/1.1 将发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。
这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。
**Cache**
HTTP/1.1 在 1.0 的基础上加入了一些 Cache 的新特性，当缓存对象的 Age 超过 Expire 时变为 Stable 对象，Cache 不需要直接抛弃 Stable 对象，而是与源服务器进行重新激活。

### [#](https://javabetter.cn/cs/wangluo.html#http2-0)HTTP2.0

**HTTP2.0 和 HTTP1.X 相比的新特性**

- 新的二进制格式，HTTP1.x 的解析是基于文本
- 多路复用，即连接共享，即每一个 request 都是是用作连接共享机制的，一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面
- header 压缩，HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小
- 服务端推送

HTTP/2 还在一定程度上改善了传统的请求 - 应答工作模式，服务不再是被动地响应，也可以**主动**向客户端发送消息。
举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，**减少延时的等待**，也就是服务器推送。
**数据流**
HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。
因此，必须要对数据包做标记，指出它属于哪个回应。
每个请求或回应的所有数据包，称为一个数据流（Stream）。
每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数
客户端还可以**指定数据流的优先级**。优先级高的请求，服务器就先响应该请求。
**HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别**

- HTTP/1.1 的 Pipeling 为若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法；
- HTTP2.0 多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行

### [#](https://javabetter.cn/cs/wangluo.html#http3-0)HTTP3.0

**使用 UDP 协议**
HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。
所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来**。

- HTTP/1.1 中的管道传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了
- HTTP/2 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。

这都是基于 TCP 传输层的问题，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**

### [#](https://javabetter.cn/cs/wangluo.html#https)HTTPS

**HTTP 与 HTTPS 的区别**
HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全

- HTTPS 比 HTTP 更加安全，对搜索引擎更友好，利于 SEO，谷歌、百度优先索引 HTTPS 网页
- HTTPS 需要用到 SSL 证书，而 HTTP 不用
- HTTPS 标准端口 443，HTTP 标准端口 80
- HTTPS 基于传输层，HTTP 基于应用层
- HTTPS 在浏览器显示绿色安全锁，HTTP 没有显示

**工作原理**
HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现
HTTPS 的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：
![](https://oss1.aistar.cool/elog-offer-now/b8e79041cfe365580f8910e1707116f9.png)

- Client 发起一个 HTTPS 的请求
- Server 把事先配置好的公钥证书返回给客户端。
- Client 验证公钥证书：比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书），如果验证通过则继续，不通过则显示警告信息。
- Client 使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给 Server。
- Server 使用自己的私钥解密这个消息，得到对称密钥。至此，Client 和 Server 双方都持有了相同的对称密钥。
- Server 使用对称密钥加密明文内容 A，发送给 Client。
- Client 使用对称密钥解密响应的密文，得到明文内容 A。
- Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的明文内容 B，然后 Server 使用对称密钥解密密文，得到明文内容 B。

#### [#](https://javabetter.cn/cs/wangluo.html#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6)数字证书

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
这就存在些问题，如何保证公钥不被篡改和信任度？
所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将**服务器公钥放在数字证书**（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。
通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。
![](https://oss1.aistar.cool/elog-offer-now/0ee9de562c063f87507d6687fe5c213e.png)

### [#](https://javabetter.cn/cs/wangluo.html#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87)请求报文

**请求头**
HTTP 请求报文由 3 部分组成(请求行+请求头+请求体)
![](https://oss1.aistar.cool/elog-offer-now/966897b2d876233f4dfc7af3f93c9696.png)
**常见的 HTTP 报文头属性**

- Accpet
  - 告诉服务端，客户端接收什么类型的响应
- Referer
  - 表示这是请求是从哪个 URL 进来的,比如想在网上购物，但是不知道选择哪家电商平台，你就去问度娘，说哪家电商的东西便宜啊，然后一堆东西弹出在你面前，第一给就是某宝，当你从这里进入某宝的时候，这个请求报文的 Referer 就是：[www.baidu.com](https://javabetter.cn/cs/www.baidu.com)
- Cache-Control
  - 对缓存进行控制，如一个请求希望响应的内容在客户端缓存一年，或不被缓可以通过这个报文头设置
- Accept-Encoding
  - 这个属性是用来告诉服务器能接受什么编码格式，包括字符编码,压缩形式(一般都是压缩形式)
    - 例如:Accept-Encoding:gzip, deflate(这两种都是压缩格式)
- Host
  - 指定要请求的资源所在的主机和端口
- User-Agent：告诉服务器，客户端使用的操作系统、浏览器版本和名称
- Connection

决定当前事务（三次握手和四次挥手）完成后，是否关闭网络连接。

- 持久连接，事务完成后不关闭网络连接 ： Connection: keep-alive
- 非持久连接，事务完成后关闭网络连接： Connection: close

### [#](https://javabetter.cn/cs/wangluo.html#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87)响应报文

响应报文与请求报文一样，由三个部分组成(响应行,响应头,响应体)
![](https://oss1.aistar.cool/elog-offer-now/1aae4883ba2cceb3c197e601b5415a86.png)
**HTTP 响应报文属性**

- Cache-Control
  - 响应输出到客户端后，服务端通过该属性告诉客户端该怎么控制响应内容的缓存
- ETag
  - 表示你请求资源的版本，如果该资源发生啦变化，那么这个属性也会跟着变
- Location
  - 在重定向中或者创建新资源时使用
- Set-Cookie
  - 服务端可以设置客户端的 cookie

![](https://oss1.aistar.cool/elog-offer-now/880b2806395ced0a748725073ccad9e0.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#tcp)TCP

TCP 是一个传输层协议，提供可靠传输，支持全双工，是一个连接导向的协议。
**双工/单工**
在任何一个时刻，如果数据只能单向发送，就是单工。
如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫作半双工；半双工需要至少 1 条线路。
如果任何时刻数据都可以双向收发，这就是全双工，全双工需要大于 1 条线路。
TCP 是一个双工协议，数据任何时候都可以双向传输。
这就意味着客户端和服务端可以平等地发送、接收信息。

## OSI 七层模型

**物理层**
首先解决两台物理机之间的通信需求，具体就是机器 A 往机器 B 发送比特流，机器 B 能收到比特流。
物理层主要定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率。
主要作用是传输比特流（0101 二进制数据），将比特流转化为电流强弱传输，到达目的后再转化为比特流，即常说的数模转化和模数转换。
这层数据叫做比特。**网卡工作在这层**。
物理层是 OSI 七层模型的物理基础，没有它就谈不上数据传输了
物理层就是由实物所承载的，所以作比喻的话，公路、汽车和飞机等承载货物（数据）的交通工具，就是物理层的象征
**数据链路层**
在传输比特流的过程中，会产生错传、数据传输不完整的可能。
数据链路层定义了**如何格式化数据进行传输**，以及如何控制对物理介质的访问。通常提供错误检测和纠正，以确保数据传输的准确性。
本层将比特数据组成帧，交换机工作在这层，对帧解码，并根据帧中包含的信息把数据发送到正确的接收方。
该层负责物理层面上互连的节点之间的通信传输。例如与 1 个以太网相连的两个节点间的通讯。
常见的协议有 HDLC、PPP、SLIP 等
数据链路层会将 0、1 序列划分为具有意义的数据帧传送给对端（**数据帧的生成与接收**）
**网络层**
随着网络节点的不断增加，点对点通讯需要通过多个节点，如何找到目标节点，如何选择最佳路径成为首要需求。
网络层主要功能是将网络地址转化为对应的物理地址，并决定如何将数据从发送方路由到接收方。
网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点 A 到另一个网络中节点 B 的最佳路径。
由于网络层处理并智能指导数据传送，路由器连接网络隔断，所以路由器属于网络层。
此层的数据称之为数据包。本层需要关注的协议 TCP/IP 协议中的 IP 协议。
网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责**寻址和路由选择**。主要由 IP、ICMP 两个协议组成
网络层将数据从发送端的主机发送到接收端的主机，两台主机间可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址使用的是 IP 地址。IP 地址通过不断转发到更近的 IP 地址，最终可以到达目标地址
**传输层**
随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很长时间，网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发送出去的数据进行切分，切割为一个一个的段落（Segement）发送，其中一个段落丢失是否重传，段落是否按顺序到达，是传输层需要考虑的问题。
传输层解决了主机间的数据传输，数据间的传输可以是不同网络，并且传输层解决了**传输质量**的问题。
传输层需要关注的协议有 TCP/IP 协议中的 TCP 协议和 UDP 协议。
**会话层**
自动收发包，自动寻址。
会话层作用是**负责建立和断开通信连接**，何时建立，断开连接以及保持多久的连接。常见的协议有 ADSP、RPC 等
**表示层**
Linux 给 WIndows 发包，不同系统语法不一致，如 exe 不能在 Linux 下执行，shell 不能在 Windows 不能直接运行。于是需要表示层。
解决**不同系统之间通信语法问题**，在表示层数据将按照网络能理解的方案进行格式化，格式化因所使用网络的不同而不同。
它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有 ASCII、SSL/TLS 等
**应用层**
规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，消息头中必须记录消息体的长度等信息，方便接收方正确解析发送方发送的数据。
应用层旨在更**方便应用从网络中接收的数据**，重点关注 TCP/IP 协议中的 HTTP 协议
四层传输层数据被称作**段**（Segments）；
三层网络层数据被称做**包**（Packages）；
二层数据链路层时数据被称为**帧**（Frames）；
一层物理层时数据被称为**比特流**（Bits）。
![](https://oss1.aistar.cool/elog-offer-now/288606e8dc4e08f4b77444879d4d8200.png)

## [#](https://javabetter.cn/cs/wangluo.html#tcp%E5%92%8Cip%E6%A8%A1%E5%9E%8B)TCP 和 IP 模型

OSI 模型注重通信协议必要的功能；TCP/IP 更强调在计算机上实现协议应该开发哪种程序
**TCP/IP 划分了四层网络模型**

- 第一层：应用层，主要有负责 web 浏览器的 HTTP 协议， 文件传输的 FTP 协议，负责电子邮件的 SMTP 协议，负责域名系统的 DNS 等
- 第二层：传输层，主要是有**可靠传输**的 TCP 协议，特别**高效**的 UDP 协议。主要负责传输应用层的数据包。
- 第三层：网络层，主要是 IP 协议。主要负责寻址（找到目标设备的位置）
- 第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。

![](https://oss1.aistar.cool/elog-offer-now/c6903afab20261ac0b8635d1ef7725b0.png)
**四层网络协议的作用**

- 发送端是由上至下，把上层来的数据在头部加上各层协议的数据（部首）再下发给下层。
- 接受端则由下而上，把从下层接受到的数据进行解密和去掉头部的部首后再发送给上层。
- 层层加密和解密后，应用层最终拿到了需要的数据。

**举个例子：**
我们需要发送一个**index.html**。
两台电脑在应用层都使用 HTTP 协议（即都使用浏览器）。
在传输层，TCP 协议会将 HTTP 协议发送的数据看作一个数据包，并在这个数据包前面加上 TCP 包的一部分信息（部首）
在网络层，IP 协议会将 TCP 协议要发送的数据看作一个数据包，同样的在这个数据包前端加上 IP 协议的部首
在数据链路层，对应的协议也会在 IP 数据包前端加上以太网的部首。
![](https://oss1.aistar.cool/elog-offer-now/3e8d4ec843a238f44a4a5fc164199567.png)
源设备和目标设备通过网线连接，就可以通过物理层的二进制传输数据。
数据链路层，会使用对应的协议找到物理层的二进制数据，解码得到以太网的部首信息和对应的 IP 数据包，再将 IP 数据包传给上层的网络层。
数据链路层>网络层>传输层>应用层，一层层的解码，最后就可以在浏览器中得到目标设备传送过来的**index.html**。
![](https://oss1.aistar.cool/elog-offer-now/47f5d7b9476cf814006fe756b6d9a281.png)
**TCP/IP 协议族**
从字面意义上来讲，TCP/IP 是指**传输层**的 TCP 协议和**网络层**的 IP 协议。
实际上，TCP/IP 只是利用 IP 进行通信时所必须用到的协议群的统称。
具体来说，在网络层是 IP/ICMP 协议、在传输层是 TCP/UDP 协议、在应用层是 SMTP、FTP、以及 HTTP 等。他们都属于 TCP/IP 协议。
![](https://oss1.aistar.cool/elog-offer-now/509394b2458005d4847e9ef033e23e16.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87)网络设备

### [#](https://javabetter.cn/cs/wangluo.html#%E4%BA%A4%E6%8D%A2%E6%9C%BA)交换机

交换机可以接入多台电脑
每个电脑网卡的 **MAC 地址**都是不一样的，电脑发送数据时，数据头部携带网卡的 MAC 地址，用 MAC 地址标识来不同的电脑
交换机就可以识别数据头部的 MAC 地址来区分不同的电脑
交换机除了能识别不同的电脑，还需要找到电脑连接的**交换机端口**，才能顺利的把数据从相应端口发送出去
交换机通过**自学机制**，把学习到的设备 MAC 地址和交换机端口号添加到 **MAC 地址表**，并根据 MAC 地址表进行数据**转发**

### [#](https://javabetter.cn/cs/wangluo.html#%E8%B7%AF%E7%94%B1%E5%99%A8)路由器

交换机需要记录的 MAC 地址表也越来越多，需要的交换机也越来越多
但是交换机的**容量和性能有限**，MAC 地址表无法记录全世界电脑的 MAC 地址和对应的端口号，MAC 地址表太大也无法快速查找到对应的 MAC 地址表项
于是就有了三层网络设备**路由器**，路由器可以把全世界的网络连接起来
局域网内的网络连接可以使用**交换机**，例如一个公司内的网络或者一个校园内的网络通过交换机连接
不同区域的局域网互联使用**路由器**
那么如何区分不同的网络区域呢？又是如何跨网络区域进行数据转发的呢？
路由器有多个端口，分别连接不同的网络区域，不同网络区域的 IP 地址**网络号不同**
它通过识别目的 IP 地址的**网络号**，再根据**路由表**进行数据转发
![](https://oss1.aistar.cool/elog-offer-now/4f5553da06fd2dac39d1bbec096b3417.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#http)HTTP

**请求方法**
HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。
HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

| 序 号 | 方法    | 描述                                                                                                                                     |
| ----- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| 1     | GET     | 请求指定的页面信息，并返回实体主体。                                                                                                     |
| 2     | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头                                                                          |
| 3     | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
| 4     | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。                                                                                         |
| 5     | DELETE  | 请求服务器删除指定的页面。                                                                                                               |
| 6     | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。                                                                                |
| 7     | OPTIONS | 允许客户端查看服务器的性能。                                                                                                             |
| 8     | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                                                                                               |
| 9     | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。                                                                                       |

**GET 请求和 POST 请求的区别**

1. GET 请求的请求参数是添加到 head 中，可以在 url 中可以看到；POST 请求的请求参数是添加到 body 中，在 url 中不可见。
2. 请求的 url 有长度限制，这个限制由浏览器和 web 服务器决定和设置的，例如 IE 浏览器对 URL 的最大限制为 2083 个字符，如果超过这个数字，提交按钮没有任何反应，因为 GET 请求的参数是添加到 URL 中，所以 GET 请求的 URL 的长度限制需要将请求参数长度也考虑进去。而 POST 请求不用考虑请求参数的长度。
3. GET 请求产生一个数据包; POST 请求产生 2 个数据包，在火狐浏览器中，产生一个数据包，这个区别点在于浏览器的请求机制，先发送请求头，再发送请求体，因为 GET 没有请求体，所以就发送一个数据包，而 POST 包含请求体，所以发送两次数据包，但是由于火狐机制不同，所以发送一个数据包。
4. GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
5. GET 是幂等的，而 POST 不是(幂等表示执行相同的操作，结果也是相同的)
6. GET 是获取数据，POST 是修改数据

### [#](https://javabetter.cn/cs/wangluo.html#%E7%8A%B6%E6%80%81%E7%A0%81)状态码

**状态码由 3 位数字组成，第一位定义响应的类别**
1XX：指示信息，表示请求以接收，继续处理
2XX：成功，表示请求已经被成功接收、理解、接受

- 200 OK 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
- 204 No Content 也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 206 Partial Content 是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

3XX：状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 301 Moved Permanently 表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。
- 302 Moved Permanently 表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问，搜索引擎会抓取新的内容而保存旧的网址。

301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 304 Not Modified 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。

4XX：状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 400 Bad Request 表示客户端请求的报文有错误。
- 401 Unauthorized：缺失或错误的认证，这个状态代码必须和 WWW-Authenticate 报头域一起使用。
- 403 Forbidden 表示服务器禁止访问资源，并不是客户端的请求出错。
- 404 Not Found 表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

5XX：状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 501 Not Implemented 表示客户端请求的功能还不支持。
- 502 Bad Gateway 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务器。
- 504 Gateway Timeout：网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。

**301 和 302 的区别**
301 重定向，指页面永久性转移，表示为资源或页面永久性地转移到了另一个位置。
301 是 HTTP 协议中的一种状态码，当用户或搜索引擎向服务器发出浏览请求时，服务器返回的 HTTP 数据流中头信息中包含状态码 301 ，表示该资源已经永久改变了位置。
302 重定向是页面暂时性转移，搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。

### [#](https://javabetter.cn/cs/wangluo.html#http1-1)HTTP1.1

**长连接**
HTTP 1.1 支持长连接
HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。
HTTP 1.1 则支持持久连接 Persistent Connection，并且默认使用，在同一个 TCP 的连接中可以传送多个 HTTP 请求和响应，多个请求和响应可以重叠，多个请求和响应可以同时进行，更加多的请求头和响应头
HTTP 1.1 的持续连接，也需要增加新的请求头来帮助实现，例如，Connection 请求头的值为 Keep-Alive 时，客户端通知服务器返回本次请求结果后保持连接；Connection 请求头的值为 Close 时，客户端通知服务器返回本次请求结果后关闭连接。
**管道网络传输**
HTTP/1.1 采用了长连接的方式，这使得管道网络传输成为了可能。
即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**
举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求，管道机制则是允许浏览器同时发出 A 请求和 B 请求。
但是服务器还是按照**顺序**，先回应 A 请求，完成后再回应 B 请求，要是 前面的回应特别慢，后面就会有许多请求排队等着。
**Host 字段**
在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。
HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。
此外，服务器应该接受以绝对路径标记的资源请求。
**100Status**
HTTP/1.1 加入了一个新的状态码 100。
客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码 401（Unauthorized）；
如果服务器接收此请求就回送响应码 100，客户端就可以继续发送带实体的完整请求了。
100 状态代码的使用，允许客户端在发 request 消息 body 之前先用 request header 试探一下 server，看 server 要不要接收 request body，再决定要不要发 request body。
**Chunked Transfer Coding**
HTTP/1.1 将发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。
这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。
**Cache**
HTTP/1.1 在 1.0 的基础上加入了一些 Cache 的新特性，当缓存对象的 Age 超过 Expire 时变为 Stable 对象，Cache 不需要直接抛弃 Stable 对象，而是与源服务器进行重新激活。

### [#](https://javabetter.cn/cs/wangluo.html#http2-0)HTTP2.0

**HTTP2.0 和 HTTP1.X 相比的新特性**

- 新的二进制格式，HTTP1.x 的解析是基于文本
- 多路复用，即连接共享，即每一个 request 都是是用作连接共享机制的，一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面
- header 压缩，HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小
- 服务端推送

HTTP/2 还在一定程度上改善了传统的请求 - 应答工作模式，服务不再是被动地响应，也可以**主动**向客户端发送消息。
举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，**减少延时的等待**，也就是服务器推送。
**数据流**
HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。
因此，必须要对数据包做标记，指出它属于哪个回应。
每个请求或回应的所有数据包，称为一个数据流（Stream）。
每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数
客户端还可以**指定数据流的优先级**。优先级高的请求，服务器就先响应该请求。
**HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别**

- HTTP/1.1 的 Pipeling 为若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法；
- HTTP2.0 多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行

### [#](https://javabetter.cn/cs/wangluo.html#http3-0)HTTP3.0

**使用 UDP 协议**
HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。
所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来**。

- HTTP/1.1 中的管道传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了
- HTTP/2 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。

这都是基于 TCP 传输层的问题，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**

### [#](https://javabetter.cn/cs/wangluo.html#https)HTTPS

**HTTP 与 HTTPS 的区别**
HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全

- HTTPS 比 HTTP 更加安全，对搜索引擎更友好，利于 SEO，谷歌、百度优先索引 HTTPS 网页
- HTTPS 需要用到 SSL 证书，而 HTTP 不用
- HTTPS 标准端口 443，HTTP 标准端口 80
- HTTPS 基于传输层，HTTP 基于应用层
- HTTPS 在浏览器显示绿色安全锁，HTTP 没有显示

**工作原理**
HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现
HTTPS 的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：
![](https://oss1.aistar.cool/elog-offer-now/b8e79041cfe365580f8910e1707116f9.png)

- Client 发起一个 HTTPS 的请求
- Server 把事先配置好的公钥证书返回给客户端。
- Client 验证公钥证书：比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书），如果验证通过则继续，不通过则显示警告信息。
- Client 使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给 Server。
- Server 使用自己的私钥解密这个消息，得到对称密钥。至此，Client 和 Server 双方都持有了相同的对称密钥。
- Server 使用对称密钥加密明文内容 A，发送给 Client。
- Client 使用对称密钥解密响应的密文，得到明文内容 A。
- Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的明文内容 B，然后 Server 使用对称密钥解密密文，得到明文内容 B。

#### [#](https://javabetter.cn/cs/wangluo.html#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6)数字证书

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
这就存在些问题，如何保证公钥不被篡改和信任度？
所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将**服务器公钥放在数字证书**（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。
通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。
![](https://oss1.aistar.cool/elog-offer-now/0ee9de562c063f87507d6687fe5c213e.png)

### [#](https://javabetter.cn/cs/wangluo.html#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87)请求报文

**请求头**
HTTP 请求报文由 3 部分组成(请求行+请求头+请求体)
![](https://oss1.aistar.cool/elog-offer-now/966897b2d876233f4dfc7af3f93c9696.png)
**常见的 HTTP 报文头属性**

- Accpet
  - 告诉服务端，客户端接收什么类型的响应
- Referer
  - 表示这是请求是从哪个 URL 进来的,比如想在网上购物，但是不知道选择哪家电商平台，你就去问度娘，说哪家电商的东西便宜啊，然后一堆东西弹出在你面前，第一给就是某宝，当你从这里进入某宝的时候，这个请求报文的 Referer 就是：[www.baidu.com](https://javabetter.cn/cs/www.baidu.com)
- Cache-Control
  - 对缓存进行控制，如一个请求希望响应的内容在客户端缓存一年，或不被缓可以通过这个报文头设置
- Accept-Encoding
  - 这个属性是用来告诉服务器能接受什么编码格式，包括字符编码,压缩形式(一般都是压缩形式)
    - 例如:Accept-Encoding:gzip, deflate(这两种都是压缩格式)
- Host
  - 指定要请求的资源所在的主机和端口
- User-Agent：告诉服务器，客户端使用的操作系统、浏览器版本和名称
- Connection

决定当前事务（三次握手和四次挥手）完成后，是否关闭网络连接。

- 持久连接，事务完成后不关闭网络连接 ： Connection: keep-alive
- 非持久连接，事务完成后关闭网络连接： Connection: close

### [#](https://javabetter.cn/cs/wangluo.html#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87)响应报文

响应报文与请求报文一样，由三个部分组成(响应行,响应头,响应体)
![](https://oss1.aistar.cool/elog-offer-now/1aae4883ba2cceb3c197e601b5415a86.png)
**HTTP 响应报文属性**

- Cache-Control
  - 响应输出到客户端后，服务端通过该属性告诉客户端该怎么控制响应内容的缓存
- ETag
  - 表示你请求资源的版本，如果该资源发生啦变化，那么这个属性也会跟着变
- Location
  - 在重定向中或者创建新资源时使用
- Set-Cookie
  - 服务端可以设置客户端的 cookie

![](https://oss1.aistar.cool/elog-offer-now/880b2806395ced0a748725073ccad9e0.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#tcp)TCP

TCP 是一个传输层协议，提供可靠传输，支持全双工，是一个连接导向的协议。
**双工/单工**
在任何一个时刻，如果数据只能单向发送，就是单工。
如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫作半双工；半双工需要至少 1 条线路。
如果任何时刻数据都可以双向收发，这就是全双工，全双工需要大于 1 条线路。
TCP 是一个双工协议，数据任何时候都可以双向传输。
这就意味着客户端和服务端可以平等地发送、接收信息。

## OSI 七层模型

**物理层**
首先解决两台物理机之间的通信需求，具体就是机器 A 往机器 B 发送比特流，机器 B 能收到比特流。
物理层主要定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率。
主要作用是传输比特流（0101 二进制数据），将比特流转化为电流强弱传输，到达目的后再转化为比特流，即常说的数模转化和模数转换。
这层数据叫做比特。**网卡工作在这层**。
物理层是 OSI 七层模型的物理基础，没有它就谈不上数据传输了
物理层就是由实物所承载的，所以作比喻的话，公路、汽车和飞机等承载货物（数据）的交通工具，就是物理层的象征
**数据链路层**
在传输比特流的过程中，会产生错传、数据传输不完整的可能。
数据链路层定义了**如何格式化数据进行传输**，以及如何控制对物理介质的访问。通常提供错误检测和纠正，以确保数据传输的准确性。
本层将比特数据组成帧，交换机工作在这层，对帧解码，并根据帧中包含的信息把数据发送到正确的接收方。
该层负责物理层面上互连的节点之间的通信传输。例如与 1 个以太网相连的两个节点间的通讯。
常见的协议有 HDLC、PPP、SLIP 等
数据链路层会将 0、1 序列划分为具有意义的数据帧传送给对端（**数据帧的生成与接收**）
**网络层**
随着网络节点的不断增加，点对点通讯需要通过多个节点，如何找到目标节点，如何选择最佳路径成为首要需求。
网络层主要功能是将网络地址转化为对应的物理地址，并决定如何将数据从发送方路由到接收方。
网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点 A 到另一个网络中节点 B 的最佳路径。
由于网络层处理并智能指导数据传送，路由器连接网络隔断，所以路由器属于网络层。
此层的数据称之为数据包。本层需要关注的协议 TCP/IP 协议中的 IP 协议。
网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责**寻址和路由选择**。主要由 IP、ICMP 两个协议组成
网络层将数据从发送端的主机发送到接收端的主机，两台主机间可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址使用的是 IP 地址。IP 地址通过不断转发到更近的 IP 地址，最终可以到达目标地址
**传输层**
随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很长时间，网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发送出去的数据进行切分，切割为一个一个的段落（Segement）发送，其中一个段落丢失是否重传，段落是否按顺序到达，是传输层需要考虑的问题。
传输层解决了主机间的数据传输，数据间的传输可以是不同网络，并且传输层解决了**传输质量**的问题。
传输层需要关注的协议有 TCP/IP 协议中的 TCP 协议和 UDP 协议。
**会话层**
自动收发包，自动寻址。
会话层作用是**负责建立和断开通信连接**，何时建立，断开连接以及保持多久的连接。常见的协议有 ADSP、RPC 等
**表示层**
Linux 给 WIndows 发包，不同系统语法不一致，如 exe 不能在 Linux 下执行，shell 不能在 Windows 不能直接运行。于是需要表示层。
解决**不同系统之间通信语法问题**，在表示层数据将按照网络能理解的方案进行格式化，格式化因所使用网络的不同而不同。
它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有 ASCII、SSL/TLS 等
**应用层**
规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，消息头中必须记录消息体的长度等信息，方便接收方正确解析发送方发送的数据。
应用层旨在更**方便应用从网络中接收的数据**，重点关注 TCP/IP 协议中的 HTTP 协议
四层传输层数据被称作**段**（Segments）；
三层网络层数据被称做**包**（Packages）；
二层数据链路层时数据被称为**帧**（Frames）；
一层物理层时数据被称为**比特流**（Bits）。
![](https://oss1.aistar.cool/elog-offer-now/288606e8dc4e08f4b77444879d4d8200.png)

## [#](https://javabetter.cn/cs/wangluo.html#tcp%E5%92%8Cip%E6%A8%A1%E5%9E%8B)TCP 和 IP 模型

OSI 模型注重通信协议必要的功能；TCP/IP 更强调在计算机上实现协议应该开发哪种程序
**TCP/IP 划分了四层网络模型**

- 第一层：应用层，主要有负责 web 浏览器的 HTTP 协议， 文件传输的 FTP 协议，负责电子邮件的 SMTP 协议，负责域名系统的 DNS 等
- 第二层：传输层，主要是有**可靠传输**的 TCP 协议，特别**高效**的 UDP 协议。主要负责传输应用层的数据包。
- 第三层：网络层，主要是 IP 协议。主要负责寻址（找到目标设备的位置）
- 第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。

![](https://oss1.aistar.cool/elog-offer-now/c6903afab20261ac0b8635d1ef7725b0.png)
**四层网络协议的作用**

- 发送端是由上至下，把上层来的数据在头部加上各层协议的数据（部首）再下发给下层。
- 接受端则由下而上，把从下层接受到的数据进行解密和去掉头部的部首后再发送给上层。
- 层层加密和解密后，应用层最终拿到了需要的数据。

**举个例子：**
我们需要发送一个**index.html**。
两台电脑在应用层都使用 HTTP 协议（即都使用浏览器）。
在传输层，TCP 协议会将 HTTP 协议发送的数据看作一个数据包，并在这个数据包前面加上 TCP 包的一部分信息（部首）
在网络层，IP 协议会将 TCP 协议要发送的数据看作一个数据包，同样的在这个数据包前端加上 IP 协议的部首
在数据链路层，对应的协议也会在 IP 数据包前端加上以太网的部首。
![](https://oss1.aistar.cool/elog-offer-now/3e8d4ec843a238f44a4a5fc164199567.png)
源设备和目标设备通过网线连接，就可以通过物理层的二进制传输数据。
数据链路层，会使用对应的协议找到物理层的二进制数据，解码得到以太网的部首信息和对应的 IP 数据包，再将 IP 数据包传给上层的网络层。
数据链路层>网络层>传输层>应用层，一层层的解码，最后就可以在浏览器中得到目标设备传送过来的**index.html**。
![](https://oss1.aistar.cool/elog-offer-now/47f5d7b9476cf814006fe756b6d9a281.png)
**TCP/IP 协议族**
从字面意义上来讲，TCP/IP 是指**传输层**的 TCP 协议和**网络层**的 IP 协议。
实际上，TCP/IP 只是利用 IP 进行通信时所必须用到的协议群的统称。
具体来说，在网络层是 IP/ICMP 协议、在传输层是 TCP/UDP 协议、在应用层是 SMTP、FTP、以及 HTTP 等。他们都属于 TCP/IP 协议。
![](https://oss1.aistar.cool/elog-offer-now/509394b2458005d4847e9ef033e23e16.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87)网络设备

### [#](https://javabetter.cn/cs/wangluo.html#%E4%BA%A4%E6%8D%A2%E6%9C%BA)交换机

交换机可以接入多台电脑
每个电脑网卡的 **MAC 地址**都是不一样的，电脑发送数据时，数据头部携带网卡的 MAC 地址，用 MAC 地址标识来不同的电脑
交换机就可以识别数据头部的 MAC 地址来区分不同的电脑
交换机除了能识别不同的电脑，还需要找到电脑连接的**交换机端口**，才能顺利的把数据从相应端口发送出去
交换机通过**自学机制**，把学习到的设备 MAC 地址和交换机端口号添加到 **MAC 地址表**，并根据 MAC 地址表进行数据**转发**

### [#](https://javabetter.cn/cs/wangluo.html#%E8%B7%AF%E7%94%B1%E5%99%A8)路由器

交换机需要记录的 MAC 地址表也越来越多，需要的交换机也越来越多
但是交换机的**容量和性能有限**，MAC 地址表无法记录全世界电脑的 MAC 地址和对应的端口号，MAC 地址表太大也无法快速查找到对应的 MAC 地址表项
于是就有了三层网络设备**路由器**，路由器可以把全世界的网络连接起来
局域网内的网络连接可以使用**交换机**，例如一个公司内的网络或者一个校园内的网络通过交换机连接
不同区域的局域网互联使用**路由器**
那么如何区分不同的网络区域呢？又是如何跨网络区域进行数据转发的呢？
路由器有多个端口，分别连接不同的网络区域，不同网络区域的 IP 地址**网络号不同**
它通过识别目的 IP 地址的**网络号**，再根据**路由表**进行数据转发
![](https://oss1.aistar.cool/elog-offer-now/4f5553da06fd2dac39d1bbec096b3417.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#http)HTTP

**请求方法**
HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。
HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

| 序 号 | 方法    | 描述                                                                                                                                     |
| ----- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| 1     | GET     | 请求指定的页面信息，并返回实体主体。                                                                                                     |
| 2     | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头                                                                          |
| 3     | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
| 4     | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。                                                                                         |
| 5     | DELETE  | 请求服务器删除指定的页面。                                                                                                               |
| 6     | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。                                                                                |
| 7     | OPTIONS | 允许客户端查看服务器的性能。                                                                                                             |
| 8     | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                                                                                               |
| 9     | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。                                                                                       |

**GET 请求和 POST 请求的区别**

1. GET 请求的请求参数是添加到 head 中，可以在 url 中可以看到；POST 请求的请求参数是添加到 body 中，在 url 中不可见。
2. 请求的 url 有长度限制，这个限制由浏览器和 web 服务器决定和设置的，例如 IE 浏览器对 URL 的最大限制为 2083 个字符，如果超过这个数字，提交按钮没有任何反应，因为 GET 请求的参数是添加到 URL 中，所以 GET 请求的 URL 的长度限制需要将请求参数长度也考虑进去。而 POST 请求不用考虑请求参数的长度。
3. GET 请求产生一个数据包; POST 请求产生 2 个数据包，在火狐浏览器中，产生一个数据包，这个区别点在于浏览器的请求机制，先发送请求头，再发送请求体，因为 GET 没有请求体，所以就发送一个数据包，而 POST 包含请求体，所以发送两次数据包，但是由于火狐机制不同，所以发送一个数据包。
4. GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
5. GET 是幂等的，而 POST 不是(幂等表示执行相同的操作，结果也是相同的)
6. GET 是获取数据，POST 是修改数据

### [#](https://javabetter.cn/cs/wangluo.html#%E7%8A%B6%E6%80%81%E7%A0%81)状态码

**状态码由 3 位数字组成，第一位定义响应的类别**
1XX：指示信息，表示请求以接收，继续处理
2XX：成功，表示请求已经被成功接收、理解、接受

- 200 OK 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
- 204 No Content 也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 206 Partial Content 是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

3XX：状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 301 Moved Permanently 表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。
- 302 Moved Permanently 表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问，搜索引擎会抓取新的内容而保存旧的网址。

301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 304 Not Modified 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。

4XX：状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 400 Bad Request 表示客户端请求的报文有错误。
- 401 Unauthorized：缺失或错误的认证，这个状态代码必须和 WWW-Authenticate 报头域一起使用。
- 403 Forbidden 表示服务器禁止访问资源，并不是客户端的请求出错。
- 404 Not Found 表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

5XX：状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 501 Not Implemented 表示客户端请求的功能还不支持。
- 502 Bad Gateway 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务器。
- 504 Gateway Timeout：网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。

**301 和 302 的区别**
301 重定向，指页面永久性转移，表示为资源或页面永久性地转移到了另一个位置。
301 是 HTTP 协议中的一种状态码，当用户或搜索引擎向服务器发出浏览请求时，服务器返回的 HTTP 数据流中头信息中包含状态码 301 ，表示该资源已经永久改变了位置。
302 重定向是页面暂时性转移，搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。

### [#](https://javabetter.cn/cs/wangluo.html#http1-1)HTTP1.1

**长连接**
HTTP 1.1 支持长连接
HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。
HTTP 1.1 则支持持久连接 Persistent Connection，并且默认使用，在同一个 TCP 的连接中可以传送多个 HTTP 请求和响应，多个请求和响应可以重叠，多个请求和响应可以同时进行，更加多的请求头和响应头
HTTP 1.1 的持续连接，也需要增加新的请求头来帮助实现，例如，Connection 请求头的值为 Keep-Alive 时，客户端通知服务器返回本次请求结果后保持连接；Connection 请求头的值为 Close 时，客户端通知服务器返回本次请求结果后关闭连接。
**管道网络传输**
HTTP/1.1 采用了长连接的方式，这使得管道网络传输成为了可能。
即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**
举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求，管道机制则是允许浏览器同时发出 A 请求和 B 请求。
但是服务器还是按照**顺序**，先回应 A 请求，完成后再回应 B 请求，要是 前面的回应特别慢，后面就会有许多请求排队等着。
**Host 字段**
在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。
HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。
此外，服务器应该接受以绝对路径标记的资源请求。
**100Status**
HTTP/1.1 加入了一个新的状态码 100。
客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码 401（Unauthorized）；
如果服务器接收此请求就回送响应码 100，客户端就可以继续发送带实体的完整请求了。
100 状态代码的使用，允许客户端在发 request 消息 body 之前先用 request header 试探一下 server，看 server 要不要接收 request body，再决定要不要发 request body。
**Chunked Transfer Coding**
HTTP/1.1 将发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。
这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。
**Cache**
HTTP/1.1 在 1.0 的基础上加入了一些 Cache 的新特性，当缓存对象的 Age 超过 Expire 时变为 Stable 对象，Cache 不需要直接抛弃 Stable 对象，而是与源服务器进行重新激活。

### [#](https://javabetter.cn/cs/wangluo.html#http2-0)HTTP2.0

**HTTP2.0 和 HTTP1.X 相比的新特性**

- 新的二进制格式，HTTP1.x 的解析是基于文本
- 多路复用，即连接共享，即每一个 request 都是是用作连接共享机制的，一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面
- header 压缩，HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小
- 服务端推送

HTTP/2 还在一定程度上改善了传统的请求 - 应答工作模式，服务不再是被动地响应，也可以**主动**向客户端发送消息。
举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，**减少延时的等待**，也就是服务器推送。
**数据流**
HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。
因此，必须要对数据包做标记，指出它属于哪个回应。
每个请求或回应的所有数据包，称为一个数据流（Stream）。
每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数
客户端还可以**指定数据流的优先级**。优先级高的请求，服务器就先响应该请求。
**HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别**

- HTTP/1.1 的 Pipeling 为若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法；
- HTTP2.0 多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行

### [#](https://javabetter.cn/cs/wangluo.html#http3-0)HTTP3.0

**使用 UDP 协议**
HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。
所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来**。

- HTTP/1.1 中的管道传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了
- HTTP/2 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。

这都是基于 TCP 传输层的问题，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**

### [#](https://javabetter.cn/cs/wangluo.html#https)HTTPS

**HTTP 与 HTTPS 的区别**
HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全

- HTTPS 比 HTTP 更加安全，对搜索引擎更友好，利于 SEO，谷歌、百度优先索引 HTTPS 网页
- HTTPS 需要用到 SSL 证书，而 HTTP 不用
- HTTPS 标准端口 443，HTTP 标准端口 80
- HTTPS 基于传输层，HTTP 基于应用层
- HTTPS 在浏览器显示绿色安全锁，HTTP 没有显示

**工作原理**
HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现
HTTPS 的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：
![](https://oss1.aistar.cool/elog-offer-now/b8e79041cfe365580f8910e1707116f9.png)

- Client 发起一个 HTTPS 的请求
- Server 把事先配置好的公钥证书返回给客户端。
- Client 验证公钥证书：比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书），如果验证通过则继续，不通过则显示警告信息。
- Client 使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给 Server。
- Server 使用自己的私钥解密这个消息，得到对称密钥。至此，Client 和 Server 双方都持有了相同的对称密钥。
- Server 使用对称密钥加密明文内容 A，发送给 Client。
- Client 使用对称密钥解密响应的密文，得到明文内容 A。
- Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的明文内容 B，然后 Server 使用对称密钥解密密文，得到明文内容 B。

#### [#](https://javabetter.cn/cs/wangluo.html#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6)数字证书

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
这就存在些问题，如何保证公钥不被篡改和信任度？
所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将**服务器公钥放在数字证书**（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。
通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。
![](https://oss1.aistar.cool/elog-offer-now/0ee9de562c063f87507d6687fe5c213e.png)

### [#](https://javabetter.cn/cs/wangluo.html#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87)请求报文

**请求头**
HTTP 请求报文由 3 部分组成(请求行+请求头+请求体)
![](https://oss1.aistar.cool/elog-offer-now/966897b2d876233f4dfc7af3f93c9696.png)
**常见的 HTTP 报文头属性**

- Accpet
  - 告诉服务端，客户端接收什么类型的响应
- Referer
  - 表示这是请求是从哪个 URL 进来的,比如想在网上购物，但是不知道选择哪家电商平台，你就去问度娘，说哪家电商的东西便宜啊，然后一堆东西弹出在你面前，第一给就是某宝，当你从这里进入某宝的时候，这个请求报文的 Referer 就是：[www.baidu.com](https://javabetter.cn/cs/www.baidu.com)
- Cache-Control
  - 对缓存进行控制，如一个请求希望响应的内容在客户端缓存一年，或不被缓可以通过这个报文头设置
- Accept-Encoding
  - 这个属性是用来告诉服务器能接受什么编码格式，包括字符编码,压缩形式(一般都是压缩形式)
    - 例如:Accept-Encoding:gzip, deflate(这两种都是压缩格式)
- Host
  - 指定要请求的资源所在的主机和端口
- User-Agent：告诉服务器，客户端使用的操作系统、浏览器版本和名称
- Connection

决定当前事务（三次握手和四次挥手）完成后，是否关闭网络连接。

- 持久连接，事务完成后不关闭网络连接 ： Connection: keep-alive
- 非持久连接，事务完成后关闭网络连接： Connection: close

### [#](https://javabetter.cn/cs/wangluo.html#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87)响应报文

响应报文与请求报文一样，由三个部分组成(响应行,响应头,响应体)
![](https://oss1.aistar.cool/elog-offer-now/1aae4883ba2cceb3c197e601b5415a86.png)
**HTTP 响应报文属性**

- Cache-Control
  - 响应输出到客户端后，服务端通过该属性告诉客户端该怎么控制响应内容的缓存
- ETag
  - 表示你请求资源的版本，如果该资源发生啦变化，那么这个属性也会跟着变
- Location
  - 在重定向中或者创建新资源时使用
- Set-Cookie
  - 服务端可以设置客户端的 cookie

![](https://oss1.aistar.cool/elog-offer-now/880b2806395ced0a748725073ccad9e0.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#tcp)TCP

TCP 是一个传输层协议，提供可靠传输，支持全双工，是一个连接导向的协议。
**双工/单工**
在任何一个时刻，如果数据只能单向发送，就是单工。
如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫作半双工；半双工需要至少 1 条线路。
如果任何时刻数据都可以双向收发，这就是全双工，全双工需要大于 1 条线路。
TCP 是一个双工协议，数据任何时候都可以双向传输。
这就意味着客户端和服务端可以平等地发送、接收信息。

## OSI 七层模型

**物理层**
首先解决两台物理机之间的通信需求，具体就是机器 A 往机器 B 发送比特流，机器 B 能收到比特流。
物理层主要定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率。
主要作用是传输比特流（0101 二进制数据），将比特流转化为电流强弱传输，到达目的后再转化为比特流，即常说的数模转化和模数转换。
这层数据叫做比特。**网卡工作在这层**。
物理层是 OSI 七层模型的物理基础，没有它就谈不上数据传输了
物理层就是由实物所承载的，所以作比喻的话，公路、汽车和飞机等承载货物（数据）的交通工具，就是物理层的象征
**数据链路层**
在传输比特流的过程中，会产生错传、数据传输不完整的可能。
数据链路层定义了**如何格式化数据进行传输**，以及如何控制对物理介质的访问。通常提供错误检测和纠正，以确保数据传输的准确性。
本层将比特数据组成帧，交换机工作在这层，对帧解码，并根据帧中包含的信息把数据发送到正确的接收方。
该层负责物理层面上互连的节点之间的通信传输。例如与 1 个以太网相连的两个节点间的通讯。
常见的协议有 HDLC、PPP、SLIP 等
数据链路层会将 0、1 序列划分为具有意义的数据帧传送给对端（**数据帧的生成与接收**）
**网络层**
随着网络节点的不断增加，点对点通讯需要通过多个节点，如何找到目标节点，如何选择最佳路径成为首要需求。
网络层主要功能是将网络地址转化为对应的物理地址，并决定如何将数据从发送方路由到接收方。
网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点 A 到另一个网络中节点 B 的最佳路径。
由于网络层处理并智能指导数据传送，路由器连接网络隔断，所以路由器属于网络层。
此层的数据称之为数据包。本层需要关注的协议 TCP/IP 协议中的 IP 协议。
网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责**寻址和路由选择**。主要由 IP、ICMP 两个协议组成
网络层将数据从发送端的主机发送到接收端的主机，两台主机间可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址使用的是 IP 地址。IP 地址通过不断转发到更近的 IP 地址，最终可以到达目标地址
**传输层**
随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很长时间，网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发送出去的数据进行切分，切割为一个一个的段落（Segement）发送，其中一个段落丢失是否重传，段落是否按顺序到达，是传输层需要考虑的问题。
传输层解决了主机间的数据传输，数据间的传输可以是不同网络，并且传输层解决了**传输质量**的问题。
传输层需要关注的协议有 TCP/IP 协议中的 TCP 协议和 UDP 协议。
**会话层**
自动收发包，自动寻址。
会话层作用是**负责建立和断开通信连接**，何时建立，断开连接以及保持多久的连接。常见的协议有 ADSP、RPC 等
**表示层**
Linux 给 WIndows 发包，不同系统语法不一致，如 exe 不能在 Linux 下执行，shell 不能在 Windows 不能直接运行。于是需要表示层。
解决**不同系统之间通信语法问题**，在表示层数据将按照网络能理解的方案进行格式化，格式化因所使用网络的不同而不同。
它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有 ASCII、SSL/TLS 等
**应用层**
规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，消息头中必须记录消息体的长度等信息，方便接收方正确解析发送方发送的数据。
应用层旨在更**方便应用从网络中接收的数据**，重点关注 TCP/IP 协议中的 HTTP 协议
四层传输层数据被称作**段**（Segments）；
三层网络层数据被称做**包**（Packages）；
二层数据链路层时数据被称为**帧**（Frames）；
一层物理层时数据被称为**比特流**（Bits）。
![](https://oss1.aistar.cool/elog-offer-now/288606e8dc4e08f4b77444879d4d8200.png)

## [#](https://javabetter.cn/cs/wangluo.html#tcp%E5%92%8Cip%E6%A8%A1%E5%9E%8B)TCP 和 IP 模型

OSI 模型注重通信协议必要的功能；TCP/IP 更强调在计算机上实现协议应该开发哪种程序
**TCP/IP 划分了四层网络模型**

- 第一层：应用层，主要有负责 web 浏览器的 HTTP 协议， 文件传输的 FTP 协议，负责电子邮件的 SMTP 协议，负责域名系统的 DNS 等
- 第二层：传输层，主要是有**可靠传输**的 TCP 协议，特别**高效**的 UDP 协议。主要负责传输应用层的数据包。
- 第三层：网络层，主要是 IP 协议。主要负责寻址（找到目标设备的位置）
- 第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。

![](https://oss1.aistar.cool/elog-offer-now/c6903afab20261ac0b8635d1ef7725b0.png)
**四层网络协议的作用**

- 发送端是由上至下，把上层来的数据在头部加上各层协议的数据（部首）再下发给下层。
- 接受端则由下而上，把从下层接受到的数据进行解密和去掉头部的部首后再发送给上层。
- 层层加密和解密后，应用层最终拿到了需要的数据。

**举个例子：**
我们需要发送一个**index.html**。
两台电脑在应用层都使用 HTTP 协议（即都使用浏览器）。
在传输层，TCP 协议会将 HTTP 协议发送的数据看作一个数据包，并在这个数据包前面加上 TCP 包的一部分信息（部首）
在网络层，IP 协议会将 TCP 协议要发送的数据看作一个数据包，同样的在这个数据包前端加上 IP 协议的部首
在数据链路层，对应的协议也会在 IP 数据包前端加上以太网的部首。
![](https://oss1.aistar.cool/elog-offer-now/3e8d4ec843a238f44a4a5fc164199567.png)
源设备和目标设备通过网线连接，就可以通过物理层的二进制传输数据。
数据链路层，会使用对应的协议找到物理层的二进制数据，解码得到以太网的部首信息和对应的 IP 数据包，再将 IP 数据包传给上层的网络层。
数据链路层>网络层>传输层>应用层，一层层的解码，最后就可以在浏览器中得到目标设备传送过来的**index.html**。
![](https://oss1.aistar.cool/elog-offer-now/47f5d7b9476cf814006fe756b6d9a281.png)
**TCP/IP 协议族**
从字面意义上来讲，TCP/IP 是指**传输层**的 TCP 协议和**网络层**的 IP 协议。
实际上，TCP/IP 只是利用 IP 进行通信时所必须用到的协议群的统称。
具体来说，在网络层是 IP/ICMP 协议、在传输层是 TCP/UDP 协议、在应用层是 SMTP、FTP、以及 HTTP 等。他们都属于 TCP/IP 协议。
![](https://oss1.aistar.cool/elog-offer-now/509394b2458005d4847e9ef033e23e16.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87)网络设备

### [#](https://javabetter.cn/cs/wangluo.html#%E4%BA%A4%E6%8D%A2%E6%9C%BA)交换机

交换机可以接入多台电脑
每个电脑网卡的 **MAC 地址**都是不一样的，电脑发送数据时，数据头部携带网卡的 MAC 地址，用 MAC 地址标识来不同的电脑
交换机就可以识别数据头部的 MAC 地址来区分不同的电脑
交换机除了能识别不同的电脑，还需要找到电脑连接的**交换机端口**，才能顺利的把数据从相应端口发送出去
交换机通过**自学机制**，把学习到的设备 MAC 地址和交换机端口号添加到 **MAC 地址表**，并根据 MAC 地址表进行数据**转发**

### [#](https://javabetter.cn/cs/wangluo.html#%E8%B7%AF%E7%94%B1%E5%99%A8)路由器

交换机需要记录的 MAC 地址表也越来越多，需要的交换机也越来越多
但是交换机的**容量和性能有限**，MAC 地址表无法记录全世界电脑的 MAC 地址和对应的端口号，MAC 地址表太大也无法快速查找到对应的 MAC 地址表项
于是就有了三层网络设备**路由器**，路由器可以把全世界的网络连接起来
局域网内的网络连接可以使用**交换机**，例如一个公司内的网络或者一个校园内的网络通过交换机连接
不同区域的局域网互联使用**路由器**
那么如何区分不同的网络区域呢？又是如何跨网络区域进行数据转发的呢？
路由器有多个端口，分别连接不同的网络区域，不同网络区域的 IP 地址**网络号不同**
它通过识别目的 IP 地址的**网络号**，再根据**路由表**进行数据转发
![](https://oss1.aistar.cool/elog-offer-now/4f5553da06fd2dac39d1bbec096b3417.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#http)HTTP

**请求方法**
HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。
HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

| 序 号 | 方法    | 描述                                                                                                                                     |
| ----- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| 1     | GET     | 请求指定的页面信息，并返回实体主体。                                                                                                     |
| 2     | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头                                                                          |
| 3     | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
| 4     | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。                                                                                         |
| 5     | DELETE  | 请求服务器删除指定的页面。                                                                                                               |
| 6     | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。                                                                                |
| 7     | OPTIONS | 允许客户端查看服务器的性能。                                                                                                             |
| 8     | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                                                                                               |
| 9     | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。                                                                                       |

**GET 请求和 POST 请求的区别**

1. GET 请求的请求参数是添加到 head 中，可以在 url 中可以看到；POST 请求的请求参数是添加到 body 中，在 url 中不可见。
2. 请求的 url 有长度限制，这个限制由浏览器和 web 服务器决定和设置的，例如 IE 浏览器对 URL 的最大限制为 2083 个字符，如果超过这个数字，提交按钮没有任何反应，因为 GET 请求的参数是添加到 URL 中，所以 GET 请求的 URL 的长度限制需要将请求参数长度也考虑进去。而 POST 请求不用考虑请求参数的长度。
3. GET 请求产生一个数据包; POST 请求产生 2 个数据包，在火狐浏览器中，产生一个数据包，这个区别点在于浏览器的请求机制，先发送请求头，再发送请求体，因为 GET 没有请求体，所以就发送一个数据包，而 POST 包含请求体，所以发送两次数据包，但是由于火狐机制不同，所以发送一个数据包。
4. GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
5. GET 是幂等的，而 POST 不是(幂等表示执行相同的操作，结果也是相同的)
6. GET 是获取数据，POST 是修改数据

### [#](https://javabetter.cn/cs/wangluo.html#%E7%8A%B6%E6%80%81%E7%A0%81)状态码

**状态码由 3 位数字组成，第一位定义响应的类别**
1XX：指示信息，表示请求以接收，继续处理
2XX：成功，表示请求已经被成功接收、理解、接受

- 200 OK 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
- 204 No Content 也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 206 Partial Content 是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

3XX：状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 301 Moved Permanently 表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。
- 302 Moved Permanently 表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问，搜索引擎会抓取新的内容而保存旧的网址。

301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 304 Not Modified 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。

4XX：状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 400 Bad Request 表示客户端请求的报文有错误。
- 401 Unauthorized：缺失或错误的认证，这个状态代码必须和 WWW-Authenticate 报头域一起使用。
- 403 Forbidden 表示服务器禁止访问资源，并不是客户端的请求出错。
- 404 Not Found 表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

5XX：状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 501 Not Implemented 表示客户端请求的功能还不支持。
- 502 Bad Gateway 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务器。
- 504 Gateway Timeout：网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。

**301 和 302 的区别**
301 重定向，指页面永久性转移，表示为资源或页面永久性地转移到了另一个位置。
301 是 HTTP 协议中的一种状态码，当用户或搜索引擎向服务器发出浏览请求时，服务器返回的 HTTP 数据流中头信息中包含状态码 301 ，表示该资源已经永久改变了位置。
302 重定向是页面暂时性转移，搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。

### [#](https://javabetter.cn/cs/wangluo.html#http1-1)HTTP1.1

**长连接**
HTTP 1.1 支持长连接
HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。
HTTP 1.1 则支持持久连接 Persistent Connection，并且默认使用，在同一个 TCP 的连接中可以传送多个 HTTP 请求和响应，多个请求和响应可以重叠，多个请求和响应可以同时进行，更加多的请求头和响应头
HTTP 1.1 的持续连接，也需要增加新的请求头来帮助实现，例如，Connection 请求头的值为 Keep-Alive 时，客户端通知服务器返回本次请求结果后保持连接；Connection 请求头的值为 Close 时，客户端通知服务器返回本次请求结果后关闭连接。
**管道网络传输**
HTTP/1.1 采用了长连接的方式，这使得管道网络传输成为了可能。
即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**
举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求，管道机制则是允许浏览器同时发出 A 请求和 B 请求。
但是服务器还是按照**顺序**，先回应 A 请求，完成后再回应 B 请求，要是 前面的回应特别慢，后面就会有许多请求排队等着。
**Host 字段**
在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。
HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。
此外，服务器应该接受以绝对路径标记的资源请求。
**100Status**
HTTP/1.1 加入了一个新的状态码 100。
客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码 401（Unauthorized）；
如果服务器接收此请求就回送响应码 100，客户端就可以继续发送带实体的完整请求了。
100 状态代码的使用，允许客户端在发 request 消息 body 之前先用 request header 试探一下 server，看 server 要不要接收 request body，再决定要不要发 request body。
**Chunked Transfer Coding**
HTTP/1.1 将发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。
这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。
**Cache**
HTTP/1.1 在 1.0 的基础上加入了一些 Cache 的新特性，当缓存对象的 Age 超过 Expire 时变为 Stable 对象，Cache 不需要直接抛弃 Stable 对象，而是与源服务器进行重新激活。

### [#](https://javabetter.cn/cs/wangluo.html#http2-0)HTTP2.0

**HTTP2.0 和 HTTP1.X 相比的新特性**

- 新的二进制格式，HTTP1.x 的解析是基于文本
- 多路复用，即连接共享，即每一个 request 都是是用作连接共享机制的，一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面
- header 压缩，HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小
- 服务端推送

HTTP/2 还在一定程度上改善了传统的请求 - 应答工作模式，服务不再是被动地响应，也可以**主动**向客户端发送消息。
举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，**减少延时的等待**，也就是服务器推送。
**数据流**
HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。
因此，必须要对数据包做标记，指出它属于哪个回应。
每个请求或回应的所有数据包，称为一个数据流（Stream）。
每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数
客户端还可以**指定数据流的优先级**。优先级高的请求，服务器就先响应该请求。
**HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别**

- HTTP/1.1 的 Pipeling 为若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法；
- HTTP2.0 多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行

### [#](https://javabetter.cn/cs/wangluo.html#http3-0)HTTP3.0

**使用 UDP 协议**
HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。
所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来**。

- HTTP/1.1 中的管道传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了
- HTTP/2 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。

这都是基于 TCP 传输层的问题，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**

### [#](https://javabetter.cn/cs/wangluo.html#https)HTTPS

**HTTP 与 HTTPS 的区别**
HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全

- HTTPS 比 HTTP 更加安全，对搜索引擎更友好，利于 SEO，谷歌、百度优先索引 HTTPS 网页
- HTTPS 需要用到 SSL 证书，而 HTTP 不用
- HTTPS 标准端口 443，HTTP 标准端口 80
- HTTPS 基于传输层，HTTP 基于应用层
- HTTPS 在浏览器显示绿色安全锁，HTTP 没有显示

**工作原理**
HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现
HTTPS 的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：
![](https://oss1.aistar.cool/elog-offer-now/b8e79041cfe365580f8910e1707116f9.png)

- Client 发起一个 HTTPS 的请求
- Server 把事先配置好的公钥证书返回给客户端。
- Client 验证公钥证书：比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书），如果验证通过则继续，不通过则显示警告信息。
- Client 使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给 Server。
- Server 使用自己的私钥解密这个消息，得到对称密钥。至此，Client 和 Server 双方都持有了相同的对称密钥。
- Server 使用对称密钥加密明文内容 A，发送给 Client。
- Client 使用对称密钥解密响应的密文，得到明文内容 A。
- Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的明文内容 B，然后 Server 使用对称密钥解密密文，得到明文内容 B。

#### [#](https://javabetter.cn/cs/wangluo.html#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6)数字证书

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
这就存在些问题，如何保证公钥不被篡改和信任度？
所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将**服务器公钥放在数字证书**（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。
通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。
![](https://oss1.aistar.cool/elog-offer-now/0ee9de562c063f87507d6687fe5c213e.png)

### [#](https://javabetter.cn/cs/wangluo.html#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87)请求报文

**请求头**
HTTP 请求报文由 3 部分组成(请求行+请求头+请求体)
![](https://oss1.aistar.cool/elog-offer-now/966897b2d876233f4dfc7af3f93c9696.png)
**常见的 HTTP 报文头属性**

- Accpet
  - 告诉服务端，客户端接收什么类型的响应
- Referer
  - 表示这是请求是从哪个 URL 进来的,比如想在网上购物，但是不知道选择哪家电商平台，你就去问度娘，说哪家电商的东西便宜啊，然后一堆东西弹出在你面前，第一给就是某宝，当你从这里进入某宝的时候，这个请求报文的 Referer 就是：[www.baidu.com](https://javabetter.cn/cs/www.baidu.com)
- Cache-Control
  - 对缓存进行控制，如一个请求希望响应的内容在客户端缓存一年，或不被缓可以通过这个报文头设置
- Accept-Encoding
  - 这个属性是用来告诉服务器能接受什么编码格式，包括字符编码,压缩形式(一般都是压缩形式)
    - 例如:Accept-Encoding:gzip, deflate(这两种都是压缩格式)
- Host
  - 指定要请求的资源所在的主机和端口
- User-Agent：告诉服务器，客户端使用的操作系统、浏览器版本和名称
- Connection

决定当前事务（三次握手和四次挥手）完成后，是否关闭网络连接。

- 持久连接，事务完成后不关闭网络连接 ： Connection: keep-alive
- 非持久连接，事务完成后关闭网络连接： Connection: close

### [#](https://javabetter.cn/cs/wangluo.html#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87)响应报文

响应报文与请求报文一样，由三个部分组成(响应行,响应头,响应体)
![](https://oss1.aistar.cool/elog-offer-now/1aae4883ba2cceb3c197e601b5415a86.png)
**HTTP 响应报文属性**

- Cache-Control
  - 响应输出到客户端后，服务端通过该属性告诉客户端该怎么控制响应内容的缓存
- ETag
  - 表示你请求资源的版本，如果该资源发生啦变化，那么这个属性也会跟着变
- Location
  - 在重定向中或者创建新资源时使用
- Set-Cookie
  - 服务端可以设置客户端的 cookie

![](https://oss1.aistar.cool/elog-offer-now/880b2806395ced0a748725073ccad9e0.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#tcp)TCP

TCP 是一个传输层协议，提供可靠传输，支持全双工，是一个连接导向的协议。
**双工/单工**
在任何一个时刻，如果数据只能单向发送，就是单工。
如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫作半双工；半双工需要至少 1 条线路。
如果任何时刻数据都可以双向收发，这就是全双工，全双工需要大于 1 条线路。
TCP 是一个双工协议，数据任何时候都可以双向传输。
这就意味着客户端和服务端可以平等地发送、接收信息。

## OSI 七层模型

**物理层**
首先解决两台物理机之间的通信需求，具体就是机器 A 往机器 B 发送比特流，机器 B 能收到比特流。
物理层主要定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率。
主要作用是传输比特流（0101 二进制数据），将比特流转化为电流强弱传输，到达目的后再转化为比特流，即常说的数模转化和模数转换。
这层数据叫做比特。**网卡工作在这层**。
物理层是 OSI 七层模型的物理基础，没有它就谈不上数据传输了
物理层就是由实物所承载的，所以作比喻的话，公路、汽车和飞机等承载货物（数据）的交通工具，就是物理层的象征
**数据链路层**
在传输比特流的过程中，会产生错传、数据传输不完整的可能。
数据链路层定义了**如何格式化数据进行传输**，以及如何控制对物理介质的访问。通常提供错误检测和纠正，以确保数据传输的准确性。
本层将比特数据组成帧，交换机工作在这层，对帧解码，并根据帧中包含的信息把数据发送到正确的接收方。
该层负责物理层面上互连的节点之间的通信传输。例如与 1 个以太网相连的两个节点间的通讯。
常见的协议有 HDLC、PPP、SLIP 等
数据链路层会将 0、1 序列划分为具有意义的数据帧传送给对端（**数据帧的生成与接收**）
**网络层**
随着网络节点的不断增加，点对点通讯需要通过多个节点，如何找到目标节点，如何选择最佳路径成为首要需求。
网络层主要功能是将网络地址转化为对应的物理地址，并决定如何将数据从发送方路由到接收方。
网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点 A 到另一个网络中节点 B 的最佳路径。
由于网络层处理并智能指导数据传送，路由器连接网络隔断，所以路由器属于网络层。
此层的数据称之为数据包。本层需要关注的协议 TCP/IP 协议中的 IP 协议。
网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责**寻址和路由选择**。主要由 IP、ICMP 两个协议组成
网络层将数据从发送端的主机发送到接收端的主机，两台主机间可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址使用的是 IP 地址。IP 地址通过不断转发到更近的 IP 地址，最终可以到达目标地址
**传输层**
随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很长时间，网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发送出去的数据进行切分，切割为一个一个的段落（Segement）发送，其中一个段落丢失是否重传，段落是否按顺序到达，是传输层需要考虑的问题。
传输层解决了主机间的数据传输，数据间的传输可以是不同网络，并且传输层解决了**传输质量**的问题。
传输层需要关注的协议有 TCP/IP 协议中的 TCP 协议和 UDP 协议。
**会话层**
自动收发包，自动寻址。
会话层作用是**负责建立和断开通信连接**，何时建立，断开连接以及保持多久的连接。常见的协议有 ADSP、RPC 等
**表示层**
Linux 给 WIndows 发包，不同系统语法不一致，如 exe 不能在 Linux 下执行，shell 不能在 Windows 不能直接运行。于是需要表示层。
解决**不同系统之间通信语法问题**，在表示层数据将按照网络能理解的方案进行格式化，格式化因所使用网络的不同而不同。
它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有 ASCII、SSL/TLS 等
**应用层**
规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，消息头中必须记录消息体的长度等信息，方便接收方正确解析发送方发送的数据。
应用层旨在更**方便应用从网络中接收的数据**，重点关注 TCP/IP 协议中的 HTTP 协议
四层传输层数据被称作**段**（Segments）；
三层网络层数据被称做**包**（Packages）；
二层数据链路层时数据被称为**帧**（Frames）；
一层物理层时数据被称为**比特流**（Bits）。
![](https://oss1.aistar.cool/elog-offer-now/288606e8dc4e08f4b77444879d4d8200.png)

## [#](https://javabetter.cn/cs/wangluo.html#tcp%E5%92%8Cip%E6%A8%A1%E5%9E%8B)TCP 和 IP 模型

OSI 模型注重通信协议必要的功能；TCP/IP 更强调在计算机上实现协议应该开发哪种程序
**TCP/IP 划分了四层网络模型**

- 第一层：应用层，主要有负责 web 浏览器的 HTTP 协议， 文件传输的 FTP 协议，负责电子邮件的 SMTP 协议，负责域名系统的 DNS 等
- 第二层：传输层，主要是有**可靠传输**的 TCP 协议，特别**高效**的 UDP 协议。主要负责传输应用层的数据包。
- 第三层：网络层，主要是 IP 协议。主要负责寻址（找到目标设备的位置）
- 第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。

![](https://oss1.aistar.cool/elog-offer-now/c6903afab20261ac0b8635d1ef7725b0.png)
**四层网络协议的作用**

- 发送端是由上至下，把上层来的数据在头部加上各层协议的数据（部首）再下发给下层。
- 接受端则由下而上，把从下层接受到的数据进行解密和去掉头部的部首后再发送给上层。
- 层层加密和解密后，应用层最终拿到了需要的数据。

**举个例子：**
我们需要发送一个**index.html**。
两台电脑在应用层都使用 HTTP 协议（即都使用浏览器）。
在传输层，TCP 协议会将 HTTP 协议发送的数据看作一个数据包，并在这个数据包前面加上 TCP 包的一部分信息（部首）
在网络层，IP 协议会将 TCP 协议要发送的数据看作一个数据包，同样的在这个数据包前端加上 IP 协议的部首
在数据链路层，对应的协议也会在 IP 数据包前端加上以太网的部首。
![](https://oss1.aistar.cool/elog-offer-now/3e8d4ec843a238f44a4a5fc164199567.png)
源设备和目标设备通过网线连接，就可以通过物理层的二进制传输数据。
数据链路层，会使用对应的协议找到物理层的二进制数据，解码得到以太网的部首信息和对应的 IP 数据包，再将 IP 数据包传给上层的网络层。
数据链路层>网络层>传输层>应用层，一层层的解码，最后就可以在浏览器中得到目标设备传送过来的**index.html**。
![](https://oss1.aistar.cool/elog-offer-now/47f5d7b9476cf814006fe756b6d9a281.png)
**TCP/IP 协议族**
从字面意义上来讲，TCP/IP 是指**传输层**的 TCP 协议和**网络层**的 IP 协议。
实际上，TCP/IP 只是利用 IP 进行通信时所必须用到的协议群的统称。
具体来说，在网络层是 IP/ICMP 协议、在传输层是 TCP/UDP 协议、在应用层是 SMTP、FTP、以及 HTTP 等。他们都属于 TCP/IP 协议。
![](https://oss1.aistar.cool/elog-offer-now/509394b2458005d4847e9ef033e23e16.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87)网络设备

### [#](https://javabetter.cn/cs/wangluo.html#%E4%BA%A4%E6%8D%A2%E6%9C%BA)交换机

交换机可以接入多台电脑
每个电脑网卡的 **MAC 地址**都是不一样的，电脑发送数据时，数据头部携带网卡的 MAC 地址，用 MAC 地址标识来不同的电脑
交换机就可以识别数据头部的 MAC 地址来区分不同的电脑
交换机除了能识别不同的电脑，还需要找到电脑连接的**交换机端口**，才能顺利的把数据从相应端口发送出去
交换机通过**自学机制**，把学习到的设备 MAC 地址和交换机端口号添加到 **MAC 地址表**，并根据 MAC 地址表进行数据**转发**

### [#](https://javabetter.cn/cs/wangluo.html#%E8%B7%AF%E7%94%B1%E5%99%A8)路由器

交换机需要记录的 MAC 地址表也越来越多，需要的交换机也越来越多
但是交换机的**容量和性能有限**，MAC 地址表无法记录全世界电脑的 MAC 地址和对应的端口号，MAC 地址表太大也无法快速查找到对应的 MAC 地址表项
于是就有了三层网络设备**路由器**，路由器可以把全世界的网络连接起来
局域网内的网络连接可以使用**交换机**，例如一个公司内的网络或者一个校园内的网络通过交换机连接
不同区域的局域网互联使用**路由器**
那么如何区分不同的网络区域呢？又是如何跨网络区域进行数据转发的呢？
路由器有多个端口，分别连接不同的网络区域，不同网络区域的 IP 地址**网络号不同**
它通过识别目的 IP 地址的**网络号**，再根据**路由表**进行数据转发
![](https://oss1.aistar.cool/elog-offer-now/4f5553da06fd2dac39d1bbec096b3417.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#http)HTTP

**请求方法**
HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。
HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

| 序 号 | 方法    | 描述                                                                                                                                     |
| ----- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| 1     | GET     | 请求指定的页面信息，并返回实体主体。                                                                                                     |
| 2     | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头                                                                          |
| 3     | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
| 4     | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。                                                                                         |
| 5     | DELETE  | 请求服务器删除指定的页面。                                                                                                               |
| 6     | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。                                                                                |
| 7     | OPTIONS | 允许客户端查看服务器的性能。                                                                                                             |
| 8     | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                                                                                               |
| 9     | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。                                                                                       |

**GET 请求和 POST 请求的区别**

1. GET 请求的请求参数是添加到 head 中，可以在 url 中可以看到；POST 请求的请求参数是添加到 body 中，在 url 中不可见。
2. 请求的 url 有长度限制，这个限制由浏览器和 web 服务器决定和设置的，例如 IE 浏览器对 URL 的最大限制为 2083 个字符，如果超过这个数字，提交按钮没有任何反应，因为 GET 请求的参数是添加到 URL 中，所以 GET 请求的 URL 的长度限制需要将请求参数长度也考虑进去。而 POST 请求不用考虑请求参数的长度。
3. GET 请求产生一个数据包; POST 请求产生 2 个数据包，在火狐浏览器中，产生一个数据包，这个区别点在于浏览器的请求机制，先发送请求头，再发送请求体，因为 GET 没有请求体，所以就发送一个数据包，而 POST 包含请求体，所以发送两次数据包，但是由于火狐机制不同，所以发送一个数据包。
4. GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
5. GET 是幂等的，而 POST 不是(幂等表示执行相同的操作，结果也是相同的)
6. GET 是获取数据，POST 是修改数据

### [#](https://javabetter.cn/cs/wangluo.html#%E7%8A%B6%E6%80%81%E7%A0%81)状态码

**状态码由 3 位数字组成，第一位定义响应的类别**
1XX：指示信息，表示请求以接收，继续处理
2XX：成功，表示请求已经被成功接收、理解、接受

- 200 OK 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
- 204 No Content 也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 206 Partial Content 是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

3XX：状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 301 Moved Permanently 表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。
- 302 Moved Permanently 表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问，搜索引擎会抓取新的内容而保存旧的网址。

301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 304 Not Modified 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。

4XX：状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 400 Bad Request 表示客户端请求的报文有错误。
- 401 Unauthorized：缺失或错误的认证，这个状态代码必须和 WWW-Authenticate 报头域一起使用。
- 403 Forbidden 表示服务器禁止访问资源，并不是客户端的请求出错。
- 404 Not Found 表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

5XX：状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 501 Not Implemented 表示客户端请求的功能还不支持。
- 502 Bad Gateway 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务器。
- 504 Gateway Timeout：网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。

**301 和 302 的区别**
301 重定向，指页面永久性转移，表示为资源或页面永久性地转移到了另一个位置。
301 是 HTTP 协议中的一种状态码，当用户或搜索引擎向服务器发出浏览请求时，服务器返回的 HTTP 数据流中头信息中包含状态码 301 ，表示该资源已经永久改变了位置。
302 重定向是页面暂时性转移，搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。

### [#](https://javabetter.cn/cs/wangluo.html#http1-1)HTTP1.1

**长连接**
HTTP 1.1 支持长连接
HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。
HTTP 1.1 则支持持久连接 Persistent Connection，并且默认使用，在同一个 TCP 的连接中可以传送多个 HTTP 请求和响应，多个请求和响应可以重叠，多个请求和响应可以同时进行，更加多的请求头和响应头
HTTP 1.1 的持续连接，也需要增加新的请求头来帮助实现，例如，Connection 请求头的值为 Keep-Alive 时，客户端通知服务器返回本次请求结果后保持连接；Connection 请求头的值为 Close 时，客户端通知服务器返回本次请求结果后关闭连接。
**管道网络传输**
HTTP/1.1 采用了长连接的方式，这使得管道网络传输成为了可能。
即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**
举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求，管道机制则是允许浏览器同时发出 A 请求和 B 请求。
但是服务器还是按照**顺序**，先回应 A 请求，完成后再回应 B 请求，要是 前面的回应特别慢，后面就会有许多请求排队等着。
**Host 字段**
在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。
HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。
此外，服务器应该接受以绝对路径标记的资源请求。
**100Status**
HTTP/1.1 加入了一个新的状态码 100。
客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码 401（Unauthorized）；
如果服务器接收此请求就回送响应码 100，客户端就可以继续发送带实体的完整请求了。
100 状态代码的使用，允许客户端在发 request 消息 body 之前先用 request header 试探一下 server，看 server 要不要接收 request body，再决定要不要发 request body。
**Chunked Transfer Coding**
HTTP/1.1 将发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。
这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。
**Cache**
HTTP/1.1 在 1.0 的基础上加入了一些 Cache 的新特性，当缓存对象的 Age 超过 Expire 时变为 Stable 对象，Cache 不需要直接抛弃 Stable 对象，而是与源服务器进行重新激活。

### [#](https://javabetter.cn/cs/wangluo.html#http2-0)HTTP2.0

**HTTP2.0 和 HTTP1.X 相比的新特性**

- 新的二进制格式，HTTP1.x 的解析是基于文本
- 多路复用，即连接共享，即每一个 request 都是是用作连接共享机制的，一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面
- header 压缩，HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小
- 服务端推送

HTTP/2 还在一定程度上改善了传统的请求 - 应答工作模式，服务不再是被动地响应，也可以**主动**向客户端发送消息。
举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，**减少延时的等待**，也就是服务器推送。
**数据流**
HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。
因此，必须要对数据包做标记，指出它属于哪个回应。
每个请求或回应的所有数据包，称为一个数据流（Stream）。
每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数
客户端还可以**指定数据流的优先级**。优先级高的请求，服务器就先响应该请求。
**HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别**

- HTTP/1.1 的 Pipeling 为若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法；
- HTTP2.0 多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行

### [#](https://javabetter.cn/cs/wangluo.html#http3-0)HTTP3.0

**使用 UDP 协议**
HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。
所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来**。

- HTTP/1.1 中的管道传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了
- HTTP/2 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。

这都是基于 TCP 传输层的问题，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**

### [#](https://javabetter.cn/cs/wangluo.html#https)HTTPS

**HTTP 与 HTTPS 的区别**
HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全

- HTTPS 比 HTTP 更加安全，对搜索引擎更友好，利于 SEO，谷歌、百度优先索引 HTTPS 网页
- HTTPS 需要用到 SSL 证书，而 HTTP 不用
- HTTPS 标准端口 443，HTTP 标准端口 80
- HTTPS 基于传输层，HTTP 基于应用层
- HTTPS 在浏览器显示绿色安全锁，HTTP 没有显示

**工作原理**
HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现
HTTPS 的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：
![](https://oss1.aistar.cool/elog-offer-now/b8e79041cfe365580f8910e1707116f9.png)

- Client 发起一个 HTTPS 的请求
- Server 把事先配置好的公钥证书返回给客户端。
- Client 验证公钥证书：比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书），如果验证通过则继续，不通过则显示警告信息。
- Client 使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给 Server。
- Server 使用自己的私钥解密这个消息，得到对称密钥。至此，Client 和 Server 双方都持有了相同的对称密钥。
- Server 使用对称密钥加密明文内容 A，发送给 Client。
- Client 使用对称密钥解密响应的密文，得到明文内容 A。
- Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的明文内容 B，然后 Server 使用对称密钥解密密文，得到明文内容 B。

#### [#](https://javabetter.cn/cs/wangluo.html#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6)数字证书

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
这就存在些问题，如何保证公钥不被篡改和信任度？
所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将**服务器公钥放在数字证书**（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。
通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。
![](https://oss1.aistar.cool/elog-offer-now/0ee9de562c063f87507d6687fe5c213e.png)

### [#](https://javabetter.cn/cs/wangluo.html#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87)请求报文

**请求头**
HTTP 请求报文由 3 部分组成(请求行+请求头+请求体)
![](https://oss1.aistar.cool/elog-offer-now/966897b2d876233f4dfc7af3f93c9696.png)
**常见的 HTTP 报文头属性**

- Accpet
  - 告诉服务端，客户端接收什么类型的响应
- Referer
  - 表示这是请求是从哪个 URL 进来的,比如想在网上购物，但是不知道选择哪家电商平台，你就去问度娘，说哪家电商的东西便宜啊，然后一堆东西弹出在你面前，第一给就是某宝，当你从这里进入某宝的时候，这个请求报文的 Referer 就是：[www.baidu.com](https://javabetter.cn/cs/www.baidu.com)
- Cache-Control
  - 对缓存进行控制，如一个请求希望响应的内容在客户端缓存一年，或不被缓可以通过这个报文头设置
- Accept-Encoding
  - 这个属性是用来告诉服务器能接受什么编码格式，包括字符编码,压缩形式(一般都是压缩形式)
    - 例如:Accept-Encoding:gzip, deflate(这两种都是压缩格式)
- Host
  - 指定要请求的资源所在的主机和端口
- User-Agent：告诉服务器，客户端使用的操作系统、浏览器版本和名称
- Connection

决定当前事务（三次握手和四次挥手）完成后，是否关闭网络连接。

- 持久连接，事务完成后不关闭网络连接 ： Connection: keep-alive
- 非持久连接，事务完成后关闭网络连接： Connection: close

### [#](https://javabetter.cn/cs/wangluo.html#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87)响应报文

响应报文与请求报文一样，由三个部分组成(响应行,响应头,响应体)
![](https://oss1.aistar.cool/elog-offer-now/1aae4883ba2cceb3c197e601b5415a86.png)
**HTTP 响应报文属性**

- Cache-Control
  - 响应输出到客户端后，服务端通过该属性告诉客户端该怎么控制响应内容的缓存
- ETag
  - 表示你请求资源的版本，如果该资源发生啦变化，那么这个属性也会跟着变
- Location
  - 在重定向中或者创建新资源时使用
- Set-Cookie
  - 服务端可以设置客户端的 cookie

![](https://oss1.aistar.cool/elog-offer-now/880b2806395ced0a748725073ccad9e0.jpeg)

## [#](https://javabetter.cn/cs/wangluo.html#tcp)TCP

TCP 是一个传输层协议，提供可靠传输，支持全双工，是一个连接导向的协议。
**双工/单工**
在任何一个时刻，如果数据只能单向发送，就是单工。
如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫作半双工；半双工需要至少 1 条线路。
如果任何时刻数据都可以双向收发，这就是全双工，全双工需要大于 1 条线路。
TCP 是一个双工协议，数据任何时候都可以双向传输。
这就意味着客户端和服务端可以平等地发送、接收信息。
